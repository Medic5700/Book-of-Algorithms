"""
By: Medic5700

An implementation of a Meta CPU simulator Engine to allow a better and standardized way to create a customized CPU and ISA to illistrate bitwise instructions in lowlevel algorithms.
This project is geared towards demonstrating algorithms, and therefor generalizes a lot of details. EX: bitLength is settable, instruction words are one memroy element big, etc

IE: I want to try and directly compair different assembly algorithms with a custom instruction set, and a specific memory layout.

Note: Everything above line ~4350 is considered legacy code (working prototype v3), and below is the current implementation (non-working prototype v4)

Development Stack:
    Python 3.10 or greater (required for variable annotations support)
    A terminal that supports ANSI (IE: default Ubuntu Terminal or the "Windows Terminal" app for Windows)

Goals:
    A CPU simulator that can simulate CPU instructions and architectures at a high level (performance/speed/efficiency is sacrificed)
    Allows for creating and testing a CPU 'instruction set' at a high level.
    There is enough functionality to be a teaching tool.
        Allow easy creation of instruction sets for teaching/documentation/instructional purposes. 
            IE: this is everything this specific CPU instruction does and interacts with in these 15 lines of source code
        Includes a customizable (if unstable) parser to allow for parsing multiple different low level assembly languages.
            This allows for simulating old CPUs (IE: the MOS 6502) with native source code.
            (Holy Hell this is very outside the box compaired to how parsers should work.)
    Allow for meaningfull compairisons between various low level algorithms on the same architectures using various metrics (memory accesses, energy usage, etc)
    Allow for meaningfull compairisons between various architectures running the same algorithms using various metrics (energy usage, execution cycles, etc)
    A modular simulator where various things can be swapped in and out. IE: swapping in a different instruction set, different 'displays', different memory configurations, etc.

Quick Start: <==========================================================================================================
    This project is in the 'early prototype' stage.
    Version 3 is usable, but is considered legacy since the changes needed to be in line with the Goals above warrented a rewrite.
        Search for the below for class definitions and examples of how to use the CPU simulator:
            class CPUsim
            class TestDefaultSimplePrograms(unittest.TestCase)
            class RiscV
            class TestRISCV(unittest.TestCase)
    Version 4 is not usable and is currently being worked on.
        Search for the below for class definitions:
            class CPUsim_v4
            class ParseNode(ABC)

Getting Started: <======================================================================================================
    Note: this is a prototype, so the entire API is in flux
    refer to "def _testProgram1_defaultMultiply" for a simple example of a possible use case. (for a simuler example in RISCV, refer to "def _testProgram1_RISCVMultiply")
    refer to "class RiscV" for a mockup of how it could be used to 'create' a processor instruction set at a highlevel.

API
#TODO

API Detailed (Depreciated)
    class CPUsim
        *var state                                          Contains the current registers, stored as 2-dimension dictionary IE: state["registers"][0] = register 0
        *var lastState                                      Contains the state of the registers from the last cycle. Structure is same as 'state'
        *var config                                         Contains meta information on every register (bitLength, aliases, notes, show?). stored as 3-dimension dictionary IE: config["r"][0]["bitLength"] = bitLength of register r0
        var stats                      #TODO not implimented
        var engine                     #TODO partially implimented

        <=  Setting Up =======================================================>
        *def configSetDisplay                               Allows loading a different display interface (default loads 'class DisplaySimpleAndClean')
        *def configSetInstructionSet                        Allows loading a different instruction set (default loads 'class InstructionSetDefault')
        *def configSetParser                                Allows loading a different parser (default loads 'class ParseDefault')
        def configSetPostCycleFunction                      Allows changing the function that executes after every cycle (default loads 'def _postCycleUserDefault')
        *def configAddRegister                              Adds x amount of registers with 'key' name
        def configAddFlag                                   Adds a flag register with 'index' name
        *def configConfigRegister                           Adds or modifies a specific register (key/index pair), and it's properties
        *def inject                                         Writes a number directly to a register
        *def extract                                        Get a number directly from a register
        def _postCycleUserDefault                           The function that executes after every cycle (loaded by default), copies new state to old state, resets 'flag' registers, etc]

        <=  Running Code =====================================================>
        *def linkAndLoad                                    Takes in source code, 'compiles' it, loads it into memory
        *def run                                            Runs code (use after 'def linkAndLoad')
        *def lazy                  #TODO not implimented    Takes in source code, 'compiles' it, runs it (without loading it into main memory)
        def _postEngineTick                                 

        class compileDefault
            def compile

        <=  Available Displays ===============================================>
        *class DisplaySimpleAndClean                        The default display, simple and clean for showing execution statuses and register values
            def runtime                                     Runs after every cycle, displays status/contents of registers
            def postrun                                     Runs after execution has halted
        *class DisplaySilent                                Intentionally displays nothing
            def runtime
            def postrun

        <=  Parser Stuff =====================================================>
        *class ParseDefault                                 Contains the tools to build a customized (and partially flawed) assembly parser. Turns assembly source code into a parse tree.
            *class Node                                     A parse tree Node
                var type
                var token
                var child
                var parent
                var nodePrevious
                var nodeNext
                var lineNum
                var charNum
                def append
                def copyInfo
                def copyDeep
                def replace
                def remove
            *def parseCode                                  Takes assembly source code, uses a series of rules to turn it into a parse tree. See 'class RiscVParser' for customization example.
            def _tokenize                                   The inital tokenizer
            def ruleCastInts                                The below are a collection of rules that manipulate the parse tree, indirectly 'parsing' the source code
            def ruleCastHex
            def ruleRemoveEmptyLines
            def ruleRemoveLeadingWhitespace
            def ruleStringSimple                            Known issue: due to the structure of the parser, there is no way to combine this rule and 'def ruleFilterLineComments' without 'z-fighting'. Would require new rule that handles string AND comments together.
            def ruleFilterLineComments                      Known issue: due to the structure of the parser, there is no way to combine this rule and 'def ruleStringSimple' without 'z-fighting'. Would require new rule that handles string AND comments together.
            def ruleContainer
            def ruleFindLabels
            def ruleLabelNamespace
            def ruleRemoveToken
            def ruleSplitLines
            def ruleSplitTokens
            def ruleNestContainersIntoInstructions
            def ruleLowerCase
            def ruleApplyAlias
            def ruleFilterBlockComments             #TODO
            def ruleFindDirectives                  #TODO   not sure if needed after engine rework
            
        <=  Instruction Definition Stuff =====================================>
        *class InstructionSetDefault                        A simplified instruction set implimentation
            *var instructionSet
            var stats
            var directives
            *def __init__                                   This is where the instruction set is 'mapped' to keywords and arguments. See 'class RiscVISA.__init__' for an advanced example
            def verifyMemoryLayout          #TODO           Called on instruction set import, to verify that the memory layout is valid for this instruction set (IE: it has 'r' registers, 'm' memory, etc)
            def redirect                                    
            def enforceImm
            def enforceRegisterAccess       #TODO
            def int2bits
            def bits2int
            def opNop                                       The below are a number of base instructions that can be put together to make an instruction set
            def opAdd
            def opMultiply
            def opTwosCompliment
            def opAND
            def opOR
            def opXOR
            def opNOT
            def opJump
            def opShiftL
            def opShiftR
            def opHalt                      #TODO Still figuring out syscalls

    <=  Testing defaults in Module ===========================================>
    class TestDefault
        def __init__
        def testDefault                                     Tests that CPU is instatiated correctly
        def _testInstructions                               Instantiates CPU and runs a test program to test individual instructions
        def testInstruction                                 Tests instructions with various inputs and configurations
        def _testVLIW
        def testVLIW                                        Tests VLIW (Very Long Instruction Word) support
        def _testProgram1_defaultMultiply                   Instantiates a CPU and runs a test program (multiplication)
        def testProgram1                                    Runs (multiplication) test program with various inputs in different configurations

    <=  Example Partial Implimentation of RiscV ==============================> #Work in progress
    class RiscV                                             A more advanced example of creating a custom CPU
        var CPU                                             Contains an initialized instance of 'class CPUsim'
        def __init__                                        Sets up the CPU registers and memory and stuff
        def postCycle
        class RiscVISA
            var instructionSet
            var stats
            var directives
            def __init__                                    An advanced example of a customized instruction set
            def opSetLessThan                               A customized instruction
        class RiscVParser                                   A customized parser for loading RiscV like assembly code
            def parseCode                                   The customized parser
            def ruleContainerTokensFollowingInstruction     A customized rule

    class TestRISCV
        def __init__
        def _testProgram1_RISCVMultiply                     Instantiates a CPU and runs a test program (multiplication)
        def testProgram1                                    Runs (multiplication) test program with various inputs in different configurations

Execution Loop:
    #TODO document main execution loop

Data Structures:
    #register state datastructure
    #state['key']['index'] = int(value)
    #see 'def configConfigRegister' for full discription/initialization
    var state : dict[
        var key : str,
        dict[
            var index : int or str,
            var value : int
        ]
    ]
    state = {i : {j : 0 for j in ['index', 0]} for i in ['key']}

    #register config datastructure
    #config['key']['index']['property'] = value
    #see 'def configConfigRegister' for full discription/initialization
    var config : dict[
        var key : str,
        dict[
            var index : int or str,
            dict[
                -> 'bitLength' : str        = int
                -> 'show' : str             = bool
                -> 'alias' : str            = list[str]
                -> 'latencyCycles' : str    = int
                -> 'energy' : str           = int
                -> 'note' : str             = str
            ]
        ]
    ]
    config = {i : {j : {'bitLength':1, 'show':True, 'alias':['str1','str2'], 'latencyCycle':0, 'energy':0, 'note':'note'} for j in ['index', 0]} for i in ['key']}

    #TODO include stuff on datastructures

Test Cases to impliment:
    These test cases are various ways the CPU should be able to stretch and require functionality that should be implimented.
    Dafault
        Meant for teaching or just 'jumping right it'
        Not meant to be complex
        All defaults should be geared towards 'just working'
        #TODO
            load and store instructions
    RISCV
        A real world example and usecase
        Due to the multiple versions, can demonstrait how instructions and configurations can be 'added' for each version
        Has a robust (if confusing) ecosystem and toolchains
        has psudo instructions (which should be handled at the parser level, not instruction ISA level)
        #TODO
            proper alias handling
    Subleq
        A single instruction language
        http://mazonka.com/subleq/
        https://en.wikipedia.org/wiki/One-instruction_set_computer#Subtract_and_branch_if_less_than_or_equal_to_zero
        Kind of what CPUSimulator was built for, quickly prototyping stuff like this
        Has an actual toolchain that can compile C into assembly (IE: a list of tuples of three numbers representing operands)
    6502
        An old CPU from the Commador64 and CommanderX16 (opensource modern almost emulator/reimagining)
        A real world example, and an iconic processor
        An interesting memory layout where the first 512? bytes are accessable faster then the rest of memory
        It is simple enough where it is feasable to make it
        Has inturupts (Raises an inturupt at 60Hz for timekeeping)
        https://github.com/commanderx16/x16-emulator
    Brainfuck
        A simple and weird programming language, simple enough to be implimented here
        https://en.wikipedia.org/wiki/Brainfuck
        https://esolangs.org/wiki/Brainfuck
        has input and output, a good test for making devices/input/output/etc
        Program is stored in seperate memory, a good test for loading programs into not main memory
        The defaultDisplay will need to highlight the individual characters in the instruction line
        CPUSim Feature Requirements
            impliment IO instruction subsystems (IE: devices, instruction operations, etc)
    TIS-100
        It's a made up processor from a puzzle game (or similar name)
        Has multiple CPUs interacting together, which is a good test case for that kind of functionality
        Fairly simple instruction set
        The individual CPUs can be 'blocked' by full input/output buffers, which is a unique functionality
        This kind of idea is an idea I've had for a long time, and how to scale it up
    Magic Square of Squares
        A 3x3 grid where each square has a unique int that is squared. The sum of each row, column, and diagonal should be the same number
            It's an unsolved math puzzle thing that has yet to be proved or disproved on wheather it's possible.
            Can make multiple programs to try every int combination to use as an example of how different architectures use different amounts of energy
            The goal of the program isn't to find the answer, but to help illustrate possible ways to find the lowest upper lower bound to the computational resources needed to check for said solution
            A real world, if abstract, problem
        algorithm test cases
            RiscV
            16-bit CPU
            memory access intensive algorithm
            int op only CPU
            with/without branch prediction
        CPUSim Feature Requirements
            Energy tracking (for memory access, instruction fetching, computation, etc)
            An implimented Modular Meta Memory Managment Unit (MMMMU) (for energy tracking of memory access, instruction fetching, cache hits, etc)
            Speculative execution/branch prediction (having speculative execution with multiple execution units running could drastically change the energy profile of an algorithm)
            Multiple execution units/ports (for out of order execution)
    AMD Bulldozer
        https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)
        This CPU is special as each pair of CPU cores shared a single FPU, thus two individual threads running Floating Point calculations would be bottlenecked by the single FPU
        Would be implimented as a single CPU with hyperThreading of two threads, where the schedualer assigns instructions to specific Execution Ports based on which hyperThread the instructions are from
            IE: thread1 can assign intructions to portInt1, portInt2, portFPU. thread2 can assign instruction to portInt3, portInt4, portFPU. Thus execution unit portFPU is shared between threads
    #TODO a stack based CPU
    IBM Z16 CPU
        https://www.youtube.com/watch?v=z6u_oNIXFuU     # TechTechPotato - This is How IBM Will Revolutionize PC Gaming
        All the CPU cores has a massive private L2 cache (32 MB)[normal L2 cashe is usually 512 KB], but with a higher latency then standard L2 cache
        No L3 cache, in the standard sense
        When data is evicted from L2 from a particular core, the data is stored on another core's L2 cache (if there is space) and labled as virtual L3
        When data is evicted from virtual L3, the data is stored on another CPU die/socket's L2 cache (if there is space) and labled as virtual L4
    Photonic Tensor AI Accelerator
        https://www.youtube.com/watch?v=mt8I71VUazw     # Anastasi In Tech - This New Chip Could Change Everything
        Uses photonic computing to accelerate part of the AI computation
        The key part is that since multiple frequencies of light can go through the photonic logic gates at the same time, you can run multiple computations at the same time
        IE: the 'photonic tensorcore' is able to run a massivly parrallel vector computation, for large performance
        There is a traditional integrated circut under the photoic integrated circut that handles 'setting up' the computation for the photoic circut
        using a photonic tensorcore enables masive energy savings, on the computation going through the photonic logic gates (a couple orders of magnitude?)
    AMD Secure Encrypted Virtualization
        https://en.wikipedia.org/wiki/Zen_(first_generation)#Enhanced_security_and_virtualization_support
        https://developer.amd.com/sev/
        AMD Secure Memory Encryption (SME)
            Encrypts memory pages stored in memory when they are transfered between L3 and Memory
            IE: when a memory page is moved outside the CPU, it's encrypted
        AMD Secure Encrypted Virtualization (SEV)
            Encrypts memory pages stored in memory (when they are transfered between L3 and Memory?) such that each Virtual Machine has a different encyption key
            IE: every VM has a different encryption key for it's memory pages
        AMD Secure Encrypted Virtualization-Encrypted State (SEV-ES)
            Encrypts the registers of the CPU when a virtual machine stops running (context switch) such that the hypervisor can't read unenctyped data from the CPU registers
            IE: during a VM context switch, the CPU state is encrypted BEFORE the hypervisor takes control of the CPU
    Different clock rates between Memory and CPU
        CPU and Memory (and other modules) need to be able to run at different clock rates
        Since this simulator doesn't simulate clock signals, an alternative is needed.
        Implement the 'tick' function of modules such that they can be set to sudo run at different clock rates
            IE: CPU runs at 2Hz, Memory runs at 1Hz; therefor CPU.tick() and Memory.tick() are called twice, but one of the Memory.tick() calls does nothing, to match and sync with the CPU
            IE: L3 cache runs at 1Hz, DRAM runs at 2Hz; therefor L3.tick() and DRAM.tick() are called twice, but one of the L3.tick() calls does nothing. Both L3 and DRAM are running within the MMMU module
        All modules will need to designed to be able to cope with different clock rates, such that the interactions between modules can be buffered. 
            Possibly with a specific 'buffer' building block sitting between the interfaces of two different modules (IE: L3 and DRAM)
        Will need to find a SUDO Random algorithm to generate the 'tick patterns' in a way that best works with the different clock rates
            IE: '--|--|--|' + '|-|-|-|-|' but not '--|--|--|' + '||||----|' (needs to prevent 'bunching up' of ticks)
            Also needs to be sudo random, such that a generator seed can be swapped out to isolate any potential undesired pattern in a battery of tests
                IE: this program happens to work better with 'seed x' than 'seed y' because with 'seed x' the CPU and Memory Controller happen to sync up in just the right way to get better performance

Terminology: #TODO
    #TODO

Reference:
    https://www.youtube.com/watch?v=B_jUXiOvMo8&t=3073s     # "Talking Milan-X with Wendell: Level1Potato" [@ 3073 s] - TechTechPotato [2022-03-21]
        Caching Latency impacts on performance
    https://www.youtube.com/watch?v=5lFnKYCZT5o             # "What's Virtual Memory? - Computerphile" - Computerphile [2022-06-10]
        Overview of virtual memory
        How the ipad uses virtual memory
            uses 16 kB pages
            On initial program load, loads first few pages into memory, maps the rest of the program to virtual memory except the virtual memory refereances the program file instead of the system swap file
    Capability Hardware Enhanced RISC Instructions: CHERI Instruction-Set Architecture
        https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-risc-v.html    #overview of project website
        https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-951.pdf     # technical document on it's implimentation over various architectures
        https://youtu.be/osOEsllH-cs?t=868                  # "Why I Like Talking Chips: A Hot Chips 34 Recap" [@ 868 s] - TechTechPotato [2022-09-13]

#TODO Stack:
    create instruction helper that allows adding an immediate register (IE: you put in a number, and it passes out an immediate register address, AND adds an immediate register)
    allow ISA instructions to be referenced by a list. IE: ("add", "#") and ("add", "$") for the 6502 processor, shows two different addressing modes for the "add" instruction?
    change 'charNum' to 'colNum' in parser, add/change 'charNum' as source code number (IE: the char number of input string, not column number of that line in input string)
    impliment character tokenizer in default parser
    impliment ISA helping function that allows selecting a 'bitrange' of a register. IE: take a 16-bit register, return the upper 8-bits (as a created immiedate register)
    change engine datastructure to store instructions for EVERY register, not just as a 'special' register array. Possibly make it it's own variable, like self.config
    change variable name 'state' and 'oldState' to 'stateCurrent' and 'stateNew'
    Change terminology of 'registers' to 'registers' and 'register banks' or 'register array'
    Change terminology of 'cycle' to 'tick' with expected value of 1*10^10
"""

#asserts python version 3.8 or greater, needed due to new feature used [variable typing]
import sys
version = sys.version_info
assert version[0] == 3 and version[1] >= 10

import copy # copy.deepcopy() required because states are a nested dictionary, and need to be copied instead of referenced
import functools # used for partial functions when executioning 'instruction operations'
import unittest
import random
from decimal import Decimal # used for handling floating point numbers in limited areas. IE: keeping track of energy usage of a single hyper efficiant instruction (10^-4)

#Some stuff for more complex annotation typing
from typing import Any, Callable, Generic, Literal, Optional, Type, TypeVar

from dataclasses import dataclass # used for namespace objects (dictionaries just wasn't going to cut it)
from abc import ABC, abstractmethod # used for abstract classes

#debugging and logging stuff
import logging
import inspect # used for logging, also used to assertion testing
debugHighlight : Callable[[int], bool] = lambda _ : False # debugHighlight = lambda x : 322 <= x <= 565 #will highlight the debug lines between those number, or set to -1 to highlight nothing
def debugHelper(frame : "Frame Object") -> str:
    """Takes in a frame object, returns a string representing debug location info (IE: the line number and container name of the debug call)

    Usage 
        -> logging.debug(debugHelper(inspect.currentframe()) + "String") #Can also use (.critical .fatal) .error (.warn .warning) .info .debug 
        -> DEBUG:root:<container>"remove"[0348]@line[0372] = String
    Used for easy debugging identification of a specific line
    No, you can't assign that code segment to a lambda function, because it will always return the location of the original lambda definition

    Reference:
        https://docs.python.org/3/library/inspect.html#types-and-members
    """

    assert inspect.isframe(frame)

    global debugHighlight # Callable[[int], bool]
    if 'debugHighlight' not in globals():
        debugHighlight = lambda _ : False
    
    #textRed : str = "\u001b[31m" # forground red
    textTeal : str = "\u001b[96m" # forground teal
    ANSIend : str = "\u001b[0m" # resets ANSI colours and formatting

    line : str = ""

    if debugHighlight(frame.f_lineno):
        line += textTeal
   
    line += "<container>\"" + str(frame.f_code.co_name) + "\"" # he name of the encapuslating method that the frame was generated in
    line += "[" + str(frame.f_code.co_firstlineno).rjust(4, '0') + "]" # the line number of the encapsulating method that the frame was generated in
    line += "@line[" + str(frame.f_lineno).rjust(4, '0') + "]" # the line number when the frame was generate
    line += " = "

    if debugHighlight(frame.f_lineno):
        line += ANSIend

    return line

class CPUsim:
    """A implimentation of a generic and abstract CPU mainly geared towards illistrating algorithms
    """

    '''Random Design Notes:

    Issues/#TODO:
        Instruction functions should give warnings when input/output bitLengths aren't compatible. IE: multiplying 2 8-bit numbers together should be stored in a 16-bit register
        configSetInstructionSet() should autofill stats datastructer for any unfilled in data. (but should also show a warning)
        ProgramCounter should be semi-indipendant from instruction functions (unless explicidly modified by instruction functions)(IE: not an automatic += 1 after every instruction executed)
            This would allow for representation of variable length instructions in 'memory'
            program counter should be already incrimented before instruction is executed, so instruction doesn't have to change the program counter unless needed (like a jump)
        create instruction helper that takes in a number and creates a 'imm' value
        Note: Use Big Endian, it's convention in most cases
            If an array pointer points to a specific byte in a four byte word, does it point to the big side or little side (Big Endian points to the big side)
        Load upper immediate needs to be a thing
            Some instructions can't store a large immediate value, and use 'load upper immediate' to load the upper bytes of a large immediate
            since immediate registers are generated on the fly, and 'load upper immediate' is called before a specific a instruction...
                There needs to be a way to specify that a just declared immediate should be bolted onto the next declared immediate
            How does this impact out of order execution?
            possible implimentation:
                could have imm registers always have the last index be a blank index, and some operation is done to it whenever the next immediate is added?
                A special temp immediate register that is only used for loading upper immediates
                Immediate registers could be generated in pairs, allowing different instructions to interact with multiple pairs of immediates
                    IE: 'load upper immediate' creates 'imm1[1]' and 'imm2[1]' puts a number in 'imm1[1]', 'add immediate' creates 'imm1[2]' and 'imm2[2]', puts a number in 'imm2[2]' and combines it with 'imm1[1]'
                    Immediate registers are reset between instructions, so this wouldn't be visible to the next instruction
                could create an 'upperImm' register as part of custom ISA, and a special 'combine with immediate' function in the custom ISA (like enforceImmediate()) (which also resets the 'upperImm' register)
                    Would get around the persistance problem
                    Would be kind of 'hacky' as it could require extra control flags, etc
        Data to keep track of:
            stats:
                number of times a line is executed
                energy use per line
                cycles used for execution
        ? Instruction functions on execution should return a dictionary of info on function stats (IE: energy used, latency, instruction unit used, etc?)
            Makes instruction set composition easier (since lambda functions don't also need to copy a bunch of function properties)
            Makes instruction manipulation harder (IE: you can't know how long an instruction will take to execute ahead of time, or which execution unit it will use, or how to profile it)
        Parser:
            split line rule needs to be able to recurse, and take different characters to split with
            needs a rule to label containers as function arguments, array indices, other?
            Parser currently assumes all source code to process is perfect with no errors/typos, and thus is super fragile
            Parser 'rules' need more functionality for each function, to make it more modular
        Instructions/Special considerations
            System Calls
                How to handle system calls?
            Load and Store instructions should be able to handle bit-addressing within a memory element
            Should I define a function that enforces only a specific memory access?
                Like enforceImm(imm), enforcing access only to the imm registers. But for different registers, like 'r', or 'm'
            https://youtu.be/QKdiZSfwg-g?t=5728
                The 'repeat' prefix instruction in x86
                'repeat' (1 byte) prefix, 'moveString' (1 byte) instruction, with registers EDI (extended implicid source) defined, ESI (extended implicid destination) defined, ECX (implicid count register)
                    Allows copying an arbitry length string from ESI memory pointer to EDI memory pointer of ECX string length
        configAddAlias() should be split into addParserAlias and addEngineAlias
            addParserAlias is just like it is now, the parser searches for and replaces a token with another token (or series of tokens)
            addEngineAlias would have to be run in the execution engine, dynamically changing register names as they are being executed
                would also have to add names for each register as part of self.config (IE: each register/memory element would get a dictionary of properties)
        ? should self.config store a config dictionary for EVERY key, index pair?
            Would use a tremendous amount of memory
            Would also make accessing data on a particular register/memory element more consistent
        Execution engine should not rely on Node labels to be labeled 'container' to recurse (it doesn't rely on it, but it also shouldn't be a case if it's handled by else?)
        MicroArchitecture something something NOT MicroCode?
            self.instructionSet : dict { 
                #a single instruction, the normal case, SISD. Note: The engine should treat this as a single instruction executing
                "add"   : (lambda z1, z2, z3, z4,   des, a, b       : self.opAdd(z1, z2, z3, z4,        des, a, b))
            }
            self.instructionSet : dict = { 
                #a vector, where each instruction actually represents multiple similar instructions. SIMD. Note: The engine should treat this as 4 instructions executing, with 4 seperate memory accesses
                
                "addVector": Vector(
                    (lambda z1, z2, z3, z4,   des, a, b       : self.opAdd(z1, z2, z3, z4,        des, (a[0], a[1] + 0), (b[0], b[1] + 0)   )),
                    (lambda z1, z2, z3, z4,   des, a, b       : self.opAdd(z1, z2, z3, z4,        des, (a[0], a[1] + 1), (b[0], b[1] + 1)   )),
                    (lambda z1, z2, z3, z4,   des, a, b       : self.opAdd(z1, z2, z3, z4,        des, (a[0], a[1] + 2), (b[0], b[1] + 2)   )),
                    (lambda z1, z2, z3, z4,   des, a, b       : self.opAdd(z1, z2, z3, z4,        des, (a[0], a[1] + 3), (b[0], b[1] + 3)   ))
                    
                )
            }
            self.instructionSet : dict = { 
                #Executing as a single instruction. SISD. The engine should treat this as 1 instruction executing, with one memory access.
                #Not entirly sure this is needed, or how usefull it is, as I can't think of a good example. Maybe multiply and accumulate?
                #The instructions are executed linearly as a list.
                "loadAndIncrement" : Single( #think accessing/loading stuff from an array, where one register 'r0' holds a pointer
                    (lambda z1, z2, z3, z4,   des             : self.opLoad(z1, z2, z3, z4,       des, ('r', 0)             )),
                    (lambda z1, z2, z3, z4,   des, a, b       : self.opAdd(z2, z2, z3, z4,        ('r', 0), ('r', 0), 1     )), #Notice "self.opAdd(z2, z2, z3, z4, " has the nextState 'z2' as both the lastState and nextState
                )
            }
            self.instructionSet: dict = {
                #implimenting NAND as a linear combination of AND and NOT instructions. Node: The engine should treat this as one instruction executing, with one memory access
                #Note: this is a further case where the instruction functions should not be altering the PC by themselves.
                "nand" : Single(
                    (lambda z1, z2, z3, z4,   des, a, b       : self.opAnd(z1, z2, z3, z4,        des, a, b     )),
                    (lambda z1, z2, z3, z4,   des             : self.opNot(z2, z2, z3, z4,        des, des      )) #Notice "self.opNot(z2, z2, z3, z4, " has the nextState 'z2' as both the lastState and nextState
                    #adding a NOP here just to reset the PC is dumb and confusing
                )
            }
            self.instructionSet : dict = {
                #microcode?
                #possible cases = 
                #   1: the microcode functions like a function call, and after a context switch operates on the same registers as a user space program
                #   2: the microcode functions as a translation layer that queues up a series of instructions operating on hidden registers not exposed to the user space program
                #might have to use complex numbers for the program counter to represent multi-vector instruction streams...? IE: one component keeps track of the user space PC, the other component keeps track of the microcode PC
                "multiply" : HardwareTranslationEngine("""
                            # Multiplies two numbers together
                            # Inputs: r[0], t[0]
                            # Output: t[1]
                    loop:   jumpEQ  (end, r[0], 0)
                            and     (r[1], r[0], 1)
                            jumpNE  (zero, r[1], 1)
                                add     (t[1], t[0], t[1])
                    zero:       shiftL  (t[0], t[0])
                            shiftR  (r[0], r[0])
                            jump    (loop)
                    end:    halt
                    """
                )
            }
            self.instructionSet : dict = {
                #'repeat' (1 byte) prefix, 'moveString' (1 byte) instruction, with registers EDI (extended implicid source) defined, ESI (extended implicid destination) defined, ECX (implicid count register)
                #   Allows copying an arbitry length string from ESI memory pointer to EDI memory pointer of ECX string length
                "repeatMoveString" : Single(
                    (lambda z1, z2, z3, z4,                : self.opMove(z1, z2, z3, z4,       ESI, EDI      )),
                    (lambda z1, z2, z3, z4,                : self.opSub(z2, z2, z3, z4,        ECX, ECX, 1   )),
                    (lambda z1, z2, z3, z4,                : self.opJump(z2, z2, z3, z4,       '==', PC + 1, ECX, 0  )), #assuming PC is not altered by other instructions, which hasn't been implimented
                    (lambda z1, z2, z3, z4,                : self.opJump(z2, z2, z3, z4,       '!=', PC - 1, ECX, 0  ))
                )
            }
            #is a double indirect load possible? IE: take a register 'r=255' as a pointer, load the memory address 'm255=64' of the pointer, use that as a pointer to load another memory address 'm64=Whatever'
            self.instructionSet : dict = {
                "multiplyAccumulate" :  lambda z1, z2, z3, z4, des, a, des      : 
                                        [ #the order of evaluation possibly isn't defined?
                                            self.opMul(z1, z1, z3, z4,          des, a, b),
                                            self.opAdd(z1, z2, z3, z4,          des, a, b)
                                        ]
                                        
            }
        Devices, SysCalls, Inturupts, and Input/Output:
            Should syscalls and devices be in their own interchangable modules? Yes
            Should syscalls and devices be together? Maybe?
            What are SysCalls?
                Part of the instruction set, referenced (but not defined) in class InstructionSetDefault.__init__(), IE: 'halt'
                Can redirect the instruction pointer to an OS function, where it executes instructions then returns
                Can be a system inturupt, which then redirects the instruction pointer to an OS function
                Can it be blocking (of CPUSim)? Yes
                    EX: input from keyboard
                Can it take in data from a predefined initialied array? No
                    EX: simulate keyboard input by reading from a file
                    Should be done via a device, where it can be better controled.
                It is a context switch to the OS
                    (Will need to read up on the priviliged RISCV instruction set)
            What is a Device?
                Some hardware thing that interfaces with the CPU but is not part of the CPU
                    IE: The Device is simulated AFTER the execution of an instruction (both inside the main execution loop)
                Can it be blocking (of CPUSim)? Yes
                    EX: input from keyboard
                Can it take in data from a predefined initialized array? Yes
                    EX: simulate keyboard input by reading from a file
                    The Device can be initialized at module Instantiation
                Can devices generate inturupts? Yes
                Should devices have full access to memory? Yes
                    A video display might use a memory range as a video buffer. And the 'user program' reads and writes to that memory range to manipualte video
                    EX: the way the Commador64/CommanderX16 handles video
            What is an Inturupt?
                Something that 'inturupts' the 'user program' to handle some event, then returns to the 'user program'
                Can the CPU send an 'inturupt' to a device? Maybe?
                    It would simplify activating and deactivating stuff like a keyboard input. Then the device would write back data via memory?
                Inturupts should be stored in the State['Engine'], for modular access by instructions
        
    references/notes:
        https://en.wikipedia.org/wiki/Very_long_instruction_word
            the instruction word contains multiple instruction for each individual execution unit, so less reliance on the CPU figuring out how to out of order execution
            can result in a lot of NOPs as not every execution unit needs to be doing something at every point in the code
            relies heavily on the compiler
            more hardware dependent
        https://en.wikipedia.org/wiki/Explicitly_parallel_instruction_computing
            VLIW refined
        https://en.wikipedia.org/wiki/IA-64
            Intel's attempt at EPIC architecture
        Google(intel microarchitecture)
            https://www.servethehome.com/intel-xeon-scalable-processor-family-microarchitecture-overview/
        https://cs.lmu.edu/~ray/notes/gasexamples/  #Some stuff on GCC, with a lot of assembly examples
        https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax
        https://en.wikipedia.org/wiki/GNU_Assembler
        https://github.com/vmmc2/Vulcan     #a "RISC-V Instruction Set Simulator Built For Education", web based
        https://www.youtube.com/watch?v=QKdiZSfwg-g     #Lecture 3. ISA Tradeoffs - Carnegie Mellon - Computer Architecture 2015 - Onur Mutlu
        https://www.anandtech.com/show/16195/a-broadwell-retrospective-review-in-2020-is-edram-still-worth-it #memroy latency of different cache levels
        https://www.youtube.com/watch?v=Q4aTB0k633Y&ab_channel=Level1Techs #Ryzen is Released - Rant/Rave with Tech Tech Potato (Dr. Ian Cutress
            four times the L3 cache (16MB to 64MB), eight extra clock cycle access time
            AMD 64-bit int division, 19-ish cycles (down from like 90-120 cyles years ago)
        https://www.youtube.com/watch?v=UvCri1tqIxQ #Making Your First Game: Minimum Viable Product - Scope Small, Start Right - Extra Credits
            What is Minimum Viable Product

    Out of scope (for this itteration): #it's sometimes helpful to know what not to do
        caching
        multi-threading
        instruction schedualer
            execution unit instruction queueing
        register file
        CPU interupts
            syscalls
        CPU power states/sleep
            device drivers/interactions
        CISC recursion to simulate a context switch
        parsing
            math operorators
            indentation
            allowing accessing individual bytes in a register, IE: copy the lower 8 bits of a 64-bit register without using a specific instruction to do it
        Reverse dirty bit for register file to impliment out of order super scaler execution
            IE: an instruction is run on dummy data at runtime to see what registers are accessed, and marked dirty.
            Allowing multiple instructions to be queued up without implimenting a complex dependency graph (a short cut)
        ? allow instructions to override instruction annotations during runtime execution
            IE: an instruction uses a variable amount of energy dependent on the data processed. It can report the energy used during its execution
        Support for self-modifying code
        Custom register/memory objects (instead of simple arrays) for tracking access (reads/writes) + transational history + additional stats and stat tracking
            memory controler/address translation
            will need a simple address pointer lookup function to simulate a redirect at the instruction composting stage
                IE: add(m[r[0]], r[1], r[4]) needs to be allowed
            can merge self.lastState and self.state into single state?
                No, will make it harder to understand instruction source code/cause confusion
            Case 1: Track register reads/writes
            Case 2: Keep track of data in a cache hierarchy
            Case 3: Allow multiple reads/writes per line/instruction word in the case of sloppy written source code, or Very Long Instruction Words which have multiple paralell instructions
            Case 4: Speculative execution will require keeping track of all reads/writes on a instruction word by instruction word basis, and allow for discarding some speculative results/operations
            Case 5: Since instructions are customizable, it is impossible to predict the dynamics of an instruction before executing it.
                Therefore implimenting superscaler stuff would require actually executing MANY following instructions and seeing which instructions conflict before deciding which instructions to schedual
                (yes, it's as backwords as it sounds, in possibly the most glorious and ironic way possible)
            Case 6: Out of Order execution would require keeping track of which instructions changed what, and when to commit the changes
        Microcode. The execution engine just isn't built out enough yet to consider this yet
            Microcode could run as a recursive CPU call, elimating the need for complex tracking of register windows, since it's run in a 'custom cpu construct' made for that instruction
            Microcode could be implimented at the instruction set composition level instead
                IE: add(a,b,c) used to make a vector add instruction (lambda a,b,c : add(a,b,c), add(a+1,b+1,c+1), add(a+2,b+2,c+2), etc)
                Only useful for simple instructions
        Instruction non-execution analysis utilities to better help calabrate instructions (IE: some utilities to help the user see energy use for each instruction in a graph before code is run)
        Support for virtual memory?
        should CPUsim have 'checkpoints' that can be reverted to?
    '''

    def __init__(self, bitLength : int = 16, defaultSetup : bool = True):
        assert type(bitLength) is int
        assert bitLength >= 1

        assert type(defaultSetup) is bool
        
        self.bitLength : int = bitLength #the length of the registers in bits

        '''core engine variables, used by a number of different functions, classes, etc. It's assumed that these variables always exist'''
        self.state      : dict[str, dict[str or int, int]] = {}
        self.lastState  : dict[str, dict[str or int, int]] = {}
        self.config     : dict[str, dict[str or int, dict]] = {}
        self.stats : dict = {} #FUTURE used to keep track of CPU counters, like instruction executed, energy used, etc
        self.engine : dict = {} #FUTURE used to keep track of CPU engine information?, should it be merged with self.stats?

        self.engine["run"] = False 

        #TODO find a better structure for this
        self.engine["labels"] : dict[str, int] = None
        self.engine["instructionArray"] : list["Nodes"] = None
        self.engine["sourceCode"] : str = None
        self.engine["sourceCodeLineNumber"] : int = None #TODO this should be an array of ints, to represent multiple instructions being executed
        self.engine["tick"] : int = 0

        '''a bunch of variables that are required for proper functioning, but are reqired to be configured by config functions
        defined here for a full listing of all these variables
        defined here in a failsafe state such that they can be used without crashing (or at least a lower likelyhood of crashing)
        may result in a more difficult time debugging
        '''
        #self.configSetDisplay
        self.userDisplay : __class__ = None
        self._displayRuntime : Callable[[], None] = lambda : None
        self._displayPostRun : Callable[[], None] = lambda : None
        #self.configSetInstructionSet
        self.userInstructionSet : __class__ = None
        self._instructionSet : dict[str, Callable[[dict, dict, dict, dict, "Args"], None]] = {}
        self._directives : dict = {}
        #self.configSetParser
        self.userPraser : __class__ = None
        self._parseCode : Callable[[str], "Node"] = lambda x : None
        self._updateNameSpace : "function" = lambda x, y : None #TODO change name to _parseUpdate()
        #self.configSetPostCycleFunction
        self.userPostCycle : Callable[[dict], tuple[dict, dict]] = lambda x : (x, x)
        #self.configAddAlias
        self._tokenAlias : dict = {}

        self._namespace : dict = {}

        #adds special registers that are required
        self.configConfigRegister('pc', 0, bitLength, note="SPECIAL") #program counter, it's a list for better consistancy with the other registers
        for i in range(1024): 
            self.configConfigRegister('imm', i, bitLength, note="SPECIAL") #holds immidiate values, IE: literal numbers stored in the instruction, EX: with "add 2,r0->r1", the '2' is stored in the instruction
        self.state['imm'] = {}  #clears all immediate indexes, will be dynamically generated when needed
        self.lastState['imm'] = {}
        
        #self.state['stack'] = [None for i in range(memoryAmount)] #stores stack data #FUTURE
        #the entire state information for registers, program pointers, etc, should be stored as one memory unit for simplicity

        self.configSetDisplay(self.DisplaySimpleAndClean())
        self.configSetInstructionSet(self.InstructionSetDefault())
        self.configSetParser(self.ParseDefault({}))

        self.configSetPostCycleFunction(self._postCycleUserDefault)

        #convinence added stuff for 'works out of the box' functionality
        if defaultSetup:
            self.configAddRegister('r', bitLength, 8) #standard registers
            self.configAddRegister('m', bitLength, 32) #standard memory
            self.configAddFlag('carry')

        #engine stuff?
        self.lastState, self.state = self.userPostCycle(self.state)
        self._postEngineTick()

    def _computeNamespace(self): #TODO this should serve a different function, updating namespaces throughout program WITHOUT using a centralized 'namespace' variable
        """computes the namespace of instructions, registers, etc for the CPU. Updates self._updateNameSpace : dict"""

        names = {}
        keys = self.state.keys()
        for i in keys:
            names[str(i)] = self.state[i]
        names.update(self._instructionSet)
        names.update(self._directives)
        names.update(self._tokenAlias)
        self._namespace = names
        self._updateNameSpace(names, self._tokenAlias)

    def configAddAlias(self, token : str, replacement : str):
        #TODO replace this with configConfigRegister()
        #TODO use a more robust method for dealing with aliases, instead of string replacement
        """Takes in a 'token' and a 'replacement' str
        
        When used, adds it to self._tokenAlias.
        Parsing source code will replace that token with it's replacement during parsing"""
        assert type(token) is str
        assert type(replacement) is str
        assert len(token) != 0
        assert len(replacement) != 0
        assert token != replacement

        self._tokenAlias[token] = replacement
        
        self._computeNamespace()

    def configSetDisplay(self, displayInstance):
        """Takes in an display class

        class must have:
            runtime(lastState, state, config, stats, engine) - runs after every execution cycle
            postrun(lastState, state, config, stats, engine) - runs after the CPU halts

        Note: runtime() must be able to handle the 'imm' register having a variying sized array, since it's size changes based on what the currect instruction needs
        """
        assert displayInstance.runtime
        assert displayInstance.postrun
        assert callable(displayInstance.runtime)
        assert callable(displayInstance.postrun)
        assert len((inspect.signature(displayInstance.runtime)).parameters) == 5
        assert len((inspect.signature(displayInstance.postrun)).parameters) == 5

        self.userDisplay : __class__ = displayInstance
        self._displayRuntime = lambda : displayInstance.runtime(self.lastState, self.state, self.config, self.stats, self.engine)
        self._displayPostRun = lambda : displayInstance.postrun(self.lastState, self.state, self.config, self.stats, self.engine)

    def configSetInstructionSet(self, instructionSetInstance):
        """Takes in a class representing the instruction set

        class must have:
            instructionSet : {str: function} - contains a dictionary of operation names with instruction functions
            directives : {str: function} - contains a dictionary of assembler directives with directive functions
        """
        assert type(instructionSetInstance.instructionSet) is dict
        assert type(instructionSetInstance.directives) is dict
        assert all([type(i) is str for i in instructionSetInstance.instructionSet]) #some keys in instructionSet are not strings
        assert all([len(i) > 0 for i in instructionSetInstance.instructionSet]) #some keys in instructionSet are null strings
        assert all([callable(instructionSetInstance.instructionSet[i]) for i in instructionSetInstance.instructionSet.keys()]) #some keys in instructionSet have non-function values
        assert all([len((inspect.signature(instructionSetInstance.instructionSet[i])).parameters) >= 4 for i in instructionSetInstance.instructionSet.keys()]) #some instructionSet functions take less than the minimum required functions

        self.userInstructionSet : __class__ = instructionSetInstance
        self._instructionSet : dict = instructionSetInstance.instructionSet
        self._directives : dict = instructionSetInstance.directives

        self._computeNamespace()

        logging.info(debugHelper(inspect.currentframe()) + "Imported Instruction Set\n" + \
            "".join(
                [("    " + str(i).ljust(12, " ") + str(inspect.signature(instructionSetInstance.instructionSet[i])) + "\n") for i in instructionSetInstance.instructionSet]
                )
            )

    def configSetParser(self, parserInstance):
        """Takes in a class representing a source code parser

        class must have:
            parseCode(sourceCode : str) - a function that takes in a string, and returns an execution tree
            updateNameSpace(nameSpace : dict) - a function which takes in a nameSpace dictionary representing the CPUs registers, flags, instructions, etc
        """
        assert parserInstance.parseCode
        assert callable(parserInstance.parseCode)
        assert len(inspect.signature(parserInstance.parseCode).parameters) >= 1
        assert parserInstance.updateNameSpace
        assert callable(parserInstance.updateNameSpace)
        #TODO assert update function takes right number of arguments

        self.userParser = parserInstance
        self._parseCode = parserInstance.parseCode
        self._updateNameSpace = parserInstance.updateNameSpace

        self._computeNamespace()

    def configSetPostCycleFunction(self, postCycle : Callable[[dict[str, dict[str or int, int]]], tuple[dict[str, dict[str or int, int]], dict[str, dict[str or int, int]]]]):
        """Takes in a function that is executed after every execution cycle.

        Function must take in a dictionary currentState representing the current state
        Function must output a tuple containing a lastState dictionary and a newState dictionary, in that order.
        See self._postCycleUserDefault() for the default implimentation

        That function is used for (aside from explicidly copies the old state to the new state, etc) to reset CPU Flags, reset registers that are supposed to be hardwired to zero, to zero, etc.
        """
        assert callable(postCycle)
        assert len(inspect.signature(postCycle).parameters) == 1

        self.userPostCycle = postCycle

    def configAddRegister(self, name : str, bitLength : int, amount : int, show : bool = True):
        """takes in the name of the register/memory symbol to add, the amount of that symbol to add (can be zero for an empty array), and bitLength. Adds and configures that memory to self.state
        
        calls self.configConfigRegister()"""
        assert type(name) is str
        assert len(name) >= 1
        #assert all([i in ([chr(j) for j in range(128) if chr(j).islower()] + [chr(j) for j in range(128) if chr(j).isdigit()] + ['_']) for i in list(name)]) #does the same as str.isidrentifier()
        assert name.isidentifier()

        assert type(bitLength) is int 
        assert bitLength > 0

        assert type(amount) is int 
        assert amount >= 0

        assert type(show) is bool

        for i in range(amount):
            self.configConfigRegister(name.lower(), i, bitLength, show)

        self._computeNamespace()

    def configAddFlag(self, name : str):
        """Takes in a name for a CPU flag to add, Adds it to self.state
        
        calls self.configConfigRegister()"""
        assert type(name) is str
        assert len(name) >= 1
        #assert all([i in ([chr(j) for j in range(128) if chr(j).islower()] + [chr(j) for j in range(128) if chr(j).isdigit()] + ['_']) for i in list(name)]) #does the same as str.isidrentifier()
        assert name.isidentifier()

        self.configConfigRegister('flag', name.lower(), bitLength=1)

        self._computeNamespace()

    def configConfigRegister(self, register : str, index : int or str, bitLength : int = None, show : bool = None, alias : list[str] = None, latencyCycles : int = None, energy : int = None, note : str = None, ):
        """Takes in a key/value pair representing a register/memory element, and takes in arguments for detailed configuration of that register/memory element

        if a key/value pair does not exist, it will be created
        """
        assert type(register) is str
        assert len(register) >= 1
        #assert all([i in ([chr(j) for j in range(128) if chr(j).islower()] + [chr(j) for j in range(128) if chr(j).isdigit()] + ['_']) for i in list(name)]) #does the same as str.isidrentifier()
        assert register.isidentifier()

        assert type(index) is int or type(index) is str
        assert (True if index >= 0 else False) if type(index) is int else True
        assert (True if len(index) >= 1 else False) if type(index) is str else True
        assert (True if index.isidentifier() else False) if type(index) is str else True

        assert type(bitLength) is type(None) or type(bitLength) is int
        assert (True if bitLength >= 1 else False) if type(bitLength) is int else True

        assert type(show) is type(None) or type(show) is bool

        assert type(note) is type(None) or type(note) is str
        assert (True if 0 <= len(note) <= 32 else False) if type(note) is str else True

        assert type(alias) is type(None) or type(alias) is list
        #assert (True if len(alias) >= 1 else False) if type(alias) is list else False #'alias' should allow for an empty list
        assert all([(type(i) is str) for i in alias]) if type(alias) is list else True #assert 'alias' list contains strings
        assert all([(True if alias.count(i) == 1 else False) for i in alias]) if type(alias) is list else True #assert there are no duplicates in 'alias'

        assert type(latencyCycles) is type(None) or type(latencyCycles) is int
        assert (True if latencyCycles >= 0 else False) if type(latencyCycles) is int else True

        assert type(energy) is type(None) or type(energy) is int
        assert (True if energy >= 0 else False) if type(energy) is int else True

        if not(register.lower() in self.state.keys()):
            self.state[register.lower()]        = {}
            self.lastState[register.lower()]    = {}
            self.config[register.lower()]       = {}

        if not(index in self.state[register.lower()].keys()):
            self.state[register.lower()][index]     = 0
            self.lastState[register.lower()][index] = 0
            self.config[register.lower()][index]    = {}

            self.config[register.lower()][index]['bitLength']       = 1
            self.config[register.lower()][index]['show']            = True
            self.config[register.lower()][index]['alias']           = []
            self.config[register.lower()][index]['latencyCycles']   = 0
            self.config[register.lower()][index]['energy']          = 0
            self.config[register.lower()][index]['note']            = ""

        if bitLength != None:
            self.config[register.lower()][index]['bitLength']       = bitLength
        if show != None:
            self.config[register.lower()][index]['show']            = show
        if alias != None:
            #TODO remove 'aliases' from master 'aliases' list... once I create said list
            self.config[register.lower()][index]['alias']           = []
            for i in alias:
                self.config[register.lower()][index]['alias'].append(i)
        if latencyCycles != None:
            self.config[register.lower()][index]['latencyCycles']   = latencyCycles
        if energy != None:
            self.config[register.lower()][index]['energy']          = energy
        if note != None:
            self.config[register.lower()][index]['note']            = note

        self._computeNamespace()

    def inject(self, key : str, index : int or str, value : int):
        """Takes in a key index pair representing a specific register. Assigns int value to register.
        
        value >= 0
        Does not increment the simulatition"""
        assert type(key) is str
        assert len(key) >= 1
        assert key.isidentifier()
        assert key in self.state.keys()

        assert type(index) is int or type(index) is str
        assert (True if index >= 0 else False) if type(index) is int else True
        assert (True if len(index) >= 1 else False) if type(index) is str else True
        assert (True if index.isidentifier() else False) if type(index) is str else True
        assert index in self.state[key.lower()].keys()

        assert type(value) is int
        assert value >= 0

        t1 = key.lower()
        t2 = index.lower() if type(index) is str else index

        self.state[t1][t2] = value & (2**self.config[t1][t2]['bitLength']-1)

        self._displayRuntime()

        self._postEngineTick()

    def extract(self, key : str, index : int or str) -> int:
        """Takes in a key index pair representing a specific register. Returns an int representing the value stored in that register"""
        assert type(key) is str
        assert len(key) >= 1
        assert key.isidentifier()
        assert key in self.state.keys()

        assert type(index) is int or type(index) is str
        assert (True if index >= 0 else False) if type(index) is int else True
        assert (True if len(index) >= 1 else False) if type(index) is str else True
        assert (True if index.isidentifier() else False) if type(index) is str else True
        assert index in self.state[key.lower()].keys()

        t1 = key.lower()
        t2 = index.lower() if type(index) is str else index

        self._postEngineTick()

        return self.state[t1][t2]

    def _postCycleUserDefault(self, currentState : dict[str, dict[str or int, int]]) -> tuple[dict[str, dict[str or int, int]], dict[str, dict[str or int, int]]]:
        """Takes in a dictionary currentState, returns a tuple containing two dictionaries representing the oldState and the newState, respectivly.

        resets all required registers and flags between instructions, copies current state into lastState"""
        assert type(currentState) is dict

        oldState = copy.deepcopy(currentState) #required deepCopy because state['flags'] contains a dictionary which needs to be copied
        newState = copy.deepcopy(currentState)
        
        if 'flag' in newState.keys():
            for i in newState['flag'].keys(): #resets all flags
                newState['flag'][i] = 0
        newState['imm'] = {} 

        return (oldState, newState)

    def linkAndLoad(self, code: str):
        """Takes in a string of assembly instructions, and "compiles"/loads it into memory, 'm' registers
        
        configures:
            program counter to label __main, 0 if __main not present
            self.engine["instructionArray"] to contain instruction Nodes
            self.state["m"] to contain the memory of the program (but not instruction binary encodings, instructions are written as zeros)
            self.engine["labels"] to contain a dictionary of associations of labels with memory pointers

        #TODO '__main__' label should be changeable
        """
        assert type(code) is str
        assert len(code) > 0

        logging.info(debugHelper(inspect.currentframe()) + "Loading source code = " + "\n" + str(code))

        self.engine["sourceCode"] : str = code
        parseTree, parseLabels = self._parseCode(code)

        logging.debug(debugHelper(inspect.currentframe()) + "parseLabels = " + str(parseLabels))
        logging.info(debugHelper(inspect.currentframe()) + "linkAndLoad parseTree = " + "\n" + str(parseTree))

        assemmbledObject = self.compileDefault(self._instructionSet, self._directives)
        instructionArray : list["Node" or None] = [] #instructionArray is list of instruction nodes
        memoryArray : list[int] = [] #memoryArray is an integer array of memory elements/registers
        compileLabels : dict[str, int] = {} #compileLabels is labels, a dictionary accossiating 'labels' to a specific memory addresses
        instructionArray, memoryArray, compileLabels = assemmbledObject.compile(self.config, parseTree, parseLabels)
        
        #some checks on the returned values from compile function
        if len(memoryArray) > len(self.state["m"]):
            raise Exception("Program is too large to fit into memory array")
        assert type(instructionArray) is list
        assert type(memoryArray) is list
        assert type(compileLabels) is dict
        assert len(instructionArray) == len(memoryArray)
        assert all([(callable(i) or i == None) for i in instructionArray])
        assert all([len(i.child) != 0 for i in instructionArray]) #asserts there are no empty lines
        assert all([type(i) is int for i in memoryArray])
        assert all([(type(key) is str and type(value) is int) for key, value in compileLabels.items()])

        self.engine["instructionArray"] = instructionArray

        #TODO program is imported into memory 'm', this should be changeable
        for i in range(len(memoryArray)): #loads program memory into memory one element at a time
            self.state["m"][i] = memoryArray[i]
        
        self.engine["labels"] = compileLabels
        logging.debug(debugHelper(inspect.currentframe()) + "compilerLabels = " + str(compileLabels))

        #sets the program counter to the label __main, if the label __main exists
        #TODO allow a settable 'main' label. IE: allow different labels to be used as the program start instead of '__main'
        if "__main" in self.engine["labels"]:
            self.state["pc"][0] = self.engine["labels"]["__main"]

        logging.info(debugHelper(inspect.currentframe()) + "Program Counter set to " + hex(self.state["pc"][0]))

    def lazy(self, code : str):
        """NotImplimented
        decodes and executes a single instruction line"""
        pass

    def run(self, cycleLimit = 1024):
        """Prototype
        starts execution of instructions
        
        #TODO check for empty instruction lines
        #TODO perform checks on everything"""

        '''
            do a depth first search on the execution tree
            apply 'rule functions' based on what the token is
            recursivly evaluate
        '''
        self._displayRuntime()
        self.lastState, self.state = self.userPostCycle(self.state)
        self._postEngineTick()

        self.engine["run"] = True
        self.engine["tick"] = 0

        i = 0
        while i < cycleLimit:
            i += 1
            if self.engine["run"] == False:
                break

            #logging.info(debugHelper(inspect.currentframe()) + str(i))
            line = self.engine["instructionArray"][self.state["pc"][0]]
            #logging.info(debugHelper(inspect.currentframe()) + "\n" + str(line))
            if line is None: #TODO this should raise an exception, since it's trying to execute a non-instruction
                break

            self.engine["sourceCodeLineNumber"] = line.lineNum

            self._evaluateNested(line)

            if self.lastState['pc'][0] == self.state['pc'][0] and self.engine["run"] == True:
                logging.warning(debugHelper(inspect.currentframe()) + "Program Counter has not incremented\n" + str(line))

            self._displayRuntime()
            self.lastState, self.state = self.userPostCycle(self.state)
            self._postEngineTick()

        self._displayPostRun()
            
    class _registerObject: #TODO this is a short cut
        def __init__(self, key, index):
            self.key : str = key
            self.index : str or int = index

    def _evaluateNested(self, tree : "Node") -> tuple["Object"]:
        #logging.info(debugHelper(inspect.currentframe()) + "Recurse\n" + str(tree))

        if tree.token in self._instructionSet.keys():
            '''case 1
            tree is an intruction
                recursivly call _evaluateNested on children if there is any -> arguments
                process arguments
                run instruction on arguments
            '''

            #logging.info(debugHelper(inspect.currentframe()) + "case 1 instruction")

            #evaluates children to get arguments
            arguments = []
            if len(tree.child) != 0:
                for i in tree.child:
                    temp = self._evaluateNested(i)
                    
                    if type(temp) is tuple: #incase child is container, unpacks container
                        for j in temp:
                            arguments.append(j)
                    else:
                        arguments.append(temp)
            #logging.info(debugHelper(inspect.currentframe()) + "instruction raw input: " + str(arguments))

            #unpacks register objects
            newArguments = []
            for i in arguments:
                if type(i) is self._registerObject:
                    newArguments.append((i.key, i.index))
                else:
                    newArguments.append(i)
            arguments = newArguments
            #logging.info(debugHelper(inspect.currentframe()) + "instruction arguments: " + str(arguments))

            #adds immediate values to self.state
            newArguments = []
            for i in range(len(arguments)):
                if type(arguments[i]) is int: #TODO this case 'should' no longer be possible, but is somehow still active
                    #self.lastState["imm"].append(arguments[i])
                    self.lastState["imm"][len(self.lastState["imm"])] = arguments[i] #the created 'index' of the key/index pair will always be an int == length, int + 1 == previous index

                    newArguments.append(("imm", len(self.lastState["imm"]) - 1))
                    
                elif type(arguments[i]) is self._registerObject:
                    newArguments.append((arguments[i].key, arguments[i].index))
                else:
                    newArguments.append(arguments[i])

            #logging.info(debugHelper(inspect.currentframe()) + "instruction immidiate processing: " + str(newArguments))

            instruction : Callable[[dict, dict, dict, dict, Any], None] = self._instructionSet[tree.token]
            instruction = functools.partial(instruction, copy.deepcopy(self.lastState), self.state, copy.deepcopy(self.config), self.engine)

            for i in newArguments:
                instruction = functools.partial(instruction, i)

            #logging.info(debugHelper(inspect.currentframe()) + "instruction function?: " + str(instruction))
            
            instruction()

        elif len(tree.child) == 0:
            '''Case 2
            tree is a simple base type (int, str, etc) or a label
                if tree is a label, convert into a register object
                return object
            '''
            #logging.info(debugHelper(inspect.currentframe()) + "case 2 empty")
            result = None
            if tree.token in self.engine["labels"]:
                #self.lastState["imm"].append(self.engine["labels"][tree.token])
                self.lastState["imm"][len(self.lastState["imm"])] = self.engine["labels"][tree.token] #the created 'index' of the key/index pair will always be an int == length, int + 1 == previous index
                
                result = self._registerObject("imm", len(self.lastState["imm"]) - 1)
            else:
                result = tree.token                
            return result

        elif tree.type == "container": #TODO this should not rely on the parser properly labeling Nodes
            '''Case 3
            tree is a container _evaluateNested on children
                if there is only one child, 'pass through' results
                else, return a tuple of results
            '''

            #logging.info(debugHelper(inspect.currentframe()) + "case 3 container")
            stack = []
            for i in tree.child:
                stack.append(self._evaluateNested(i))

            if len(stack) == 1:
                return stack[0]
            else:
                return tuple(stack)
            
            #return tuple(stack)

        elif tree.token in self.state.keys():
            '''Case 4
            tree is a register
                assumes a single child
                assumes child is index
            returns register object
            '''

            #logging.info(debugHelper(inspect.currentframe()) + "case 4 register")
            return self._registerObject(tree.token, self._evaluateNested(tree.child[0]))

        else:
            '''Case X
            similar to the container case, mainly just 'passes through' the result of a recursive call on children
            '''

            #logging.info(debugHelper(inspect.currentframe()) + "case x else")
            #logging.info(debugHelper(inspect.currentframe()) + "tree = \n" + str(tree))
            stack = []
            for i in tree.child:
                stack.append(self._evaluateNested(i))
            
            if len(stack) == 1:
                return stack[0]
            else:
                return tuple(stack)

    def _postEngineTick(self):
        """Prototype
        runs at the end of each execution cycle, meant to handle engine level stuff. Should also run checks to verify the integrity of self.state"""
        self.engine["tick"] += 1
        
        '''#TODO
        assert state and last state have the same keys (except for immediate values/registers)
        assert state and last state registers have int values
            assert those values are positive
        assert all state variables are the correct type (dict)
        '''

        #for i in self.state.keys():
        #    assert all([type(j) is int for j in self.state[i]])
        
    class compileDefault:
        """a working prototype, provides functions that take in an execution tree, and return a programs instruction list, memory array, etc"""

        def __init__(self, instructionSet, directives):
            self.instructionSet = instructionSet
            self.directives = directives

        '''
        def compileOld(self, oldState, config, executionTree : "Node") -> tuple[list["Node"], list[int], dict[str, int]]:
            #assumes the instruction array is register array "m"
            
            instructionArray : list["Node"] = [None for i in range(len(oldState["m"]))]
            memoryArray : list[int] = [0 for i in range(len(oldState["m"]))]
            labels : dict = {}

            #scans for labels, removes labels from execution tree
            #TODO this should be in the parser
            for i in range(len(executionTree.child)):
                instructionArray[i] = executionTree.child[i].copyDeep()
                if len(instructionArray[i].child) != 0:
                    if instructionArray[i].child[0].type == "label":
                        labels[instructionArray[i].child[0].token] = i
                        instructionArray[i].remove(instructionArray[i].child[0])

            #TODO scan for directives, process directives.

            return instructionArray, memoryArray, labels
        '''

        def compile(self, config : dict, executionTree : "Node", parseLabels : dict[str, "Node"]) -> tuple[list["Node"], list[int], dict[str, int]]:
            """Takes in in a dict containing the config information of registers, A node representing an execution tree, and parseLabels a dict (where key is the label, and value is a line number).
            Returns a list of Tree Nodes (representing each instruction), A list of ints (representing the program memory/binary), and a dictionary of labels (where each value corisponds to a memory index)

            config should contain only the config information of the registers the program is being loaded into
            executionTree should be a properly formated execution Node Tree, duh
            parseLabels should be of the form {Label : Node}, multiple Labels for the same line number is allowed
            """
            assert type(config) is dict
            #can't assert execution tree is type node because that's only available in the parser?
            assert type(parseLabels) is dict

            logging.debug(debugHelper(inspect.currentframe()) + "compile input ExecutionTree = \n" + str(executionTree))

            instructionArray : list["Node"] = []
            memoryArray : list[int] = []
            labels : dict[str, int] = {} #Note: needs to handle multiple keys refering to the same value

            for i in range(len(executionTree.child)): #goes through program line by line
                tempInstruction = executionTree.child[i].copyDeep()

                tempArrayInstruction = [tempInstruction]
                tempArrayMemory = [0]

                #TODO check for directives should happen here

                #check for labels and associate with memory index (IE: the current len(instructionArray))
                for i in parseLabels.keys():
                    if parseLabels[i].lineNum == tempInstruction.lineNum:
                        labels[i] = len(instructionArray)

                #appends instruction word to memory
                assert len(tempArrayInstruction) == len(tempArrayMemory)
                for i in range(len(tempArrayInstruction)):
                    memoryArray.append(tempArrayMemory[i])
                    instructionArray.append(tempArrayInstruction[i])
                #TODO empty instructionArray indices should be filled with a function that raises an error if run? or a special value denoting an error if it is tried to be executed?

            return instructionArray, memoryArray, labels

    class DisplaySimpleAndClean:
        """A simple display example of the interface expected for displaying information on the screen during and post runtime
        
        Displays all registers, memory, and flags after every execution cycle. Displays some postrun stats.
        Uses ANSI for some colouring
        """

        def __init__(self, animationDelay : float = 0.5):
            assert type(animationDelay) is float or type(animationDelay) is int
            assert animationDelay >= 0

            import time #this is imported for this specific class because this class is supposed to able to be 'swapped out' and may not be neccassary if another display class doesn't need the 'time' module
            self.sleep : "function" = time.sleep
            import timeit
            self.timer : "function" = lambda : timeit.default_timer()
            self.lastTime : int = 0

            self.animationDelay : int = animationDelay

            self.textRed : str = "\u001b[31m" #forground red
            self.textTeal : str = "\u001b[96m" #forground teal, meant for register activity
            self.textGreen : str = "\u001b[92m" #forground green
            self.textGrey : str = "\u001b[90m" #forground grey
            self.backDeepBlue : str = "\u001b[48;5;17m" #background deep blue
            self.ANSIend : str = "\u001b[0m" #resets ANSI colours

        def runtime(self, oldState : dict, newState : dict, config : dict, stats : dict = None, engine : dict = None):
            """Executed after every instruction/cycle. Accesses/takes in all information about the engine, takes control of the terminal to print information."""

            lineEngine : str = ""
            lineEngine += "[TICK " + str(engine["tick"]).rjust(10, "0") + "]"
            lineEngine += "\n"

            #calculate column widths
            registers : list[tuple[str, str or int]] = []
            maxWidths : dict[str, int] = {
                                            "key":3, #3 since 'imm' doesn't show up in every cycle
                                            "index":0, 
                                            "bitLength":0, 
                                            "alias":0, 
                                            "note":0}

            for key in sorted(list(oldState.keys())):
                for index in sorted(list(oldState[key].keys())):
                    if config[key][index]["show"]:
                        registers.append((key, index))

                        if len(str(key)) > maxWidths["key"]:
                            maxWidths["key"] = len(str(key))

                        if len(str(index)) > maxWidths["index"]:
                            maxWidths["index"] = len(str(index))

                        if config[key][index]["bitLength"] > maxWidths["bitLength"]:
                            maxWidths["bitLength"] = config[key][index]["bitLength"]

                        if len(config[key][index]["alias"]) + sum([len(str(i)) for i in config[key][index]["alias"]]) > maxWidths["alias"]:
                            maxWidths["alias"] = len(config[key][index]["alias"]) + sum([len(str(i)) for i in config[key][index]["alias"]])

                        if len(config[key][index]["note"]) > maxWidths["note"]:
                            maxWidths["note"] = len(config[key][index]["note"])
            
            #add padding for seperator
            for key in maxWidths.keys():
                maxWidths[key] += 1
            maxWidths["index"] += 2 #accounts for "[]"
            maxWidths["bitLength"] += 4 #accounts for "[0b]"

            #ceil to nearest column using integer math
            for key in maxWidths.keys():
                maxWidths[key] += (4 - (maxWidths[key] % 4)) % 4 #the outer '%4' prevents adding an additional 4, adding a 0 instead

            #source code program counter
            lineSource : str = ""
            indent : int = 4
            for key, index in [(key, index) for key, index in registers if key in ["pc"]]:
                lineSource += "".ljust(indent)

                lineSource += self.backDeepBlue

                lineSource += str(key).ljust(maxWidths["key"])

                lineSource += ("[" + str(index) + "]").ljust(maxWidths["index"])

                if len(config[key][index]["alias"]) != 0:
                    lineSource += self.textGrey + ("[" + ",".join(config[key][index]["alias"]) + "]").ljust(maxWidths["alias"]) + self.ANSIend
                else:
                    lineSource += "".ljust(maxWidths["alias"])

                lineSource += ("[" + self.textGrey + "0x" + self.ANSIend + self.backDeepBlue + str(hex(oldState[key][index]))[2:].rjust(config[key][index]["bitLength"] // 4, "0") + "]")\
                                .ljust(maxWidths["bitLength"] + len(self.textGrey) + len(self.ANSIend) + len(self.backDeepBlue))

                operation = engine["instructionArray"][oldState[key][index]]
                if type(operation) is not type(None):
                    sourceInstruction = engine["sourceCode"].split("\n")
                    lineSource += ("[Line " + str(operation.lineNum).rjust(4, "0") + "]").ljust(maxWidths["bitLength"])
                    lineSource += str(sourceInstruction[operation.lineNum]).strip()
                else:
                    lineSource += "Instruction Not Found"

                lineSource += self.ANSIend + "\n"

            #format special registers 'pc'
            lineSpecialPC : str = ""
            indent : int = 4
            for key, index in [(key, index) for key, index in registers if key in ["pc"]]:
                lineSpecialPC += "".ljust(indent)

                lineSpecialPC += str(key).ljust(maxWidths["key"])

                lineSpecialPC += ("[" + str(index) + "]").ljust(maxWidths["index"])

                if len(config[key][index]["alias"]) != 0:
                    lineSpecialPC += self.textGrey + ("[" + ",".join(config[key][index]["alias"]) + "]").ljust(maxWidths["alias"]) + self.ANSIend
                else:
                    lineSpecialPC += "".ljust(maxWidths["alias"])

                highlight = ""
                lineSpecialPC += ("[" + self.textGrey + "0b" + self.ANSIend + highlight + str(bin(oldState[key][index]))[2:].rjust(config[key][index]["bitLength"], "0") + self.ANSIend + "]")\
                                    .ljust(maxWidths["bitLength"] + len(self.textGrey) + len(highlight) + 2*len(self.ANSIend))

                highlight = self.textTeal if (oldState[key][index] != newState[key][index]) else "" #TODO should check if memory read/written instead of just looking for a difference
                lineSpecialPC += ("[" + self.textGrey + "0b" + self.ANSIend + highlight + str(bin(newState[key][index]))[2:].rjust(config[key][index]["bitLength"], "0") + self.ANSIend + "]")\
                                    .ljust(maxWidths["bitLength"] + len(self.textGrey) + len(highlight) + 2*len(self.ANSIend))

                lineSpecialPC += self.textGrey + (config[key][index]["note"]).ljust(maxWidths["note"]) + self.ANSIend

                lineSpecialPC += "\n"

            #format special registers 'imm'
            lineSpecialIMM : str = ""
            indent : int = 4
            for key, index in [(key, index) for key, index in registers if key in ["imm"]]:
                lineSpecialIMM += "".ljust(indent)

                lineSpecialIMM += str(key).ljust(maxWidths["key"])

                lineSpecialIMM += ("[" + str(index) + "]").ljust(maxWidths["index"])

                if len(config[key][index]["alias"]) != 0:
                    lineSpecialIMM += self.textGrey + ("[" + ",".join(config[key][index]["alias"]) + "]").ljust(maxWidths["alias"]) + self.ANSIend
                else:
                    lineSpecialIMM += "".ljust(maxWidths["alias"])

                highlight = self.textTeal
                lineSpecialIMM += ("[" + self.textGrey + "0b" + self.ANSIend + highlight + str(bin(oldState[key][index]))[2:].rjust(config[key][index]["bitLength"], "0") + self.ANSIend + "]")\
                                    .ljust(maxWidths["bitLength"] + len(self.textGrey) + len(highlight) + 2*len(self.ANSIend))
                lineSpecialIMM += "".ljust(maxWidths["bitLength"])

                lineSpecialIMM += self.textGrey + (config[key][index]["note"]).ljust(maxWidths["note"]) + self.ANSIend

                lineSpecialIMM += "\n"
            #TODO pad 'imm' lines with trailing empty lines, since number of 'imm' registers varies

            #format non-special registers
            lineRegisters : str = ""
            indent : int = 4
            for key, index in [(key, index) for key, index in registers if key not in ["pc", "imm"]]:
                lineRegisters += "".ljust(indent)

                lineRegisters += str(key).ljust(maxWidths["key"])

                lineRegisters += ("[" + str(index) + "]").ljust(maxWidths["index"])

                if len(config[key][index]["alias"]) != 0:
                    lineRegisters += self.textGrey + ("[" + ",".join(config[key][index]["alias"]) + "]").ljust(maxWidths["alias"]) + self.ANSIend
                else:
                    lineRegisters += "".ljust(maxWidths["alias"])

                highlight = ""
                lineRegisters += ("[" + self.textGrey + "0b" + self.ANSIend + highlight + str(bin(oldState[key][index]))[2:].rjust(config[key][index]["bitLength"], "0") + self.ANSIend + "]")\
                                    .ljust(maxWidths["bitLength"] + len(self.textGrey) + len(highlight) + 2*len(self.ANSIend))

                highlight = self.textTeal if (oldState[key][index] != newState[key][index]) else "" #TODO should check if memory read/written instead of just looking for a difference
                lineRegisters += ("[" + self.textGrey + "0b" + self.ANSIend + highlight + str(bin(newState[key][index]))[2:].rjust(config[key][index]["bitLength"], "0") + self.ANSIend + "]")\
                                    .ljust(maxWidths["bitLength"] + len(self.textGrey) + len(highlight) + 2*len(self.ANSIend))

                lineRegisters += self.textGrey + (config[key][index]["note"]).ljust(maxWidths["note"]) + self.ANSIend

                lineRegisters += "\n"

            screen : str = ""
            screen += lineEngine
            screen += lineSource
            screen += lineSpecialPC
            screen += lineSpecialIMM
            screen += lineRegisters

            print(screen)

            #the animation delay
            delay : float = (self.animationDelay - self.timer() + self.lastTime) if 0 < (self.animationDelay - self.timer() + self.lastTime) < self.animationDelay else 0
            self.sleep(delay)
            self.lastTime = self.timer()

        def postrun(self, oldState : dict, newState : dict, config : dict, stats : dict = None, engine : dict = None):
            """When CPU execution HALTS, displays information about execution stats, etc"""
            #TODO

            print("CPU Halted")

    class DisplaySilent:
        """An intentionally empty definition, that will display nothing to the screen"""

        def __init__(self):
            pass

        def runtime(self, oldState : dict, newState : dict, config : dict, stats : dict = None, engine : dict = None):
            """An intentionally empty definition, that will display nothing to the screen"""
            pass

        def postrun(self, oldState : dict, newState : dict, config : dict, stats : dict = None, engine : dict = None):
            """An intentionally empty definition, that will display nothing to the screen"""
            pass

    class DisplayInstruction:
        #TODO

        def __init__(self):
            import shutil #used to get the terminal window size

            #will return (80, 24) as a default if the terminal size is undefined
            self.getTerminalSize : function = lambda : (shutil.get_terminal_size()[0], shutil.get_terminal_size()[1])
            pass

        def runtime(self, oldState : dict, newState : dict, config : dict, stats : dict = None, engine : dict = None):
            pass

        def postrun(self, oldState : dict, newState : dict, config : dict, stats : dict = None, engine : dict = None):
            pass

    class ParseDefault:
        """Parses strings into an (almost) execution tree.
        ParseDefault.Node is the dataclass for storing tokens in a Node Tree.

        ParseDefault.parseCode("source code") is called which returns a Node Tree representing the "source code"

            ParseDefault.parseCode() calls ParseDefault._tokenize() to do the initial tokenization of the "source code"
            root -> Node
                    |- Token "test"
                    |- Token " "
                    |- Token "123"
                    |- ...

            "rule functions" are called to apply various rules to the Node Tree
            all "rule functions" are functional, and return a COPY of Nodes
            Note: most do not recurse
            by combining "rule functions" in different ways in ParseDefault.parseCode(), different syntaxes can be proccessed
            root = self.ruleRemoveToken(root, " ")
            root -> Node
                    |- Token "test"
                    |- Token "123"
                    |- ...
            root = ruleCastInts(root)
            root -> Node
                    |- Token "test"
                    |- Token 123
                    |- ...

            return root
        """

        def __init__(self, nameSpace : dict = {}):
            assert type(nameSpace) is dict

            self.nameSpace : dict = nameSpace
            self.alias : dict = {}
            self.labels : dict = None

        def updateNameSpace(self, nameSpace : dict, alias : dict):
            """Takes in nameSpace a dictionary whose keys represent the CPU flags, registers, instructions, etc"""
            assert type(nameSpace) is dict
            assert type(alias) is dict

            self.nameSpace = nameSpace
            self.alias = alias

        def update(
            self, 
            instructionSet : dict[str, Callable[[dict, dict, dict, dict, "Args"], None]], 
            directives : dict,
            tokenAlias : dict[str, str]
            ):
            pass

        class Node:
            """A data class for storing information in a tree like structure. 

            Each Node also has a coupld relational links between children (nodeNext, nodePrevious, nodeParent)
            Note: __eq__() and __ne__() are implimented to make it easier for compairsions with Node.token and other values.
            """

            def __init__(self, typeStr : str = None, token : "str/int" = None, lineNum : int = None, charNum : int = None):
                assert type(typeStr) is str or typeStr == None
                #check for type(token) not done for better flexibility
                assert type(lineNum) is int or lineNum == None
                if type(lineNum) is int:
                    assert lineNum >= 0
                assert type(charNum) is int or charNum == None
                if type(charNum) is int:
                    assert charNum >= 0

                self.type : str = typeStr
                self.token : str = token
                self.child : list = []

                #relational references to other nodes
                self.parent : self.__class__ = None
                self.nodePrevious : self.__class__ = None
                self.nodeNext : self.__class__ = None

                #the line number of the string or character position in a line, will be needed for indentation awareness if it's ever needed
                self.lineNum : int = lineNum 
                self.charNum : int = charNum

            def append(self, node : "Node"):
                """Adds a new node object to self as a child (at end of list)"""
                assert type(node) is self.__class__

                if len(self.child) != 0:
                    self.child[-1].nodeNext = node
                    node.nodePrevious = self.child[-1]
                if node.parent == None:
                    node.parent = self
                self.child.append(node)
            
            def copyInfo(self) -> "Node":
                """Creates a new node with the properties (but not relational data) of this node. returns the created node. 
                
                IE: returns a copy of the node with type, token, lineNum, charNum. Does not copy links to children, parent, nodeNext, nodePrevious, etc"""

                return self.__class__(self.type, self.token, self.lineNum, self.charNum) #TODO This feels wrong, but I don't know why it's wrong

            def copyDeep(self) -> "Node": #name is copyDeep instead of deepCopy to avoid accedentally calling copy.copyDeep()
                """Creates a new node with all properties of current node including recursivly copying all children (but not relational data). Returns a node tree.
                
                Has the side effect of 'resetting' all relational links (parent, nodeNext, nodePrevious)"""
                
                newNode = self.__class__(self.type, self.token, self.lineNum, self.charNum)

                logging.debug(debugHelper(inspect.currentframe()) + "attempting to copyDeep node"+ "\n" + str((
                        self.type,
                        self.token,
                        self.lineNum,
                        self.charNum,
                        self.child))
                    )

                for i in range(len(self.child)):
                    newNode.append(self.child[i].copyDeep())
                return newNode

            def replace(self, oldNode : "Node", newNode : "Node"):
                """Takes in an oldNode that is child of self, and replaces it with newNode. Deletes oldNode"""
                assert type(oldNode) is self.__class__
                assert type(newNode) is self.__class__

                index = None
                for i in range(len(self.child)):
                    if self.child[i] is oldNode:
                        index = i
                
                if index == None:
                    raise Exception("oldNode not found, can not replace oldNode. oldNode = \n" + str(oldNode))

                removeNode = self.child[index]
                
                #'rewires' the references of the children nodes
                newNode.parent = self
                if len(self.child) == 1: #case where oldNode is the only child in the list
                    logging.debug(debugHelper(inspect.currentframe()) + "only child detected")
                    pass
                elif index == 0: #case where oldNode is first child in the list, but not the only child in the list
                    logging.debug(debugHelper(inspect.currentframe()) + "first child detected")

                    newNode.nodeNext = self.child[1]
                    self.child[1].nodePrevious = newNode
                elif index == len(self.child) - 1: #case where oldNode is the last child in the list, but not the only child in the list
                    logging.debug(debugHelper(inspect.currentframe()) + "last child detected")

                    newNode.nodePrevious = self.child[-1]
                    self.child[-1].nodeNext = newNode
                elif 0 < index < len(self.child) -1: #case where oldNode is between two other nodes
                    logging.debug(debugHelper(inspect.currentframe()) + "middle child detected")

                    newNode.nodePrevious = self.child[index - 1]
                    newNode.nodeNext = self.child[index + 1]

                    self.child[index - 1] = newNode
                    self.child[index + 1] = newNode

                self.child[index] = newNode

                #deletes oldNode
                removeNode.parent = None
                removeNode.nodeNext = None
                removeNode.nodePrevious = None

                for i in range(len(removeNode.child) - 1, -1, -1):
                    removeNode.remove(removeNode.child[i])

            def remove(self, node : "Node"):
                """Takes in a node that is a child of self, removes node. raises exception if node is not a child
                
                deletes references to other nodes from Node, recursively removes child nodes of Node using remove()
                This is to make it easier to the python garbage collecter to destroy it, because cyclic references"""
                assert type(node) is self.__class__

                index : int = None
                for i in range(len(self.child)):
                    if self.child[i] is node:
                        index = i

                if index == None:
                    raise Exception("node is not found, can not remove. node = \n" + str(node))

                removeNode : self.__class__ = self.child[index]

                logging.debug(debugHelper(inspect.currentframe()) + "attempting to remove node"+ "\n" + str((
                        self.type,
                        self.token,
                        self.lineNum,
                        self.charNum,
                        self.child)))

                #'rewires' the references of the children nodes to remove removeNode
                if len(self.child) == 1: #case where removeNode is the only child in the list
                    logging.debug(debugHelper(inspect.currentframe()) + "only child detected")
                    pass
                elif index == 0: #case where removeNode is first child in the list, but not the only child in the list
                    logging.debug(debugHelper(inspect.currentframe()) + "first child detected")
                    if type(removeNode.nodeNext) is self.__class__: #TODO figure out why this is neccissary to avoid a specific error.
                        removeNode.nodeNext.nodePrevious = None
                elif index == len(self.child) - 1: #case where removeNode is the last child in the list, but not the only child in the list
                    logging.debug(debugHelper(inspect.currentframe()) + "last child detected")
                    if type(removeNode.nodePrevious) is self.__class__:
                        removeNode.nodePrevious.nodeNext = None
                elif 0 < index < len(self.child) -1: #case where removeNode is between two other nodes
                    logging.debug(debugHelper(inspect.currentframe()) + "middle child detected")
                    if type(removeNode.nodePrevious) is self.__class__:
                        removeNode.nodePrevious.nodeNext = removeNode.nodeNext
                    if type(removeNode.nodeNext) is self.__class__:
                        removeNode.nodeNext.nodePrevious = removeNode.nodePrevious
                
                removeNode.parent = None
                removeNode.nodeNext = None
                removeNode.nodePrevious = None
                
                self.child.pop(index)
                
                for i in range(len(removeNode.child) - 1, -1, -1):
                    removeNode.remove(removeNode.child[i])

            def __repr__(self, depth : int = 1) -> str:
                """Recursivly composes a string representing the node hierarchy, returns a string.
                
                Called by print() to display the object"""
                assert type(depth) is int
                assert depth >= 1

                block : str = ""
                line : str = ""
                for i in range(depth):
                    line += "    "
                line += repr(self.token)
                line = line.ljust(40, " ")
                line += "\t:" + str(self.type).capitalize().ljust(8)
                line += "\t" + str(depth)

                line += "\t" + "lineNum=" + str(self.lineNum) + "\t" + "charNum=" + str(self.charNum)

                line += "\n"

                childLines : list[str] = [i.__repr__(depth+1) for i in self.child]
                block += line
                for i in childLines:
                    block += i

                return block
                
            def __eq__(self, other) -> bool:
                """A custom equals comparision. Takes in another object other, and compaires it to self.token. Returns True if equal, False otherwise"""
                logging.debug(debugHelper(inspect.currentframe()) + "Custom equals comparison")

                #return self.token == other
                if type(other) is self.__class__:
                    return self.token == other.token
                else:
                    return self.token == other

            def __ne__(self, other) -> bool:
                """A custom not equals comparision. Takes in another object other, and compaires it to self.token. Returns True if not equal, False otherwise"""
                logging.debug(debugHelper(inspect.currentframe()) + "Custom equals comparison")

                #return self.token != other
                if type(other) is self.__class__:
                    return self.token != other.token
                else:
                    return self.token != other

            #No longer needed since remove() cleans up enough recursivly for the python garbage collector to pick it up. This function might be useful for debugging purposes
            def __del__(self):
                """Decontructor, needed because the various inter-node references may make it harder for the python garbage collector to properly delete an entire tree.
                
                will not touch pointers to this node from other nodes. IE: nodeNext's pointer to this node could be set to None, but that could get messy?"""
                
                logging.debug(debugHelper(inspect.currentframe()) + "Deleting Node" + "\n" + str((
                        self.type,
                        self.token,
                        self.lineNum,
                        self.charNum))
                        )
                
                self.parent = None
                self.nodeNext = None
                self.nodePrevious = None

                while len(self.child) != 0:
                    self.remove(self.child[0])

        def _tokenize(self, code : str) -> list[tuple[str, int, int]] :
            """Takes in a string of code, returns a list of tuples representing the code in the form of (string/tuple, line location, character location in line). 
            
            No characters are filtered out
            
            Case 1: "test\n\nHello World" =>
            [
                ('test',    0, 0),
                ('\n',      0, 0),
                ('\n',      1, 0),
                ('Hello',   2, 0),
                (' ',       2, 5),
                ('World',   2, 6)
            ]
            """
            assert type(code) is str
            assert len(code) > 0

            #done like this to easily add extra characters
            _isName : Callable[[str], bool] = lambda x : x.isalnum() or x in "_" #returns True is character can be in a name, False otherwise

            tokenList : list[tuple[str, int, int]] = []
            token : str = ""
            lineNum : int = 0
            characterNum : int = 0
            for j in code:
                if _isName(j): #creates tokens from everything that could be a variable name
                    token += j
                else: #everything else is a special character
                    if token != "":
                        tokenList.append((token, lineNum, characterNum))
                        token = ""
                    tokenList.append((j, lineNum, characterNum))

                #keeps track of line and positition numbers
                if j == "\n":
                    lineNum += 1
                    characterNum = 0
                else:
                    characterNum += 1
            if token != "": #adds last token
                tokenList.append((token, lineNum, characterNum))
                token = ""

            return tokenList

        def ruleCastInts(self, tree : Node) -> Node:
            """Takes in a Node Tree of depth 2, casts all children that are integers to integers (with labels). Returns a Node Tree of depth 2.

            Does not recurse #TODO should recurse

            Case: "123 456 789" =>
            Node
                '123'   |
                ' '
                '456'   |
                ' '
                '789'   |
            =>
            Node
                123     |
                ' '
                456     |
                ' '
                789     |
            """
            assert type(tree) is self.Node

            root : self.Node = tree.copyInfo()

            for i in tree.child:
                if type(i.token) is str:
                    if i.token.isdigit():
                        temp = i.copyDeep()
                        temp.token = int(i.token)
                        temp.type = "int"
                        root.append(temp)
                    else:
                        root.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root

        def ruleCastHex(self, tree : Node) -> Node:
            """Takes in a Node Tree of depth 2, casts all children that are in hex format to integers (with labels). Returns a node tree of depth 2.

            Does not recurse #TODO should recurse

            Case: "0x0 0x000A 0xff" =>
            Node
                '0x0'       |
                ' '
                '0x000A'    |
                ' '
                '0xff'      |
            =>
            Node
                0           |
                ' '
                10          |
                ' '
                255         |
            """
            assert type(tree) is self.Node

            root : self.Node = tree.copyInfo()

            for i in tree.child:
                if type(i.token) == str:
                    if i.token.startswith("0x") or i.token.startswith("0X"):
                        temp : self.Node = i.copyDeep()
                        temp.token = int(i.token, 16)
                        temp.type = "int"
                        root.append(temp)
                    else:
                        root.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root

        def ruleRemoveEmptyLines(self, tree : Node) -> Node:
            """Takes in a Node Tree of depth 2. Removes all empty lines. Returns a Node Tree of depth 2.

            Does not recurse

            Case 1: "test\ntest\n\n\ntest\n" =>
            Node
                'test'
                '\n'
                'test'
                '\n'    |
                '\n'    |
                '\n'    |
                'test'
                '\n'
            Node
                'test'
                '\n'
                'test'
                '\n'    |
                'test'
                '\n'
            """
            assert type(tree) is self.Node

            root : self.Node = tree.copyInfo()

            stack : str = "\n"

            for i in tree.child:
                #if previous == "\n" and current == "\n" do nothing, else copy Node
                if i != "\n" or stack != "\n":
                    root.append(i.copyDeep())
                    stack = i.token

            return root

        def ruleRemoveLeadingWhitespace(self, tree : Node, whiteSpace : list[str] = [" ", "\t"]) -> Node:
            """Takes in a Node Tree of depth 2, removes all white space tokens between a new line token and the next token. Returns a Node Tree of depth 2.
            
            Does not recurse

            Case: "test test \ntest\n  \ttest\t\n     \n" -> "test test \ntest\ntest\t\n\n" ->
            Node
                'test'
                ' '
                'test'
                ' '
                '\n'
                'test'
                '\n'
                'test'
                '\t'
                '\n'
                '\n'
            """
            assert type(tree) is self.Node
            assert type(whiteSpace) is list
            assert all([len(i) == 1 for i in whiteSpace])

            root : self.Node = tree.copyInfo()

            stack : str = "\n" #initialize to State 0
            if len(tree.child) != 0:
                if tree.child[0] == "\n":
                    stack = None #initialize to State 1

            ''' Finite State Machine
            State 0: at beginning of line
            State 1: after first token
            Edge: 0 -> 0: found whitespace, not copying
            Edge: 0 -> 1: found token, copying
            Edge: 1 -> 0: found newline
            Edge: 1 -> 1: did not find newline, copy token
            '''
            for i in tree.child:
                logging.debug(debugHelper(inspect.currentframe()) + repr(i.token))
                if stack != None: #State 0: at beginning of line
                    if i.token in whiteSpace: #Edge: 0 -> 0: found whitespace, not copying
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 0 -> 0")
                        pass
                    else: #Edge: 0 -> 1: found token, copying
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 0 -> 1")
                        root.append(i.copyDeep())
                        stack = None
                else: #State 1: after first token
                    if i == "\n": #Edge: 1 -> 0: found newline
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 1 -> 0")
                        stack = "\n"
                        root.append(i.copyDeep())
                    else: #Edge: 1 -> 1: did not find newline, copy token
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 1 -> 1")
                        root.append(i.copyDeep())

            return root

        def ruleStringSimple(self, tree : Node) -> Node:
            """Takes in a Node Tree of depth 2, combines all the tokens that are contained by quote tokens into a string node. Returns a Node Tree of depth 2.
            #TODO allow for arbitrary definition of list of 'quote like characters'

            Does not recurse
            
            Case: "test 'test'" ->
            Node
                'test'
                ' '
                "test"

            Case: "\'test\n\\\'test\\\''\ntest" ->
            Node
                "test\n\\\'test\\\'"
                '\n'
                'test'

            Case: "\'test\n\'test\'\'\ntest" ->
            Node
                "test\n"
                "test"
                ""
                "\n"
                "test"

            Case: "test1\"abc\'123\'abc\"test2" ->
                "test1"
                "abc\'123\'abc"
                "test2"

            Case: "" ->
                None
            """
            assert type(tree) is self.Node

            root : self.Node = tree.copyInfo()
            string : str = ""

            stack : str = None
            lineNum : int = None
            charNum : int = None

            '''Finite State Machine
            State 0 #Looking for an opening quote
            State 1 #Looking for a closing quote
            Edge 0 -> 0 iff token != quote: append node to root
            Edge 0 -> 1 iff token == quote: setup looking for closing quote
            Edge 1 -> 1 iff token != quote: append string with token
            Edge 1 -> 0 iff token == quote: copy string to node, append to root
            '''
            for i in tree.child:
                if stack == None: #the 'looking for an opening quote' State 0
                    if i != "\"" and i != "\'": #Edge 0 -> 0
                        root.append(i.copyDeep())
                    if i == "\"" or i == "\'":
                        if i.nodePrevious != "\\": #Edge 0 -> 1
                            stack = i.token
                            lineNum = i.lineNum
                            charNum = i.charNum
                        elif i.nodePrevious == "\\": #Edge 0 -> 0
                            root.append(i.copyDeep())
                elif stack != None: #the 'in a quote' State 1
                    if i != stack: #Edge 1 -> 1
                        string += str(i.token)
                    if i == stack:
                        if i.nodePrevious != "\\": #Edge 1 -> 0
                            temp = self.Node("string", string, lineNum, charNum)
                            root.append(temp)

                            stack = None
                            lineNum = None
                            charNum = None
                            string = ""
                        elif i.nodePrevious == "\\": #Edge 1 -> 1
                            string += str(i.token)

            if stack != None: #TODO handle mis-matched quotes
                raise Exception("Parse Error: Mismatched quotes")

            return root

        def ruleFilterLineComments(self, tree : Node, character : str = "#") -> Node:
            """Takes in a Node Tree of depth 2, removes any tokens between a "#" token and a new line token. Returns a Node Tree of depth 2.

            Does not recurse

            Case: "test #test\n #test\n\t\\#test" -> "test \n \n\t\\#test" ->
            Node
                'test'
                ' '
                '\n'
                ' '
                '\n'
                '\t'
                '\\
                '#'
                'test'
            
            Case: "test test \\# test #abc abc abc \\n abc \n test test" ->
            Node
                'test'
                ' '
                'test'
                ' '
                '\\'
                '#'
                ' '
                'test'
                ' '
                '\n'
                ' '
                'test'
                ' '
                'test'
            """
            assert type(tree) is self.Node
            assert type(character) is str 
            assert len(character) == 1

            root : self.Node = tree.copyInfo()

            stack : str = None

            '''Finite State Machine
            State 0: Looking for comment begin
            State 1: Looking for comment end
            0 -> 0 iff token != # : append token to root
            0 -> 1 iff token == # : setup looking for \n
            1 -> 1 iff token != \n : do nothing
            1 -> 0 iff token == \n : append \n to root
            '''
            for i in tree.child:
                if stack == None:
                    if i != character:
                        root.append(i.copyDeep())
                    elif i == character:
                        if i.nodePrevious != "\\":
                            stack = character
                        elif i.nodePrevious == "\\":
                            root.append(i.copyDeep())
                elif stack != None:
                    if i != "\n":
                        pass
                    elif i == "\n":
                        if i.nodePrevious != "\\":
                            stack = None
                            root.append(i.copyDeep())
                        elif i.nodePrevious == "\\":
                            pass

            return root

        def ruleContainer(self, tree : Node, containers : dict[str, str] = {"(":")", "[":"]", "{":"}"}, nodeType : str = "container") -> Node:
            """Takes in a Node Tree of depth 2, finds containers "([{}])" and rearranges nodes to form a tree respecting the containers. Returns a Node Tree of arbitrary depth.

            Containers are of the form {"opening bracket": "closing bracket", ...}
            Does not copy closing brackets
            Does not recurse
            
            Case: "test[test(test)]" ->
            Node
                'test'
                '['
                    'test'
                    '('
                        'test'

            Case: "test[abc abc{123 123}{123 123}](abc)" ->
            Node
                'test'
                '['
                    'abc'
                    ' '
                    'abc'
                    '{'
                        '123'
                        ' '
                        '123'
                    '{'
                        '123'
                        ' '
                        '123'
                '('
                    'abc'
            """
            assert type(tree) is self.Node
            assert type(containers) is dict
            assert len(containers) >= 1
            assert all([True if type(i) is str else False for i in containers.keys()])
            assert all([True if type(containers[i]) is str else False for i in containers.keys()])
            assert all([True if len(i) == 1 else False for i in containers.keys()])
            assert all([True if len(containers[i]) == 1 else False for i in containers.keys()])
            assert all([True if containers[i] != i else False for i in containers.keys()]) #asserts that the 'matching bracket' isn't the same characters
            assert type(nodeType) is str

            root : self.Node = tree.copyInfo()
            stack : list[tuple[str, self.Node]] = []

            for i in tree.child:
                '''
                if openbracket
                    append to stack
                if closing bracket
                    pop from stack
                    append to root
                else
                    if len(stack) == 0
                        append to root
                    else
                        append to last element in stack
                '''
                if i.token in list(containers.keys()): #if open bracket
                    #append to stack
                    temp : self.Node = i.copyDeep()
                    temp.type = nodeType
                    stack.append((i.token, temp))
                elif len(stack) != 0:
                    if containers[stack[-1][0]] == i.token: #if closing bracket
                        temp : self.Node = stack.pop()[1] #pop from stack

                        if len(stack) != 0: #append to last element in stack, otherwise append to root
                            stack[-1][1].append(temp)
                        else:
                            root.append(temp)
                    else: #not container, append to last element in stack
                        stack[-1][1].append(i.copyDeep())
                else: #not container, append to last element in stack, otherwise append to root
                    if len(stack) == 0:
                        root.append(i.copyDeep())
                    else:
                        stack[-1][1].append(i.copyDeep())

            if len(stack) != 0:
                raise Exception("Parse Error: mismatching brackets")

            return root

        def ruleFindLabels(self, tree : Node) -> tuple[Node, dict[str, Node]]:
            """Takes in a Node Tree of depth 2, attempts to find a label that is immidiatly followed by a ":", returns a Node Tree of depth 2, and a dictionary of labels
            
            Does not recurse"""
            assert type(tree) is self.Node

            root : self.Node = tree.copyInfo()
            previous : str = "\n"
            skipToken : bool = False

            labels : dict[str, self.Node] = {}

            for i in tree.child:
                if (i.nodePrevious == previous or i.nodePrevious == None) and i.nodeNext == ":":
                    temp : self.Node = i.copyDeep()
                    temp.type = "label"
                    root.append(temp)

                    labels[i.token] = temp.copyInfo()

                    previous = i.token
                    skipToken = True
                elif skipToken == True:
                    skipToken = False
                else:
                    root.append(i.copyDeep())
                    previous = i.token

            return (root, labels)

        def ruleLabelNamespace(self, tree : Node, nameSpace : dict, tokenType : str = "namespace") -> Node:
            """Takes in a node tree, and a nameSpace. Labels all nodes that are in nameSpace as 'NameSpace'. Returns Node Tree of depth 2.
            
            Does not recurse
            #TODO find a better/less confusing name (conflicts with ruleFindLabels)?"""
            assert type(tree) is self.Node
            assert type(nameSpace) is dict
            assert type(tokenType) is str

            root : self.Node = tree.copyInfo()
            keys : list[str]= [i.lower() for i in nameSpace.keys()]

            for i in tree.child:
                if type(i.token) is str:
                    if i.token.lower() in keys:
                        temp = i.copyDeep()
                        temp.type = tokenType
                        root.append(temp)
                    else:
                        root.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root
        
        def ruleRemoveToken(self, tree : Node, token : str, recurse : bool = True) -> Node:
            """Takes in a Node Tree of arbitrary depth, and a token. Removes all instances of token in tree.child. Returns a Node Tree of arbitrary depth.
            
            Case 1: token = '\n'
            Node
                'test1'
                '\n'
                'test2'
            =>
            Node
                'test1'
                'test2'

            Case 2: token = ','
            Node
                'add'
                    'arg1'
                    ','
                    'arg2'
                ','
                'mult'
                    'arg1'
                    ','
                    'arg2'
            =>
            Node
                'add'
                    'arg1'
                    'arg2'
                'mult'
                    'arg1'
                    'arg2'
            """
            assert type(tree) is self.Node
            
            root : self.Node = tree.copyInfo()

            for i in tree.child:
                if i != token:
                    root.append(i.copyDeep())

            if recurse:
                newRoot : self.Node = tree.copyInfo()
                for i in root.child:
                    newRoot.append(self.ruleRemoveToken(i.copyDeep(), token, True))
                root = newRoot

            return root
        
        def ruleSplitLines(self, tree : Node, tokenType : str = "line", splitToken : str = "\n") -> list[Node]:
            """Takes in a Node Tree of arbitrary depth. Returns a list of Node Trees of arbitrary depth, split by the splitToken ("\n") with the splitToken ommited.
            
            #TODO should be able to recurse
            """
            assert type(tree) is self.Node
            assert type(tokenType) is str
            assert type(splitToken) is str

            result : list[self.Node] = []
            current : self.Node = self.Node(tokenType, None, 0, 0)

            for i in tree.child:
                if i == splitToken:
                    result.append(current)
                    current = self.Node(tokenType, None, 0, 0)
                else:
                    current.append(i.copyDeep())

            if len(current.child) >= 1:
                result.append(current)

            #Goes through all 'lines' and sets lineNum and charNum to the values of the first child Node in them
            for i in result:
                if len(i.child) != 0:
                    i.lineNum = i.child[0].lineNum
                    i.charNum = i.child[0].charNum

            return result

        def ruleSplitTokens(self, tree : Node, tokenType : str = "line", splitToken : str = "\n", recurse : bool = True) -> Node:
            """Takes in a Node Tree of arbitrary depth. Returns a Node Trees of arbitrary depth, split by the splitToken ("\n") with the splitToken ommited, and in containers.

            Case 1: splitToken = "\n"
            Node
                'test'
                '\n'    #notice the splitToken '\n' is omitted
                'abc'
            =>
            Node
                None
                    'test'
                None
                    'abc' 

            Case 2: splitToken = ','
            Node
                'test1'
                'test2'
                    'abc1'
                    ','
                    'abc2'
                    ','
                    'abc3'
                    'abc4'
            =>
            Node
                'test1'
                'test2'
                    None
                        'abc1'
                    None
                        'abc2'
                    None
                        'abc3'
                        'abc4'
            
            Case 3: splitToken = ','
            Node
                'test1'
                    'abc1'
                    ','
                    'abc2'
                ','
                'test2'
            =>
            Node
                None
                    'test1'
                        None
                            'abc1'
                        None
                            'abc2'
                None
                    'test2'

            Case 4: splitToken = '\n'
            Node
                'test1'
                'test2'
                'test3'
            =>
            Node
                'test1'
                'test2'
                'test3'
            """
            assert type(tree) is self.Node
            assert type(tokenType) is str
            assert len(tokenType) > 0
            assert type(splitToken) is str
            assert len(splitToken) > 0
            assert type(recurse) is bool

            root : self.Node = tree.copyInfo()
            tokenFound : bool = False

            #checks if there is a splitToken in children
            for i in tree.child:
                if i == splitToken:
                    tokenFound = True

            if tokenFound:
                stack : list[self.Node] = []
                for i in tree.child:
                    if i == splitToken:
                        temp : self.Node = self.Node(tokenType, None, stack[0].lineNum, stack[0].charNum)
                        while len(stack) != 0:
                            temp.append(stack.pop(0))
                        root.append(temp)
                    else:
                        #stack.append(self.ruleSplitTokens(i.copyDeep(), tokenType, splitToken, recurse) if recurse else i.copyDeep())
                        temp : self.Node = None
                        if recurse:
                            temp = self.ruleSplitTokens(i.copyDeep(), tokenType, splitToken, recurse)
                        else:
                            temp = i.copyDeep()
                        stack.append(temp)

                if len(stack) != 0:
                    temp : self.Node = self.Node(tokenType, None, stack[0].lineNum, stack[0].charNum)
                    while len(stack) != 0:
                        temp.append(stack.pop(0))
                    root.append(temp)
                    
            else: #the splitToken not found case
                for i in tree.child:
                    temp : self.Node = None
                    if recurse:
                        temp = self.ruleSplitTokens(i.copyDeep(), tokenType, splitToken, recurse)
                    else:
                        temp = i.copyDeep()
                    root.append(temp)
            
            return root

        def ruleNestContainersIntoInstructions(self, tree : Node, nameSpace : dict, recurse : bool = True) -> Node:
            """Takes in a Node Tree of arbitrary depth, and a nameSpace dict represeting instructions, registers, etc. 
            If a container node follows a nameSpace node, make container node a child of the nameSpace node.
            Returns a Node Tree of arbitrary depth.

            Recurses by default            
            """
            assert type(tree) is self.Node
            assert type(nameSpace) is dict
            
            root : self.Node = tree.copyInfo()

            for i in tree.child:
                if i.type == "container":  
                    temp : self.Node = None
                    if recurse:
                        temp = self.ruleNestContainersIntoInstructions(i.copyDeep(), nameSpace, True)
                    else:
                        temp = i

                    if type(i.nodePrevious) is self.Node: #IE: the node exists
                        if i.nodePrevious.token in nameSpace:
                            root.child[-1].append(temp.copyDeep())
                        else:
                            root.append(temp.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root

        def ruleLowerCase(self, tree : Node, recurse : bool = True) -> Node:
            """Takes in a Node Tree of arbitrary depth. Sets all tokens in the Node Tree's children as lower case. Recurses by default. Returns a Node Tree of arbitrary depth.
            
            Case 1:
            Node
                'HELLO'
                ' '
                'WORLD'
                    'test'
                    'ABC'
            =>
            Node
                'hello'
                ' '
                'world'
                    'test'
                    'abc'
            """
            assert type(tree) is self.Node

            root : self.Node = tree.copyInfo()
            for i in tree.child:
                temp : self.Node = i.copyDeep()
                if type(temp.token) is str:
                    temp.token = temp.token.lower()
                if recurse:
                    temp = self.ruleLowerCase(temp, True)
                root.append(temp)
            
            return root

        def ruleApplyAlias(self, tree : Node, alias : dict[str, str]) -> Node:
            """Takes in a Node Tree of Depth 2. If a token is in alias, replaces that token, then tokenizes it. Returns a Node Tree of Depth 2.
            
            Case 1: alias = {'123': 'hello world'}
            Node
                'test'
                ' '
                '123'       |
                ' '
                'abc'
            =>
            Node
                'test'
                ' '
                'hello'     | #notice how the string 'hello world' was tokenized
                ' '         |
                'world'     |
                ' '
                'abc'
            
            Case 2: alias = {'abc' : '1 2 3'}
            Node
                'test'
                ' '
                'abc'       |
                    'hello' |
                    ' '     |
                    'world' |
                ' '
                'temp
            =>
            Node
                'test'
                ' '
                '1'         | #notice how the children of 'abc' was added to the first of the replacement nodes
                    'hello' |
                    ' '     |
                    'world' |
                ' '         |
                '2'         |
                ' '         |
                '3'         |
                ' '
                'temp'
            """
            assert type(tree) is self.Node
            assert type(alias) is dict
            assert all([type(i) is str for i in alias.keys()])
            assert all([type(i) is str for i in alias.values()])
            assert all([i != j for i, j in alias.items()])

            root : self.Node = tree.copyInfo()

            for i in tree.child:
                temp = []
                if type(i.token) is str and i.token in alias: #if alias token found, tokenize it's replacement string, and add that series of tokens to root
                    for j in self._tokenize(alias[i.token]):
                        temp.append(self.Node("token", j[0], i.lineNum, i.charNum))
                else:
                    temp.append(i.copyInfo())

                for j in i.child: #if alias token has children, add children to first token of the replacement tokens
                    temp[0].append(j.copyDeep)
                
                #append tokens to root
                for j in temp:
                    root.append(j)

            return root

        def ruleFilterBlockComments(self, tree : Node, character : dict = {}) -> Node:
            #TODO
            pass

        def ruleFindDirectives(self, tree : Node, directives : dict) -> Node:
            #TODO
            pass

        def parseCode(self, sourceCode : str) -> tuple[Node, dict[str, Node]]:
            """Takes a string of source code, returns a parsed instruction tree
            
            Takes source code of the form:
                #This is a comment, non-functional example code
                label1:     add(r[0],r[0],r[0])
                            and(r[1],r[2],r[0]) #Another comment
                label2:     jump(label1)
            Returns:
                None                                        :Root           1       lineNum=None    charNum=None
                    None                                    :Line           2       lineNum=2       charNum=31
                        'add'                               :Namespace      3       lineNum=2       charNum=31
                            '('                             :Container      4       lineNum=2       charNum=31
                                None                        :Argument       5       lineNum=2       charNum=33
                                    'r'                     :Namespace      6       lineNum=2       charNum=33
                                        '['                 :Container      7       lineNum=2       charNum=33
                                            0               :Int            8       lineNum=2       charNum=35
                                None                        :Argument       5       lineNum=2       charNum=38
                                    'r'                     :Namespace      6       lineNum=2       charNum=38
                                        '['                 :Container      7       lineNum=2       charNum=38
                                            0               :Int            8       lineNum=2       charNum=40
                                None                        :Argument       5       lineNum=2       charNum=43
                                    'r'                     :Namespace      6       lineNum=2       charNum=43
                                        '['                 :Container      7       lineNum=2       charNum=43
                                            0               :Int            8       lineNum=2       charNum=45
                    None                                    :Line           2       lineNum=3       charNum=31
                        'and'                               :Namespace      3       lineNum=3       charNum=31
                            '('                             :Container      4       lineNum=3       charNum=31
                                None                        :Argument       5       lineNum=3       charNum=33
                                    'r'                     :Namespace      6       lineNum=3       charNum=33
                                        '['                 :Container      7       lineNum=3       charNum=33
                                            1               :Int            8       lineNum=3       charNum=35
                                None                        :Argument       5       lineNum=3       charNum=38
                                    'r'                     :Namespace      6       lineNum=3       charNum=38
                                        '['                 :Container      7       lineNum=3       charNum=38
                                            2               :Int            8       lineNum=3       charNum=40
                                None                        :Argument       5       lineNum=3       charNum=43
                                    'r'                     :Namespace      6       lineNum=3       charNum=43
                                        '['                 :Container      7       lineNum=3       charNum=43
                                            0               :Int            8       lineNum=3       charNum=45
                    None                                    :Line           2       lineNum=4       charNum=32
                        'jump'                              :Namespace      3       lineNum=4       charNum=32
                            '('                             :Container      4       lineNum=4       charNum=32
                                'label1'                    :Token          5       lineNum=4       charNum=39
            """
            assert type(sourceCode) is str
            
            #tokenizes sourceCode, and turns it into a Node Tree
            root : self.Node = self.Node("root")
            for i in self._tokenize(sourceCode):
                root.append(self.Node("token", i[0], i[1], i[2]))

            logging.debug(debugHelper(inspect.currentframe()) + "this is the original code: " + "\n" + repr(sourceCode))
            logging.debug(debugHelper(inspect.currentframe()) + "tokenized code: " + "\n" + str(root))

            #Note: at this point, rules do operations on the Node Tree, but the depth of the Node Tree remains 2

            root = self.ruleFilterLineComments(root, "#")
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFilterLineComments: " + "\n" + str(root))

            root = self.ruleStringSimple(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleStringSimple: " + "\n" + str(root))

            root = self.ruleApplyAlias(root, self.alias)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleApplyAlias: " + "\n" + str(root))

            root = self.ruleLowerCase(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleLowerCase: " + "\n" + str(root))            

            root = self.ruleRemoveLeadingWhitespace(root, [" ", "\t"])
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveLeadingWhitespace: " + "\n" + str(root))

            root = self.ruleRemoveEmptyLines(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveEmptyLines: " + "\n" + str(root))

            root, self.labels = self.ruleFindLabels(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFindLabels: " + "\n" + str(root) + "\nlabels: " + str(self.labels))
            i = 0
            while i < len(root.child): #removes the label nodes, as they don't need to be executed
                if root.child[i].type == "label":
                    root.remove(root.child[i])
                else:
                    i += 1
            
            root = self.ruleLabelNamespace(root, self.nameSpace)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleLabelNamespace: " + "\n" + str(root))

            root = self.ruleRemoveToken(root, " ", False)
            root = self.ruleRemoveToken(root, "\t", False)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveToken: " + "\n" + str(root))

            root = self.ruleCastInts(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleCastInts: " + "\n" + str(root))

            root = self.ruleCastHex(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleCastHex: " + "\n" + str(root))

            #This is where the Node Tree is allowed to go to depth > 2
            root = self.ruleContainer(root, {"(":")", "[":"]"})
            logging.debug(debugHelper(inspect.currentframe()) + "ruleContainer: " + "\n" + str(root))

            root = self.ruleNestContainersIntoInstructions(root, self.nameSpace, True)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleNestContainersIntoInstructions: " + "\n" + str(root))

            temp : list[self.Node] = self.ruleSplitLines(root, "line", "\n")
            root = self.Node("root")
            for i in temp:
                root.append(i)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleSplitLines: " + "\n" + str(root))

            #removes empty lines/empty line nodes
            i = 0
            while i < len(root.child):
                if len(root.child[i].child) == 0:
                    root.remove(root.child[i])
                else:
                    i += 1
            logging.debug(debugHelper(inspect.currentframe()) + "remove empty line nodes: " + "\n" + str(root))

            root = self.ruleSplitTokens(root, "argument", ',', True)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleSplitTokens: " + "\n" + str(root))

            return root, self.labels
            
    class InstructionSetDefault:
        """A simplified instruction set implimentation, along with a number of base instructions to help build an instruction set.
        
        Note: uses 'carry' flag, but doesn't need that flag to run. IE: will use 'carry' flag if present
        Note: instruction functions do not 'see' immediate values, they instead see an index of register 'imm' (IE: immediate values are filtered out before instructions are called)
        """

        def __init__(self):
            self.instructionSet : dict[str, Callable[[dict, dict, dict, dict, "Arguments (Optional)"], None]] = {
                "nop"   : self.opNop,
                "add"   : self.opAdd,
                "mult"  : self.opMultiply,
                "twos"  : self.opTwosCompliment,
                "and"   : self.opAND,
                "or"    : self.opOR,
                "xor"   : self.opXOR,
                "not"   : self.opNOT,
                "jumpeq": (lambda z1, z2, z3, z4,   pointer, a, b     : self.opJump(z1, z2, z3, z4,       "==", pointer, a, b)),
                "jumpne": (lambda z1, z2, z3, z4,   pointer, a, b     : self.opJump(z1, z2, z3, z4,       "!=", pointer, a, b)),
                "jump"  : (lambda z1, z2, z3, z4,   pointer           : self.opJump(z1, z2, z3, z4,       "goto", pointer)),
                "shiftl": (lambda z1, z2, z3, z4,   des, a            : self.opShiftL(z1, z2, z3, z4,     des, a, 1)),
                "shiftr": (lambda z1, z2, z3, z4,   des, a            : self.opShiftR(z1, z2, z3, z4,     des, a, 1)),

                "halt"  : self.opHalt
            }

            self.stats : dict = {}

            self.directives : dict = {}

        def redirect(self, redirection : str, register : str, index : str or int) -> tuple[str, int]:
            """Takes in redirection as a pointer to the memory array to access, and a register index pair. Returns a key index pair corrispoding to redirection as key, index as value stored in register[index]"""
            assert type(redirection) is str
            assert type(register) is str
            assert type(index) is str or type(index) is int

            return (redirection, register[index])

        def enforceImm(self, registerTuple : tuple[str, int], bitLength : int = None) -> tuple[str, int]:
            """Takes in a register key index pair. Returns a register key index pair iff key is 'imm' for immediate. Raises an Exception otherwise
            
            #TODO this should be replaced with a more generic function that allows for restricting access to a specific register. IE: The 'add' instruction destination can only be 'accumulate' register
            """
            assert type(registerTuple) is tuple and len(registerTuple) == 2 
            assert type(registerTuple[0]) is str and (type(registerTuple[0]) is int or type(registerTuple[0]) is str) 

            assert type(bitLength) is type(None) or type(bitLength) is int
            assert (True if bitLength >= 1 else False) if type(bitLength) is int else True

            if registerTuple[0] != "imm":
                raise Exception("Expected immediate value, got register instead")
            if bitLength != None:
                pass #TODO should also be able to limit the size of the immediate value. IE: imm < 2**12

            return registerTuple

        def enforceRegisterAccess(self, registerTuple : tuple[str, int], key : str = None, index : str = None) -> tuple[str, int]:
            pass #TODO

        def int2bits(self, number : int, bitLength : int) -> list[int]:
            """Takes a bitLength, and a number where ((0 - 2**bitLength) // 2 <= number < 2**bitLength). Returns a bit int array representing the number, zero index is least significant bit
            
            For numbers < 0, twos compliment is applied (python represents negative numbers correctly when appling bitise operations)
            """
            assert type(bitLength) is int
            assert bitLength > 0

            assert type(number) is int
            assert (0 - 2**bitLength) // 2 <= number < 2**bitLength

            number = number & (2**bitLength - 1)
            bitArray = [number >> i & 1 for i in range(bitLength)] #index 0 is least significant bit
            return bitArray

        def bits2int(self, bitArray : list[int or bool]) -> int:
            """Takes in a bit (int or bool) array where zero index is least significant bit. Returns the positive number is represents"""
            assert type(bitArray) is list
            assert len(bitArray) > 0
            assert all([(type(i) is int or type(i) is bool) for i in bitArray])

            return sum([bit << i for i, bit in enumerate(bitArray)])

        def opNop(self, oldState, newState, config, engine):
            newState['pc'][0] = oldState['pc'][0] + 1

        def opAdd(self, oldState, newState, config, engine, des, a, b):
            """adds registers a and b, stores result in des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(b) is tuple and len(b) == 2 
            assert type(b[0]) is str and (type(b[0]) is int or type(b[0]) is str) 

            a1, a2 = a
            b1, b2 = b
            des1, des2 = des

            newState[des1][des2] = oldState[a1][a2] + oldState[b1][b2]

            if 'flag' in newState.keys():
                if 'carry' in newState['flag']:
                    if newState[des1][des2] >= 2**config[des1][des2]['bitLength']:
                        newState['flag']['carry'] = 1
            
            newState[des1][des2] = newState[des1][des2] & (2**config[des1][des2]['bitLength'] - 1)

            newState['pc'][0] = oldState['pc'][0] + 1

        def opMultiply(self, oldState, newState, config, engine, des, a, b):
            """multiplys registers a and b, stores result in des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(b) is tuple and len(b) == 2 
            assert type(b[0]) is str and (type(b[0]) is int or type(b[0]) is str) 

            n = oldState[a[0]][a[1]]
            m = oldState[b[0]][b[1]]
            des1, des2 = des

            result = n * m
            result = result & (2**config[des1][des2]['bitLength'] -1)
            newState[des1][des2] = result

            newState['pc'][0] = oldState['pc'][0] + 1

        def opTwosCompliment(self, oldState, newState, config, engine, des, a):
            """performs Twos COmpliment on register a, stores result in register des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str)
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 

            a1, a2 = a
            des1, des2 = des

            inputNumber = oldState[a1][a2] & (2**config[des1][des2]['bitLength'] - 1) #Cuts down number to correct bitLength BEFORE converting it
            bitArray = [inputNumber >> i & 1 for i in range(config[des1][des2]['bitLength'] - 1, -1, -1)] #converts to bit array, index 0 is most significant bit
            bitArray = [not i for i in bitArray] #performs the bitwise NOT operation
            result = sum([bit << (len(bitArray) - 1 - i) for i, bit in enumerate(bitArray)]) #converts bit array back into a number
            result += 1
            result = result & (2**config[des1][des2]['bitLength'] - 1)

            ''' #this way, the 0 index is least significant bit
            t1 = a & ((2**bitLength) - 1)
            t1 = [t1 >> i & 1 for i in range(bitLength)] #index 0 is least significant bit
            t1 = [not i for i in t1]
            t1 = sum([bit << i for i, bit in enumerate(t1)])
            t1 = t1 + 1
            t1 = t1 & (2**bitLength - 1)
            '''

            newState[des1][des2] = result

            newState['pc'][0] = oldState['pc'][0] + 1 #incriments the program counter
            
        def opAND(self, oldState, newState, config, engine, des, a, b):
            """performs operation AND between registers a and b, stores result in des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(b) is tuple and len(b) == 2 
            assert type(b[0]) is str and (type(b[0]) is int or type(b[0]) is str) 

            a1, a2 = a
            b1, b2 = b
            des1, des2 = des

            newState[des1][des2] = oldState[a1][a2] & oldState[b1][b2] #performs the bitwise AND operation

            newState[des1][des2] = newState[des1][des2] & (2**config[des1][des2]['bitLength'] - 1) #'cuts down' the result to something that fits in the register/memory location

            newState['pc'][0] = oldState['pc'][0] + 1 #incriments the program counter

        def opOR(self, oldState, newState, config, engine, des, a, b):
            """performs operation OR between registers a and b, stores result in des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(b) is tuple and len(b) == 2 
            assert type(b[0]) is str and (type(b[0]) is int or type(b[0]) is str) 

            a1, a2 = a
            b1, b2 = b
            des1, des2 = des

            newState[des1][des2] = oldState[a1][a2] | oldState[b1][b2] #performs the bitwise OR operation

            newState[des1][des2] = newState[des1][des2] & (2**config[des1][des2]['bitLength'] - 1) #'cuts down' the result to something that fits in the register/memory location

            newState['pc'][0] = oldState['pc'][0] + 1 #incriments the program counter

        def opXOR(self, oldState, newState, config, engine, des, a, b):
            """performs operation XOR between registers a and b, stores result in des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(b) is tuple and len(b) == 2 
            assert type(b[0]) is str and (type(b[0]) is int or type(b[0]) is str) 

            a1, a2 = a
            b1, b2 = b
            des1, des2 = des

            newState[des1][des2] = oldState[a1][a2] ^ oldState[b1][b2] #performs the bitwise XOR operation

            newState[des1][des2] = newState[des1][des2] & (2**config[des1][des2]['bitLength'] - 1) #'cuts down' the result to something that fits in the register/memory location

            newState['pc'][0] = oldState['pc'][0] + 1 #incriments the program counter

        def opNOT(self, oldState, newState, config, engine, des, a):
            """performs operation NOT on register a, stores result in register des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str)
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 

            a1, a2 = a
            des1, des2 = des

            inputNumber = oldState[a1][a2] & (2**config[des1][des2]['bitLength'] - 1) #Cuts down number to correct bitLength BEFORE converting it
            bitArray = [inputNumber >> i & 1 for i in range(config[des1][des2]['bitLength'] - 1, -1, -1)] #converts to bit array
            bitArray = [not i for i in bitArray] #performs the bitwise NOT operation
            result = sum([bit << (len(bitArray) - 1 - i) for i, bit in enumerate(bitArray)]) #converts bit array back into a number
            
            newState[des1][des2] = result

            newState['pc'][0] = oldState['pc'][0] + 1 #incriments the program counter

        def opJump(self, oldState, newState, config, engine, mode : str, gotoIndex, a = None, b = None):
            """Conditional jump to gotoIndex, conditional on mode, and optional registers a and b

            #TODO needs to handle signed and unsigned ints

            mode:
                goto    - a simple jump without any condition testing, a and b must be set to None
                <       - less than
                <=      - less than or equal to
                >       - greater than
                >=      - greater than or equal to
                ==      - equal
                !=      - not equal
            """
            assert mode in ("goto", "<", "<=", ">", ">=", "==", "!=")
            assert (mode == "goto" and a == None and b == None) ^ (mode != "goto" and a != None and b != None)
            assert type(gotoIndex) is tuple and len(gotoIndex) == 2 #assert propper formated register
            assert type(gotoIndex[0]) is str and (type(gotoIndex[0]) is int or type(gotoIndex[0]) is str) #assert propper formated register

            pointer = oldState[gotoIndex[0]][gotoIndex[1]]

            if mode == "goto":
                newState['pc'][0] = pointer
            else:
                a1, a2 = a
                b1, b2 = b

                if mode == "<" and oldState[a1][a2] < oldState[b1][b2]:
                    newState['pc'][0] = pointer
                elif mode == "<=" and oldState[a1][a2] <= oldState[b1][b2]:
                    newState['pc'][0] = pointer
                elif mode == ">" and oldState[a1][a2] > oldState[b1][b2]:
                    newState['pc'][0] = pointer
                elif mode == ">=" and oldState[a1][a2] >= oldState[b1][b2]:
                    newState['pc'][0] = pointer
                elif mode == "==" and oldState[a1][a2] == oldState[b1][b2]:
                    newState['pc'][0] = pointer
                elif mode == "!=" and oldState[a1][a2] != oldState[b1][b2]:
                    newState['pc'][0] = pointer
                else:
                    newState['pc'][0] = oldState['pc'][0] + 1

        def opShiftL(self, oldState, newState, config, engine, des, a, n = 1):
            """Takes register a, shifts it left by n (key index pair, or int) bits. Stores result in des"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(n) is int or (type(n) is tuple and type(n[0]) is str and (type(n[1]) is int or type(n[1]) is str))

            a1, a2 = a
            des1, des2 = des

            amount = 0
            if type(n) is int:
                amount = n
            elif type(n) is tuple:
                amount = oldState[n[0]][n[1]]

            newState[des1][des2] = oldState[a1][a2] << amount

            newState[des1][des2] = newState[des1][des2] & (2**config[des1][des2]['bitLength'] - 1)

            newState['pc'][0] = oldState['pc'][0] + 1

        def opShiftR(self, oldState, newState, config, engine, des, a, n = 1, arithmetic : bool = False):
            """Takes register a, shifts it right by n (key index pair, or int) bits. Stores result in des
            
            #TODO test arithmetic shiftt"""
            assert type(des) is tuple and len(des) == 2 
            assert type(des[0]) is str and (type(des[0]) is int or type(des[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(n) is int or (type(n) is tuple and type(n[0]) is str and (type(n[1]) is int or type(n[1]) is str))
            assert type(arithmetic) is bool

            a1, a2 = a
            des1, des2 = des

            amount : int = 0
            if type(n) is int:
                amount = n
            elif type(n) is tuple:
                amount = oldState[n[0]][n[1]]

            result = oldState[a1][a2]
            for i in range(amount):
                t1 : int = 0
                if arithmetic:
                    t1 = 2 ** (config[a1][a2]['bitLength'] - 1)
                    t1 = t1 & result
                result = result >> 1
                result = result | t1

            result : int = result & (2**config[des1][des2]['bitLength'] - 1)

            newState[des1][des2] = result
            newState['pc'][0] = oldState['pc'][0] + 1

        def opHalt(self, oldState, newState, config, engine):
            engine["run"] = False

        def dirString(self, config) -> list[int]:
            #TODO
            pass

class RiscV:
    """A non-functional mockup of what a rudimentry Risc-V implimentation could look like. IE: this is what I'm aiming for, but nowhere near implimenting it, dispite half implimenting it

    useful for spotting architectual flaws, figuring out what to keep track of, etc.
    Specific implimentation attempts RV32I version 2.1 as per https://riscv.org/technical/specifications/ -> riscv-spec-20191213.pdf -> Volume 1, Unprivileged Spec v. 20191213

    Reference:
        https://riscv.org/technical/specifications/ -> riscv-spec-20191213.pdf -> Volume 1, Unprivileged Spec v. 20191213
            The technical specification for the RISC-V instruction set, and all it's modules
        https://www.cl.cam.ac.uk/teaching/1617/ECAD+Arch/files/docs/RISCVGreenCardv8-20151013.pdf 
            A cheat sheet of some of RISC-Vs instructions, instruction byte layout, etc
        https://metalcode.eu/2019-12-06-rv32i.html
            Another cheat sheet of some RISC-V instructions, register layout, etc
            #Why that font?... why?
        https://smist08.wordpress.com/2019/09/07/risc-v-assembly-language-hello-world/
            Hello World example
        https://github.com/andrescv/Jupiter
            A RISC-V simulator/assembler as a standalone program
        http://venus.cs61c.org/
            A RISC-V simulator/assembler as a webpage
            https://github.com/ThaumicMekanism/venus
            https://github.com/ThaumicMekanism/venusbackend
        https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/
            A RISC-V simulator as a webpage
            surprisingly simple and easy to use (at least for basic and simple instructions/programs)
        https://github.com/riscv/riscv-gnu-toolchain
            The RISC-V toolchain, used to compile C/C++ into RISC-V binaries, etc?
        https://github.com/d0iasm/rvemu
            The most complete RISC-V emulator I've seen so far, and you can run it in a web browser.
            https://rvemu.app/                          #The webapp
            https://github.com/d0iasm/rvemu-for-book
            https://book.rvemu.app/index.html           #A book about writing a RISC-V emulator
        https://www.youtube.com/watch?v=hF3sp-q3Zmk
            RISC-V is trying to launch an open-hardware revolution | Upscaled
            
    """
    
    def __init__(self):
        #when initalizing this class making an instance of this class, initalizing this class should return a CPUsim() object
        memorySize = 2**4
        xLength = None #TODO look up the name for the bitLength of the ISA from documentation

        CPU = CPUsim(32, defaultSetup=False)
        CPU.configSetDisplay(CPU.DisplaySilent()) #hides configuration steps from display

        CPU.configAddRegister("pc", 32, 1) #explicidly set the Program Counter to 32-bit
        CPU.configAddRegister("x", 32, 32)
        #CPU.configAddRegister("m", 8, memorySize, show=False)
        CPU.configAddRegister("m", 8, memorySize, show=False)
        
        #TODO remove this, impliment aliasing properly
        #not implimented: after tokenization, should replace the token arg1 with (arg2 tokonized again). NOT A STRING FIND AND REPLACE
        #configAddAlias() should be for simple token replacement AND NOTHING MORE
        CPU.configAddAlias("zero",  "x[00]") #always zero
        CPU.configAddAlias("ra",    "x[01]") #call return address
        CPU.configAddAlias("sp",    "x[02]") #stack pointer
        CPU.configAddAlias("gp",    "x[03]") #global pointer
        CPU.configAddAlias("tp",    "x[04]") #thread pointer
        CPU.configAddAlias("t0",    "x[05]") #t0-t6 temporary registers
        CPU.configAddAlias("t1",    "x[06]")
        CPU.configAddAlias("t2",    "x[07]")
        CPU.configAddAlias("s0",    "x[08]") #s0-s11 saved registers
        CPU.configAddAlias("fp",    "x[08]") #note the two different mappings for x[08] = fp = s0
        CPU.configAddAlias("s1",    "x[09]")
        CPU.configAddAlias("a0",    "x[10]") #a0-a7 function arguments
        CPU.configAddAlias("a1",    "x[11]")
        CPU.configAddAlias("a2",    "x[12]")
        CPU.configAddAlias("a3",    "x[13]")
        CPU.configAddAlias("a4",    "x[14]")
        CPU.configAddAlias("a5",    "x[15]")
        CPU.configAddAlias("a6",    "x[16]")
        CPU.configAddAlias("a7",    "x[17]")
        CPU.configAddAlias("s2",    "x[18]")
        CPU.configAddAlias("s3",    "x[19]")
        CPU.configAddAlias("s4",    "x[20]")
        CPU.configAddAlias("s5",    "x[21]")
        CPU.configAddAlias("s6",    "x[22]")
        CPU.configAddAlias("s7",    "x[23]")
        CPU.configAddAlias("s8",    "x[24]")
        CPU.configAddAlias("s9",    "x[25]")
        CPU.configAddAlias("s10",   "x[26]")
        CPU.configAddAlias("s11",   "x[27]")
        CPU.configAddAlias("t3",    "x[28]")
        CPU.configAddAlias("t4",    "x[29]")
        CPU.configAddAlias("t5",    "x[30]")
        CPU.configAddAlias("t6",    "x[31]")

        CPU.configConfigRegister('_upper', 0, bitLength=32,     note="upper immediate")         

        CPU.configConfigRegister('x',  0, alias=["zero"],       note="Zero")                    #always zero
        CPU.configConfigRegister('x',  1, alias=["r1"],         note="call return address")     #call return address
        CPU.configConfigRegister('x',  2, alias=["sp"],         note="stack pointer")           #stack pointer
        CPU.configConfigRegister('x',  3, alias=["gp"],         note="global pointer")          #global pointer
        CPU.configConfigRegister('x',  4, alias=["tp"],         note="thread pointer")          #thread pointer
        CPU.configConfigRegister('x',  5, alias=["t0"],         note="temp")                    #t0-t6 temporary registers
        CPU.configConfigRegister('x',  6, alias=["t1"],         note="temp")
        CPU.configConfigRegister('x',  7, alias=["t2"],         note="temp")
        CPU.configConfigRegister('x',  8, alias=["s0", "fp"],   note="saved")                   #s0-s11 saved registers, note the two different mappings for x[08] = fp = s0
        CPU.configConfigRegister('x',  9, alias=["s1"],         note="saved")
        CPU.configConfigRegister('x', 10, alias=["a0"],         note="function args")           #a0-a7 function arguments
        CPU.configConfigRegister('x', 11, alias=["a1"],         note="function args")
        CPU.configConfigRegister('x', 12, alias=["a2"],         note="function args")
        CPU.configConfigRegister('x', 13, alias=["a3"],         note="function args")
        CPU.configConfigRegister('x', 14, alias=["a4"],         note="function args")
        CPU.configConfigRegister('x', 15, alias=["a5"],         note="function args")
        CPU.configConfigRegister('x', 16, alias=["a6"],         note="function args")
        CPU.configConfigRegister('x', 17, alias=["a7"],         note="function args")
        CPU.configConfigRegister('x', 18, alias=["s2"],         note="saved")
        CPU.configConfigRegister('x', 19, alias=["s3"],         note="saved")
        CPU.configConfigRegister('x', 20, alias=["s4"],         note="saved")
        CPU.configConfigRegister('x', 21, alias=["s5"],         note="saved")
        CPU.configConfigRegister('x', 22, alias=["s6"],         note="saved")
        CPU.configConfigRegister('x', 23, alias=["s7"],         note="saved")
        CPU.configConfigRegister('x', 24, alias=["s8"],         note="saved")
        CPU.configConfigRegister('x', 25, alias=["s9"],         note="saved")
        CPU.configConfigRegister('x', 26, alias=["s10"],        note="saved")
        CPU.configConfigRegister('x', 27, alias=["s11"],        note="saved")
        CPU.configConfigRegister('x', 28, alias=["t3"],         note="temp")
        CPU.configConfigRegister('x', 29, alias=["t4"],         note="temp")
        CPU.configConfigRegister('x', 30, alias=["t5"],         note="temp")
        CPU.configConfigRegister('x', 31, alias=["t6"],         note="temp")

        CPU.inject('x', 2, memorySize)  #sets stackpointer to end of memory range, Reference: https://book.rvemu.app/hardware-components/01-cpu.html#registers
        #CPU.configConfigRegister('status', 'cycle', 0)
        #CPU.configConfigRegister('status', 'time', 0)
        
        CPU.configSetPostCycleFunction(self.postCycle)
        CPU.configSetInstructionSet(self.RiscVISA())
        CPU.configSetParser(self.RiscVParser())

        CPU.configSetDisplay(CPU.DisplaySimpleAndClean())

        self.CPU = CPU

    def postCycle(self, currentState : dict) -> tuple[dict, dict]:
        """Takes in the currentState dict, returns a tuple containing the oldState dict, and the newState dict

        resets CPU Flags to zero (if there are CPU Flags)
        resets x0 to zero
        """
        assert type(currentState) is dict

        oldState = copy.deepcopy(currentState)
        newState = copy.deepcopy(currentState)
        
        oldState["x"][0] = 0 #resets x0 to zero

        if 'flag' in oldState.keys():
            for i in newState['flag'].keys():
                newState['flag'][i] = 0
        newState['imm'] = {}

        return (oldState, newState)

    class RiscVISA(CPUsim.InstructionSetDefault):
        def __init__(self):
            self.instructionSet : dict = {
                #arithmetic (add, add immidiate, subtract, load upper immediate, add upper immediate to PC)
                "add"   : self.opAdd,
                "addi"  : (lambda z1, z2, z3, z4,   des, a, imm     : self.opAdd(z1, z2, z3, z4,        des, a, self.enforceImm(imm))),
                #"sub"   : None,
                #"lui"   : None,       #TODO load upper immediate needs to be implimented via instruction composition in series. IE: mergeImm(lastState, immRegister) -> adds '_upperImmediate' with 'immRegister', THEN is does the operation 'addi'
                #"auipc" : None,

                #logical
                "xor"   : self.opXOR, 
                "xori"  : (lambda z1, z2, z3, z4,   des, a, imm     : self.opXOR(z1, z2, z3, z4,        des, a, self.enforceImm(imm))),
                "or"    : self.opOR,
                "ori"   : (lambda z1, z2, z3, z4,   des, a, imm     : self.opOR(z1, z2, z3, z4,         des, a, self.enforceImm(imm))),
                "and"   : self.opAND,
                "andi"  : (lambda z1, z2, z3, z4,   des, a, imm     : self.opAND(z1, z2, z3, z4,        des, a, self.enforceImm(imm))),

                #branch (equal, not equal, less than, greater or equal, less then unsigned, greater or equal unsigned)
                "beq"   : (lambda z1, z2, z3, z4,   a, b, pointer   : self.opJump(z1, z2, z3, z4,       "==", pointer, a, b)), 
                "bne"   : (lambda z1, z2, z3, z4,   a, b, pointer   : self.opJump(z1, z2, z3, z4,       "!=", pointer, a, b)), 
                #"blt"   : None, #opJump doesn't handle signed compairisons
                #"bge"   : None, #opJump doesn't handle signed compairisons
                "bltu"  : (lambda z1, z2, z3, z4,   a, b, pointer   : self.opJump(z1, z2, z3, z4,       "<", pointer, a, b)), 
                "bgeu"  : (lambda z1, z2, z3, z4,   a, b, pointer   : self.opJump(z1, z2, z3, z4,       ">=", pointer, a, b)), 

                #shifts (shift left, shilf left immediate, shift right, shift right immediate, shift right arithmetic, shift right arithmetic immediate)
                "sll"   : self.opShiftL,
                "slli"  : (lambda z1, z2, z3, z4,   des, a, imm     : self.opShiftL(z1, z2, z3, z4,     des, a, self.enforceImm(imm))),
                "srl"   : self.opShiftR,
                "srli"  : (lambda z1, z2, z3, z4,   des, a, imm     : self.opShiftR(z1, z2, z3, z4,     des, a, self.enforceImm(imm))),
                "sra"   : (lambda z1, z2, z3, z4,   des, a, n       : self.opShiftR(z1, z2, z3, z4,     des, a, n, True)),
                "srai"  : (lambda z1, z2, z3, z4,   des, a, imm     : self.opShiftR(z1, z2, z3, z4,     des, a, self.enforceImm(imm), True)),

                #compare (set less than, set less than immediate, set less that unsigned, set less that immediate unsigned)
                #"slt"   : None, #signed compairsons for opSetLessThen is not implimented
                #"slti"  : None, #signed compairsons for opSetLessThen is not implimented
                "sltu"  : (lambda z1, z2, z3, z4,   des, a, b       : self.opSetLessThan(z1, z2, z3, z4,     des, a, b, False)),
                "sltiu" : (lambda z1, z2, z3, z4,   des, a, imm     : self.opSetLessThan(z1, z2, z3, z4,     des, a, self.enforceImm(imm), False)),

                #jump and link
                #"jal"   : None,
                #"jalr"  : None,

                #load
                #"lb"    : None,
                #"lh"    : None,
                #"lw"    : None,
                #"lbu"   : None,
                #"lhu"   : None,

                #store
                #"sb"    : None,
                #"sh"    : None,
                #"sw"    : None

                #hotwired system call because I haven't figured out how to impliment system calls yet
                "halt"  : self.opHalt
            }

            '''instructions missing according to riscv-spec-20191213.pdf -> page 90 (108 of 238) -> RV32I Base Integer Instruction Set
            #Store, these instructions show up in https://metalcode.eu/2019-12-06-rv32i.html, but not in riscv-spec-20191213.pdf
            "sbu"   - Store byte unsigned
            "shu"   - Store half unsigned

            #fence      #Deals with out-of-order execution
            "fence"
            "fence.i"

            "ecall"
            "ebreak"
            "csrrw"
            "csrrs"
            "csrrc"
            "csrrwi"
            "csrrsi"
            "csrrci"
            '''

            #for energy and latency, 1 is normalized to 1-ish logic gates-ish
            #length is unused, but is for the assembler to compute how much memory each instruction takes, 1 is 1 byte (don't know all the edge cases that could break a simple assignment like this)
            self.stats : dict = {
                #arithmetic (add, add immidiate, subtract, load upper immediate, add upper immediate to PC)
                "add"   : {"energy"         : 5 * 32,   "latency"       : 3 * 32,   "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "addi"  : {"energy"         : 5 * 32,   "latency"       : 3 * 32,   "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "sub"   : {"energy"         : 5 * 32,   "latency"       : 3 * 32,   "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"}, #a guess for energy and latency
                "lui"   : None,
                "auipc" : None,

                #logical
                "xor"   : {"energy"         : 32,       "latency"       : 1,        "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "xori"  : {"energy"         : 32,       "latency"       : 1,        "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "or"    : {"energy"         : 32,       "latency"       : 1,        "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "ori"   : {"energy"         : 32,       "latency"       : 1,        "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "and"   : {"energy"         : 32,       "latency"       : 1,        "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},
                "andi"  : {"energy"         : 32,       "latency"       : 1,        "cycles"        : 1,        "length"        : 4,    "executionUnit" : "int"},

                #branch (equal, not equal, less than, greater or equal, less then unsigned, greater or equal unsigned)
                "beq"   : None,
                "bne"   : None,
                "blt"   : None,
                "bge"   : None,
                "bltu"  : None,
                "bgeu"  : None,

                #shifts (shift left, shilf left immediate, shift right, shift right immediate, shift right arithmetic, shift right arithmetic immediate)
                "sll"   : None,
                "slli"  : None,
                "srl"   : None,
                "srli"  : None,
                "sra"   : None,
                "srai"  : None,

                #compare (set less than, set less than immediate, set less that unsigned, set less that immediate unsigned)
                "slt"   : None,
                "slti"  : None,
                "sltu"  : None,
                "sltiu" : None,

                #jump and link
                "jal"   : None,
                "jalr"  : None,

                #load
                "lb"    : None,
                "lh"    : None,
                "lw"    : None,
                "lbu"   : None,
                "lhu"   : None,

                #store
                "sb"    : None,
                "sh"    : None,
                "sw"    : None
            }

            self.directives : dict = {}

        def opSetLessThan(self, oldState, newState, config, engine, destination, a, b, signed = False):
            assert type(destination) is tuple and len(destination) == 2 
            assert type(destination[0]) is str and (type(destination[0]) is int or type(destination[0]) is str) 
            assert type(a) is tuple and len(a) == 2 
            assert type(a[0]) is str and (type(a[0]) is int or type(a[0]) is str) 
            assert type(b) is tuple and len(b) == 2 
            assert type(b[0]) is str and (type(b[0]) is int or type(b[0]) is str) 

            a1, a2 = a
            b1, b2 = b
            des1, des2 = destination

            if oldState[a1][a2] < oldState[b1][b2]:
                newState[des1][des2] = 1
            else:
                newState[des1][des2] = 1
        
            newState['pc'][0] = oldState['pc'][0] + 1

    class RiscVParser(CPUsim.ParseDefault):

        def parseCode(self, sourceCode : str) -> tuple["Node", dict[str, "Node"]]:
            """Takes a string of code, returns a parsed instruction tree
            
            Takes source code of the form:
                # Multiplies two number together using shift and add
                # Inputs: a0 (x10), a2 (x12)
                # Outputs: a3 (x13)
                # [register mappping from other program]: r0 => a0 (x10), r1 => a1 (x11), t0 => a2 (x12), t1 => a3 (x13)
                loop:   beq     a0, 0, end          #note: the destination pointer is the third argument, where in the previous example it was the first argument
                        andi    a1, a0, 1
                        bne     a1, 1, temp
                        add     a3, a2, a3
                temp:   slli    a2, a2, 1           #can't use zero as a label, it's a register (x0)
                        srli    a0, a0, 1
                        beq     zero, zero, loop    #a psudoinstruction for an unconditional jump
                end:    halt                        #this is a jurry-rigged instruction for 'halt' because I haven't figured out how to implement system calls yet
            Returns:
                None                                        :Root           1       lineNum=None    charNum=None
                    None                                    :Line           2       lineNum=5       charNum=31
                        'beq'                               :Namespace      3       lineNum=5       charNum=31
                            None                            :Argument       4       lineNum=5       charNum=38
                                'x'                         :Namespace      5       lineNum=5       charNum=38
                                    '['                     :Container      6       lineNum=5       charNum=38
                                        10                  :Int            7       lineNum=5       charNum=38
                            None                            :Argument       4       lineNum=5       charNum=41
                                0                           :Int            5       lineNum=5       charNum=41
                            None                            :Argument       4       lineNum=5       charNum=46
                                'end'                       :Token          5       lineNum=5       charNum=46
                    None                                    :Line           2       lineNum=6       charNum=32
                        'andi'                              :Namespace      3       lineNum=6       charNum=32
                            None                            :Argument       4       lineNum=6       charNum=38
                                'x'                         :Namespace      5       lineNum=6       charNum=38
                                    '['                     :Container      6       lineNum=6       charNum=38
                                        11                  :Int            7       lineNum=6       charNum=38
                            None                            :Argument       4       lineNum=6       charNum=42
                                'x'                         :Namespace      5       lineNum=6       charNum=42
                                    '['                     :Container      6       lineNum=6       charNum=42
                                        10                  :Int            7       lineNum=6       charNum=42
                            None                            :Argument       4       lineNum=6       charNum=45
                                1                           :Int            5       lineNum=6       charNum=45
                    None                                    :Line           2       lineNum=7       charNum=31
                        'bne'                               :Namespace      3       lineNum=7       charNum=31
                            None                            :Argument       4       lineNum=7       charNum=38
                                'x'                         :Namespace      5       lineNum=7       charNum=38
                                    '['                     :Container      6       lineNum=7       charNum=38
                                        11                  :Int            7       lineNum=7       charNum=38
                            None                            :Argument       4       lineNum=7       charNum=41
                                1                           :Int            5       lineNum=7       charNum=41
                            None                            :Argument       4       lineNum=7       charNum=47
                                'temp'                      :Token          5       lineNum=7       charNum=47
                    None                                    :Line           2       lineNum=8       charNum=31
                        'add'                               :Namespace      3       lineNum=8       charNum=31
                            None                            :Argument       4       lineNum=8       charNum=38
                                'x'                         :Namespace      5       lineNum=8       charNum=38
                                    '['                     :Container      6       lineNum=8       charNum=38
                                        13                  :Int            7       lineNum=8       charNum=38
                            None                            :Argument       4       lineNum=8       charNum=42
                                'x'                         :Namespace      5       lineNum=8       charNum=42
                                    '['                     :Container      6       lineNum=8       charNum=42
                                        12                  :Int            7       lineNum=8       charNum=42
                            None                            :Argument       4       lineNum=8       charNum=46
                                'x'                         :Namespace      5       lineNum=8       charNum=46
                                    '['                     :Container      6       lineNum=8       charNum=46
                                        13                  :Int            7       lineNum=8       charNum=46
                    None                                    :Line           2       lineNum=9       charNum=32
                        'slli'                              :Namespace      3       lineNum=9       charNum=32
                            None                            :Argument       4       lineNum=9       charNum=38
                                'x'                         :Namespace      5       lineNum=9       charNum=38
                                    '['                     :Container      6       lineNum=9       charNum=38
                                        12                  :Int            7       lineNum=9       charNum=38
                            None                            :Argument       4       lineNum=9       charNum=42
                                'x'                         :Namespace      5       lineNum=9       charNum=42
                                    '['                     :Container      6       lineNum=9       charNum=42
                                        12                  :Int            7       lineNum=9       charNum=42
                            None                            :Argument       4       lineNum=9       charNum=45
                                1                           :Int            5       lineNum=9       charNum=45
                    None                                    :Line           2       lineNum=10      charNum=32
                        'srli'                              :Namespace      3       lineNum=10      charNum=32
                            None                            :Argument       4       lineNum=10      charNum=38
                                'x'                         :Namespace      5       lineNum=10      charNum=38
                                    '['                     :Container      6       lineNum=10      charNum=38
                                        10                  :Int            7       lineNum=10      charNum=38
                            None                            :Argument       4       lineNum=10      charNum=42
                                'x'                         :Namespace      5       lineNum=10      charNum=42
                                    '['                     :Container      6       lineNum=10      charNum=42
                                        10                  :Int            7       lineNum=10      charNum=42
                            None                            :Argument       4       lineNum=10      charNum=45
                                1                           :Int            5       lineNum=10      charNum=45
                    None                                    :Line           2       lineNum=11      charNum=31
                        'beq'                               :Namespace      3       lineNum=11      charNum=31
                            None                            :Argument       4       lineNum=11      charNum=40
                                'x'                         :Namespace      5       lineNum=11      charNum=40
                                    '['                     :Container      6       lineNum=11      charNum=40
                                        0                   :Int            7       lineNum=11      charNum=40
                            None                            :Argument       4       lineNum=11      charNum=46
                                'x'                         :Namespace      5       lineNum=11      charNum=46
                                    '['                     :Container      6       lineNum=11      charNum=46
                                        0                   :Int            7       lineNum=11      charNum=46
                            None                            :Argument       4       lineNum=11      charNum=52
                                'loop'                      :Token          5       lineNum=11      charNum=52
                    None                                    :Line           2       lineNum=12      charNum=32
                        'halt'                              :Namespace      3       lineNum=12      charNum=32
            """
            assert type(sourceCode) is str
            
            #tokenizes sourceCode, and turns it into a Node Tree
            root : self.Node = self.Node("root")
            for i in self._tokenize(sourceCode):
                root.append(self.Node("token", i[0], i[1], i[2]))

            logging.debug(debugHelper(inspect.currentframe()) + "this is the original code: " + "\n" + repr(sourceCode))
            logging.debug(debugHelper(inspect.currentframe()) + "tokenized code: " + "\n" + str(root))

            #Note: at this point, rules do operations on the Node Tree, but the depth of the Node Tree remains 2

            root = self.ruleFilterLineComments(root, "#")
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFilterLineComments: " + "\n" + str(root))

            root = self.ruleStringSimple(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleStringSimple: " + "\n" + str(root))

            root = self.ruleApplyAlias(root, self.alias)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleApplyAlias: " + "\n" + str(root))

            root = self.ruleLowerCase(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleLowerCase: " + "\n" + str(root))            

            root = self.ruleRemoveLeadingWhitespace(root, [" ", "\t"])
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveLeadingWhitespace: " + "\n" + str(root))

            root = self.ruleRemoveEmptyLines(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveEmptyLines: " + "\n" + str(root))

            root, self.labels = self.ruleFindLabels(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFindLabels: " + "\n" + str(root) + "\nlabels: " + str(self.labels))
            i = 0
            while i < len(root.child): #removes the label nodes, as they don't need to be executed
                if root.child[i].type == "label":
                    root.remove(root.child[i])
                else:
                    i += 1
            
            root = self.ruleLabelNamespace(root, self.nameSpace)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleLabelNamespace: " + "\n" + str(root))

            root = self.ruleRemoveToken(root, " ", False)
            root = self.ruleRemoveToken(root, "\t", False)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveToken: " + "\n" + str(root))

            root = self.ruleCastInts(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleCastInts: " + "\n" + str(root))

            root = self.ruleCastHex(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleCastHex: " + "\n" + str(root))

            #This is where the Node Tree is allowed to go to depth > 2
            root = self.ruleContainer(root, {"(":")", "[":"]"})
            logging.debug(debugHelper(inspect.currentframe()) + "ruleContainer: " + "\n" + str(root))

            root = self.ruleNestContainersIntoInstructions(root, self.nameSpace, True)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleNestContainersIntoInstructions: " + "\n" + str(root))

            temp : list[self.Node] = self.ruleSplitLines(root, "line", "\n")
            root = self.Node("root")
            for i in temp:
                root.append(i)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleSplitLines: " + "\n" + str(root))

            #removes empty lines/empty line nodes
            i = 0
            while i < len(root.child):
                if len(root.child[i].child) == 0:
                    root.remove(root.child[i])
                else:
                    i += 1
            logging.debug(debugHelper(inspect.currentframe()) + "remove empty line nodes: " + "\n" + str(root))

            temp = root.copyInfo()
            for i in root.child:
                temp.append(self.ruleContainerTokensFollowingInstruction(i, self.nameSpace))
            root = temp                            
            logging.debug(debugHelper(inspect.currentframe()) + "ruleContainerTokensFollowingInstruction: " + "\n" + str(root))

            root = self.ruleSplitTokens(root, "argument", ',', True)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleSplitTokens: " + "\n" + str(root))

            return root, self.labels

        def ruleContainerTokensFollowingInstruction(self, tree : "Node", nameSpace : dict[str, Any]) -> "Node":
            """Takes in a Node Tree of arbitrary depth, and a nameSpace dictionary. Returns a Node Tree of arbitrary depth.
            If an instruction token is found, all following tokens are made children of the instruction token.

            Case 0: nameSpace = {'add' : Any}
            Node
                'test'
                'add'       |
                '1'         |
                '2'         |
                '3'         |
            =>
            Node
                'test'
                'add'       |   #all the following tokens were appended to 'add'
                    '1'     |
                    '2'     |
                    '3'     |

            Case 1: nameSpace = {'add' : Any}
            Node
                'add'       |
                '\n'        |
                '1'         |
                '2'         |
                '3'         |
            =>
            Node
                'add'       |
                    '\n'    |   #note: newline is not respected
                    '1'     |
                    '2'     |
                    '3'     |
            """
            assert type(tree) is self.Node
            assert type(nameSpace) is dict

            root : self.Node = tree.copyInfo()
            instruction : self.Node = None

            for i in tree.child:
                if i.token in nameSpace and instruction is None:
                    instruction = i.copyDeep()
                elif not (instruction is None):
                    instruction.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            if not(instruction is None):
                root.append(instruction)

            return root

class TestDefault(unittest.TestCase):
    def testDefaultInitialization(self):
        """Tests Default initialization by reading/writing to registers and memory. Attempt initialization with multiple bitLengths"""
        bitLength : int
        for bitLength in [4, 8, 16, 32, 64, 128]:
            with self.subTest(i = bitLength):
                CPU = CPUsim(bitLength)
                CPU.configSetDisplay(CPU.DisplaySilent())

                r : list[int] = [random.randint(0, 2**bitLength -1) for _ in range(8)]
                for i, value in enumerate(r):
                    CPU.inject('r', i, value)
                    t1 : int = CPU.extract('r', i)
                    self.assertEqual(value, t1, "testing registers")
                m = [random.randint(0, 2**bitLength -1) for _ in range(32)]
                for i, value in enumerate(m):
                    CPU.inject('m', i, value)
                    t1 : int = CPU.extract('m', i)
                    self.assertEqual(value, t1, "testing memory")

    #TODO test running an instruction

    def testVLIW_oneInstructionType(self):
        """Tests for VLIW (Very long instruction word) support, with one instruction type per line"""
        program : str = "add(r[4], r[0], r[1]), add(r[5], r[2], r[3]) \n halt"

        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                CPU = CPUsim(bitLength, defaultSetup = False)
                CPU.configSetDisplay(CPU.DisplaySilent())

                CPU.configAddRegister('r', bitLength, 8)
                CPU.configAddRegister('m', bitLength, 8, show=False)

                CPU.linkAndLoad(program)

                a : list[int] = [random.randint(0, 2**(bitLength - 1) - 1) for _ in range(4)] #generates numbers that are half the max storable size of a register with the given bitLength

                for i, j in enumerate(a):
                    CPU.inject('r', i, j)
                
                CPU.run()
                
                self.assertEqual(
                    a[0] + a[1],
                    CPU.extract('r', 4),
                    ("input = " + str(a)).ljust(32) + ("Expected = " + str(a[0] + a[1])).ljust(16) + ("Got = " + str(CPU.extract('r', 4)))
                )
                self.assertEqual(
                    a[2] + a[3],
                    CPU.extract('r', 5),
                    ("input = " + str(a)).ljust(32) + ("Expected = " + str(a[2] + a[3])).ljust(16) + ("Got = " + str(CPU.extract('r', 5)))
                )
    
    def testVLIW_multipleInstructionType(self):
        """Tests for VLIW (Very long instruction word) support, with multiple instruction types per line"""
        program : str = "add(r[4], r[0], r[1]), and(r[5], r[0], r[1]), or(r[6], r[0], r[1]), xor(r[7], r[0], r[1]) \n halt"

        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                CPU = CPUsim(bitLength, defaultSetup = False)
                CPU.configSetDisplay(CPU.DisplaySilent())

                CPU.configAddRegister('r', bitLength, 8)
                CPU.configAddRegister('m', bitLength, 8, show=False)

                CPU.linkAndLoad(program)

                a : list[int] = [random.randint(0, 2**(bitLength - 1) - 1) for _ in range(2)] #generates numbers that are half the max storable size of a register with the given bitLength

                for i, j in enumerate(a):
                    CPU.inject('r', i, j)
                
                CPU.run()
                
                self.assertEqual(
                    a[0] + a[1],
                    CPU.extract('r', 4),
                    ("input = " + str(a)).ljust(32) + ("Expected = " + str(a[0] + a[1])).ljust(16) + ("Got = " + str(CPU.extract('r', 4)))
                )
                self.assertEqual(
                    a[0] & a[1],
                    CPU.extract('r', 5),
                    ("input = " + str(a)).ljust(32) + ("Expected = " + str(a[0] & a[1])).ljust(16) + ("Got = " + str(CPU.extract('r', 5)))
                )
                self.assertEqual(
                    a[0] | a[1],
                    CPU.extract('r', 6),
                    ("input = " + str(a)).ljust(32) + ("Expected = " + str(a[0] | a[1])).ljust(16) + ("Got = " + str(CPU.extract('r', 6)))
                )
                self.assertEqual(
                    a[0] ^ a[1],
                    CPU.extract('r', 7),
                    ("input = " + str(a)).ljust(32) + ("Expected = " + str(a[0] ^ a[1])).ljust(16) + ("Got = " + str(CPU.extract('r', 7)))
                )
    
class TestDefaultInstructionSet(unittest.TestCase):
    def test_int2bits_bits2int(self):
        """Tests int2bits and bits2 int against ALL NUMBERS POSSIBLE for a bitLength"""
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                for i in range(2**bitLength):
                    with self.subTest(i = i):
                        bitArray : list[int] = CPUsim.InstructionSetDefault.int2bits(None, i, bitLength) #since InstructionSetDefault is not initalized, have to pass in 'None' for 'self'
                        result : int = CPUsim.InstructionSetDefault.bits2int(None, bitArray)

                        self.assertEqual(
                            i, 
                            result, 
                            ("bitLength = " + str(bitLength)).ljust(16) + "Positive Numbers".ljust(32) + "int -> int2bits -> bits2int -> int"
                        )

    def test_int2bits_bits2int_negativeNumbers(self):
        """Tests int2bits and bits2 int against ALL NUMBERS POSSIBLE for a bitLength"""
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                for i in range(0, 0 - (2**bitLength // 2), -1):
                    with self.subTest(i = i):
                        bitArray : list[int] = CPUsim.InstructionSetDefault.int2bits(None, i, bitLength) #since InstructionSetDefault is not initalized, have to pass in 'None' for 'self'
                        result : int = CPUsim.InstructionSetDefault.bits2int(None, bitArray)

                        self.assertEqual(
                            (2**bitLength + i) % 2**bitLength, 
                            result, 
                            ("bitLength = " + str(bitLength)).ljust(16) + "Negative Numbers".ljust(32) + "int -> int2bits -> bits2int -> int"
                        )

    def _testInstructionHelper(self, a : int, b : int, bitLength : int = 8, program : str = "halt") -> int:
        """Helper function that creates an instance of CPUsim to run a given program, returns result integer
        
        a, b are loaded into registers r[0], r[1], the result is loaded from register r[2]
        meant to run simple two line programs to test individual instructions in the default instruction set
        """
        assert type(a) is int
        assert a >= 0
        assert type(b) is int
        assert b >= 0
        assert type(bitLength) is int
        assert bitLength > 0
        assert type(program) is str
        assert len(program) > 0

        CPU = CPUsim(bitLength, defaultSetup = False)
        CPU.configSetDisplay(CPU.DisplaySilent())

        CPU.configAddRegister('r', bitLength, 3)
        CPU.configAddRegister('m', bitLength, 64, show=False)

        CPU.linkAndLoad(program)

        CPU.inject('r', 0, a)
        CPU.inject('r', 1, b)
        CPU.run()
        result : int = CPU.extract('r', 2)

        return result
    
    def testInstruction_add(self):
        """Test DefaultInstructionSet operation opAdd"""
        program : str = "add(r[2], r[0], r[1]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]
                bList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            (a+b) % 2**bitLength, 
                            z,
                            "add".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_multiply(self):
        """Test DefaultInstructionSet operation opMultiply"""
        program : str = "mult(r[2], r[0], r[1]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**(bitLength//2) - 1) for _ in range(8)]
                bList : list[int] = [random.randint(0, 2**(bitLength//2) - 1) for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            (a*b) % 2**bitLength, 
                            z,
                            "multiply".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_twosCompliment(self):
        """Test DefaultInstructionSet operation opTwosCompliment"""
        bitLength : int
        program : str = "twos(r[2], r[0]) \n halt"
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**(bitLength//2) - 1) for _ in range(8)]
                bList : list[int] = [0 for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        #this is a similar algorithm used in opTwosCompliment, so... a little redundent
                        t1 = a & ((2**bitLength) - 1)
                        t1 = [t1 >> i & 1 for i in range(bitLength)] #index 0 is least significant bit
                        t1 = [not i for i in t1]
                        t1 = sum([bit << i for i, bit in enumerate(t1)])
                        t1 = t1 + 1
                        t1 = t1 & (2**bitLength - 1)

                        self.assertEqual(
                            t1, 
                            z,
                            "twosCompliment".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )

    def testInstruction_and(self):
        """Test DefaultInstructionSet operation opAnd"""
        program : str = "and(r[2], r[0], r[1]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]
                bList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            a & b, 
                            z,
                            "and".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_or(self):
        """Test DefaultInstructionSet operation opOr"""
        program : str = "or(r[2], r[0], r[1]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]
                bList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            a | b, 
                            z,
                            "or".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_xor(self):
        """Test DefaultInstructionSet operation opXor"""
        program : str = "xor(r[2], r[0], r[1]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]
                bList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            a ^ b, 
                            z,
                            "xor".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_not(self):
        """Test DefaultInstructionSet operation opNot"""
        program : str = "not(r[2], r[0]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**bitLength - 1) for _ in range(8)]
                bList : list[int] = [0 for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            a ^ (2**bitLength-1), 
                            z,
                            "not".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_shiftL1(self):
        """Test DefaultInstructionSet operation opShiftL"""
        program : str = "shiftl(r[2], r[0]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(2**(bitLength//2 - 2) - 1, 2**(bitLength//2) - 1) for _ in range(8)] #picks a random int such that the upper half of the register is not 0
                bList : list[int] = [0 for _ in range(8)]
                
                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            (a << 1) & (2**bitLength - 1), 
                            z,
                            "shiftL".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )
    
    def testInstruction_shiftL2(self):
        """Test DefaultInstructionSet operation opShiftL, multiple successive opShiftL"""
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(2**(bitLength//2 - 2) - 1, 2**(bitLength//2) - 1) for _ in range(8)] #picks a random int such that the upper half of the register is not 0
                bList : list[int] = [0 for _ in range(8)]
                
                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        for shiftAmount in [2 ** i for i in range(4 + 1)]:
                            with self.subTest(shiftAmount=shiftAmount):
                                program : str = "add(r[2], r[0], r[1])\n" + "".join(["shiftl(r[2], r[2])\n" for _ in range(shiftAmount)]) + "halt"

                                z : int = self._testInstructionHelper(a, b, bitLength, program)

                                self.assertEqual(
                                    (a << shiftAmount) & (2**bitLength - 1), 
                                    z,
                                    "shiftL".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("shiftAmount = " + str(shiftAmount)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                                )

    def testInstruction_shiftR1(self):
        """Test DefaultInstructionSet operation opShiftR"""
        program : str = "shiftr(r[2], r[0]) \n halt"
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(0, 2**(bitLength//2) - 1) for _ in range(8)] #picks a random int such that the upper half of the register is not 0
                bList : list[int] = [0 for _ in range(8)]
                
                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        z : int = self._testInstructionHelper(a, b, bitLength, program)

                        self.assertEqual(
                            (a >> 1) & (2**bitLength - 1), 
                            z,
                            "shiftR".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                        )

    def testInstruction_shiftR2(self):
        """Test DefaultInstructionSet operation opShiftL, multiple successive opShiftL"""
        bitLength : int
        for bitLength in [4, 8, 16]:
            with self.subTest(bitLength=bitLength):
                #Inputs
                aList : list[int] = [random.randint(2**(bitLength//2 - 2) - 1, 2**(bitLength//2) - 1) for _ in range(8)] #picks a random int such that the upper half of the register is not 0
                bList : list[int] = [0 for _ in range(8)]
                
                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        for shiftAmount in [2 ** i for i in range(4 + 1)]:
                            with self.subTest(shiftAmount=shiftAmount):
                                program : str = "add(r[2], r[0], r[1])\n" + "".join(["shiftr(r[2], r[2])\n" for _ in range(shiftAmount)]) + "halt"

                                z : int = self._testInstructionHelper(a, b, bitLength, program)

                                self.assertEqual(
                                    (a >> shiftAmount) & (2**bitLength - 1), 
                                    z,
                                    "shiftR".ljust(16) + ("bitLength = " + str(bitLength)).ljust(16) + ("shiftAmount = " + str(shiftAmount)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("z = " + str(z)).ljust(16) + repr(program)
                                )

class TestDefaultSimplePrograms(unittest.TestCase):
    def testDefaultProgram_multiply1(self):
        """Runs a 'multiply' program once"""
        bitLength : int = 16
        a : int = random.randint(0, 2**(bitLength) - 1)
        b : int = random.randint(0, 2**(bitLength) - 1)

        program : str = '''
                            # Multiplies two numbers together
                            # Inputs: r[0], t[0]
                            # Output: t[1]
                            loop:   jumpEQ  (end, r[0], 0)
                                        and     (r[1], r[0], 1)
                                        jumpNE  (zero, r[1], 1)
                                            add     (t[1], t[0], t[1])
                            zero:       shiftL  (t[0], t[0])
                                        shiftR  (r[0], r[0])
                                        jump    (loop)
                            end:    halt
                            '''
        
        CPU = CPUsim(bitLength, defaultSetup=False)
        CPU.configSetDisplay(CPU.DisplaySimpleAndClean(0))

        #configure memory
        CPU.configAddRegister('r', bitLength, 2) #namespace symbol, bitLength, register amount #will overwrite defaults
        CPU.configAddRegister('m', bitLength, 8, show=False) #the program is loaded into here
        CPU.configAddRegister('t', bitLength * 2, 2) #note that the register bitLength is double the input register size

        CPU.linkAndLoad(program)

        #loads arguments into correct registers
        CPU.inject(key='t', index=0, value=a)
        CPU.inject(key='r', index=0, value=b)
        CPU.run()
        result : int = CPU.extract(key='t', index=1)

        self.assertEqual(
            a * b,
            result,
            ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("Expected = " + str(a * b)).ljust(16) + ("Got = " + str(result)).ljust(16)
        )

    def testDefaultProgram_multiply2(self):
        """Runs a 'multiply' program with various bitLengths and inputs"""
        bitLength : int
        for bitLength in [2, 4, 8, 16, 32]:
            with self.subTest(bitLength=bitLength):
                aList : list[int] = [random.randint(0, 2**(bitLength) - 1) for _ in range(8)]
                bList : list[int] = [random.randint(0, 2**(bitLength) - 1) for _ in range(8)]

                for a, b in zip(aList, bList):
                    with self.subTest(a=a, b=b):
                        program : str = '''
                                            # Multiplies two numbers together
                                            # Inputs: r[0], t[0]
                                            # Output: t[1]
                                            loop:   jumpEQ  (end, r[0], 0)
                                                        and     (r[1], r[0], 1)
                                                        jumpNE  (zero, r[1], 1)
                                                            add     (t[1], t[0], t[1])
                                            zero:       shiftL  (t[0], t[0])
                                                        shiftR  (r[0], r[0])
                                                        jump    (loop)
                                            end:    halt
                                            '''
                        
                        CPU = CPUsim(bitLength, defaultSetup=False)
                        CPU.configSetDisplay(CPU.DisplaySilent())

                        #configure memory
                        CPU.configAddRegister('r', bitLength, 2) #namespace symbol, bitLength, register amount #will overwrite defaults
                        CPU.configAddRegister('m', bitLength, 8, show=False) #the program is loaded into here
                        CPU.configAddRegister('t', bitLength * 2, 2) #note that the register bitLength is double the input register size

                        CPU.linkAndLoad(program)

                        #loads arguments into correct registers
                        CPU.inject(key='t', index=0, value=a)
                        CPU.inject(key='r', index=0, value=b)
                        CPU.run()
                        result : int = CPU.extract(key='t', index=1)

                        self.assertEqual(
                            a * b,
                            result,
                            ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("Expected = " + str(a * b)).ljust(16) + ("Got = " + str(result)).ljust(16)
                        )

    def testDefaultProgram_multiply3(self):
        """Runs a 'multiply' program once, in a VLIW format. 
        
        Honestly, just wanted to see if it would run correctly"""
        bitLength : int = 16
        a : int = random.randint(0, 2**(bitLength) - 1)
        b : int = random.randint(0, 2**(bitLength) - 1)

        program : str = '''
                            # Multiplies two numbers together
                            # Inputs: r[0], t[0]
                            # Output: t[1]
                            loop:   jumpEQ  (end, r[0], 0)
                                        and     (r[1], r[0], 1)
                                        jumpNE  (zero, r[1], 1)
                                            add     (t[1], t[0], t[1])
                            zero:       shiftL  (t[0], t[0]), shiftR  (r[0], r[0]), jump    (loop)
                            end:    halt
                            '''
        
        CPU = CPUsim(bitLength, defaultSetup=False)
        CPU.configSetDisplay(CPU.DisplaySimpleAndClean(0))

        #configure memory
        CPU.configAddRegister('r', bitLength, 2) #namespace symbol, bitLength, register amount #will overwrite defaults
        CPU.configAddRegister('m', bitLength, 8, show=False) #the program is loaded into here
        CPU.configAddRegister('t', bitLength * 2, 2) #note that the register bitLength is double the input register size

        CPU.linkAndLoad(program)

        #loads arguments into correct registers
        CPU.inject(key='t', index=0, value=a)
        CPU.inject(key='r', index=0, value=b)
        CPU.run()
        result : int = CPU.extract(key='t', index=1)

        self.assertEqual(
            a * b,
            result,
            ("bitLength = " + str(bitLength)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("Expected = " + str(a * b)).ljust(16) + ("Got = " + str(result)).ljust(16)
        )

class TestRISCV(unittest.TestCase):
    #TODO test initialization

    #TODO test instructions

    def testRISCVProgram_multiply1(self):
        """Runs a 'multiply' program once"""
        a : int = random.randint(0, 2**8 - 1)
        b : int = random.randint(0, 2**8 - 1)

        CPU = RiscV().CPU
        CPU.configSetDisplay(CPU.DisplaySimpleAndClean(0))

        program : str = """
                            # Multiplies two numbers together using shift and add
                            # Inputs: a0 (x10), a2 (x12)
                            # Outputs: a3 (x13)
                            # [register mappping from other program]: r0 => a0 (x10), r1 => a1 (x11), t0 => a2 (x12), t1 => a3 (x13)
                            loop:   beq     a0, 0, end          #note: the destination pointer is the third argument, where in the previous example it was the first argument
                                    andi    a1, a0, 1
                                    bne     a1, 1, temp
                                    add     a3, a2, a3
                            temp:   slli    a2, a2, 1           #can't use zero as a label, it's a register (x0)
                                    srli    a0, a0, 1
                                    beq     zero, zero, loop    #a psudoinstruction for an unconditional jump
                            end:    halt                        #this is a jurry-rigged instruction for 'halt' because I haven't figured out how to implement system calls yet
                            """

        CPU.linkAndLoad(program)

        CPU.inject('x', 10, a)
        CPU.inject('x', 12, b)
        CPU.run()

        result : int = CPU.extract('x', 13)

        self.assertEqual(
            a * b,
            result,
            ("bitLength = " + str(32)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("Expected = " + str(a * b)).ljust(16) + ("Got = " + str(result)).ljust(16)
        )

    def testRISCVProgram_multiply2(self):
        """Runs a 'multiply' program with various inputs"""
        aList : list[int] = [random.randint(0, 2**32 - 1) for _ in range(16)]
        bList : list[int] = [random.randint(0, 2**32 - 1) for _ in range(16)]

        for a, b in zip(aList, bList):
            with self.subTest(a=a, b=b):
                CPU = RiscV().CPU
                CPU.configSetDisplay(CPU.DisplaySimpleAndClean(0))

                program : str = """
                                    # Multiplies two numbers together using shift and add
                                    # Inputs: a0 (x10), a2 (x12)
                                    # Outputs: a3 (x13)
                                    # [register mappping from other program]: r0 => a0 (x10), r1 => a1 (x11), t0 => a2 (x12), t1 => a3 (x13)
                                    loop:   beq     a0, 0, end          #note: the destination pointer is the third argument, where in the previous example it was the first argument
                                            andi    a1, a0, 1
                                            bne     a1, 1, temp
                                            add     a3, a2, a3
                                    temp:   slli    a2, a2, 1           #can't use zero as a label, it's a register (x0)
                                            srli    a0, a0, 1
                                            beq     zero, zero, loop    #a psudoinstruction for an unconditional jump
                                    end:    halt                        #this is a jurry-rigged instruction for 'halt' because I haven't figured out how to implement system calls yet
                                    """

                CPU.linkAndLoad(program)

                CPU.inject('x', 10, a)
                CPU.inject('x', 12, b)
                CPU.run()

                result : int = CPU.extract('x', 13)

                self.assertEqual(
                    (a * b) & (2**32 - 1),
                    result,
                    ("bitLength = " + str(32)).ljust(16) + ("a = " + str(a)).ljust(16) +  ("b = " + str(b)).ljust(16) +  ("Expected = " + str((a * b) & (2**32 - 1))).ljust(16) + ("Got = " + str(result)).ljust(16)
                )

    #TODO multiplication test program, but with multiple runs/parameters

def testProgramMultiply():
    bitLength : int = 16
    a : int = 4
    b : int = 8

    program : str = '''
                        # Multiplies two numbers together
                        # Inputs: r[0], t[0]
                        # Output: t[1]
                        loop:   jumpEQ  (end, r[0], 0)
                                    and     (r[1], r[0], 1)
                                    jumpNE  (zero, r[1], 1)
                                        add     (t[1], t[0], t[1])
                        zero:       shiftL  (t[0], t[0])
                                    shiftR  (r[0], r[0])
                                    jump    (loop)
                        end:    halt
                        '''
    
    CPU = CPUsim(bitLength, defaultSetup=False)
    CPU.configSetDisplay(CPU.DisplaySimpleAndClean(0))

    #configure memory
    CPU.configAddRegister('r', bitLength, 2) #namespace symbol, bitLength, register amount #will overwrite defaults
    CPU.configAddRegister('m', bitLength, 8, show=False) #the program is loaded into here
    CPU.configAddRegister('t', bitLength * 2, 2) #note that the register bitLength is double the input register size

    CPU.linkAndLoad(program)

    #loads arguments into correct registers
    CPU.inject(key='t', index=0, value=a)
    CPU.inject(key='r', index=0, value=b)
    CPU.run()
    result : int = CPU.extract(key='t', index=1)

    print(result)

#====================================================================================================================== Code above this point is mostly legacy code
#====================================================================================================================== 
#====================================================================================================================== Code below this point is version 4, activly being worked on

class ParseNode(ABC): # abstract class used exclusivly for typing, not used in the program. Documentation included for help text, is mirrored FROM NodeParse. Dunder methods are not included.
    """A data class for storing information in a tree like structure. 

    Each Node also has a coupld relational links between children (nodeNext, nodePrevious, nodeParent)
    Note: __eq__() and __ne__() are implimented to make it easier for compairsions with Node.token and other values.
    """
    
    @abstractmethod
    def __init__(self, typeStr : Optional[str | None] = None, token : Optional[Any] = None, lineNum : Optional[int | None] = None, charNum : Optional[int | None] = None):
        pass
    
    @abstractmethod
    def append(self, node : "ParseNode"):
        """Adds a new node object to self as a child (at end of list)"""
        pass
    
    @abstractmethod
    def copyInfo(self) -> "ParseNode":
        """Creates a new node with the properties (but not relational data) of this node. returns the created node. 
        
        IE: returns a copy of the node with type, token, lineNum, charNum. Does not copy links to children, parent, nodeNext, nodePrevious, etc"""
        pass
    
    @abstractmethod
    def copyDeep(self) -> "ParseNode": #name is copyDeep instead of deepCopy to avoid namespace collision with copy.copyDeep()
        """Creates a new node with all properties of current node including recursivly copying all children (but not relational data). Returns a node tree.
        
        Has the side effect of 'resetting' all relational links (parent, nodeNext, nodePrevious)"""
        pass
    
    @abstractmethod
    def replace(self, oldNode : "ParseNode", newNode : "ParseNode"):
        """Takes in an oldNode that is child of self, and replaces it with newNode. Deletes oldNode"""
        pass
    
    @abstractmethod
    def remove(self, node : "ParseNode"):
        """Takes in a node that is a child of self, removes node. raises exception if node is not a child
        
        deletes references to other nodes from Node, recursively removes child nodes of Node using remove()
        This is to make it easier to the python garbage collecter to destroy it, because cyclic references"""
        pass
    
    @abstractmethod
    def dataEqual(self, a : "ParseNode") -> bool:
        """Compairs the data of a different node recursively, returns True if equal, False otherwise"""
        pass
    
    @abstractmethod
    def __eq__(self, other : Any) -> bool:
        """A custom equals comparision. Takes in another object other, and compaires it to self.token. Returns True if equal, False otherwise"""
        pass
    
    @abstractmethod
    def __ne__(self, other : Any) -> bool:
        """A custom not equals comparision. Takes in another object other, and compaires it to self.token. Returns True if not equal, False otherwise"""
        pass

    @abstractmethod
    def dataEqual(self, a : "ParseNode") -> bool:
        """Compairs the data of a different node recursively, returns True if equal, False otherwise"""
        pass

@dataclass
class NameSpaceObject:
    type : Literal["registerAlias", "directive", "psudoInstruction", "instruction", "label", "registerBank"]
    key : Any
    value : Any = None
    replace : Any = None

class ParserAbstract(ABC):
    """Parses strings into an (almost) execution tree.
    ParseDefault.Node is the dataclass for storing tokens in a Node Tree.

    ParseDefault.parseCode("source code") is called which returns a Node Tree representing the "source code"

        ParseDefault.parseCode() calls ParseDefault.tokenize() to do the initial tokenization of the "source code"
        root -> Node
                |- Token "test"
                |- Token " "
                |- Token "123"
                |- ...

        "rule functions" are called to apply various rules to the Node Tree
        all "rule functions" are functional, and return a COPY of Nodes
        Note: most do not recurse
        by combining "rule functions" in different ways in ParseDefault.parseCode(), different syntaxes can be proccessed
        root = self.ruleRemoveToken(root, " ")
        root -> Node
                |- Token "test"
                |- Token "123"
                |- ...
        root = ruleCastInts(root)
        root -> Node
                |- Token "test"
                |- Token 123
                |- ...

        return root
    """

    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def updateNameSpace(self, nameSpace : dict[str, NameSpaceObject]) -> dict[str, NameSpaceObject]:
        """Takes in nameSpace a dictionary whose keys represent the CPU flags, registers, instructions, etc. 
        Returns nameSpace elements contained in this module that are not contained in input nameSpace"""
        pass

    @abstractmethod
    def parseCode(self, sourceCode : str) -> tuple[ParseNode, dict[str, ParseNode]]:
        """Takes a string of source code, returns a parsed instruction tree and a dictionary representing labels/pointers"""
        pass

class DisplayAbstract(ABC):
    #TODO API still in flux

    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod #TODO work in progress
    def runtime(self,
        MMMUStateOld : int, MMMUStateNew : int,
        MMMUGetMemoryKeys : Callable[[int], tuple[int, int, int, int | str, int | str]],
        MMMUGetRegisterConfig : Callable[[int, int, int, int | str, int | str], dict]
        ):
        pass

    @abstractmethod
    def postrun(self):
        pass
    
class InstructionSetAbstract(ABC):
    """An Instructionset implimentation"""

    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def assertEnvironment(self, funcRead : Callable[[int | str, int | str], int]) -> bool:
        """Checks if the memory layout is compatible by attempting to read necissary elements from memory, returns true is compatible"""
        pass

class ParserError(Exception):
    """Raised when an error occurs during parsing"""
    pass

class MMMUAccessError(Exception):
    """Raised when an error occurs during MMMU access"""
    pass

class NodeParse(ParseNode): # Named NodeParse instead of ParseNode to avoid conflicts with the type ParseNode, and NodeParse seems more logical (Parse subset of root Node)
    """A data class for storing information in a tree like structure. 

    Each Node also has a couple relational links between children (nodeNext, nodePrevious, nodeParent)
    Note: __eq__() and __ne__() are implimented to make it easier for compairsions with Node.token and other values.
    """

    def __init__(self, typeStr : Optional[str] = None, token : Optional[Any] = None, lineNum : Optional[int] = None, charNum : Optional[int] = None):
        assert type(typeStr) is str or typeStr == None
        
        assert type(lineNum) is int or lineNum == None
        if type(lineNum) is int:
            assert lineNum >= 0
        assert type(charNum) is int or charNum == None
        if type(charNum) is int:
            assert charNum >= 0

        self.type : str = typeStr
        self.token : Any = token
        self.child : list[ParseNode] = []

        # relational references to other nodes
        self.parent : ParseNode = None
        self.nodePrevious : ParseNode = None
        self.nodeNext : ParseNode = None

        # the line number of the string or character position in a line, will be needed for indentation awareness if it's ever needed
        self.lineNum : int = lineNum 
        self.charNum : int = charNum

    def append(self, node : ParseNode):
        """Adds a new node object to self as a child (at end of list)"""
        
        assert type(node) is self.__class__

        if len(self.child) != 0:
            self.child[-1].nodeNext = node
            node.nodePrevious = self.child[-1]
        if node.parent == None:
            node.parent = self
        self.child.append(node)
    
    def copyInfo(self) -> ParseNode:
        """Creates a new node with the properties (but not relational data) of this node. returns the created node. 
        
        IE: returns a copy of the node with type, token, lineNum, charNum. Does not copy links to children, parent, nodeNext, nodePrevious, etc"""

        return self.__class__(self.type, self.token, self.lineNum, self.charNum) #TODO This feels wrong, but I don't know why it's wrong

    def copyDeep(self) -> ParseNode: # name is copyDeep instead of deepCopy to avoid namespace collision with copy.copyDeep()
        """Creates a new node with all properties of current node including recursivly copying all children (but not relational data). Returns a node tree.
        
        Has the side effect of 'resetting' all relational links (parent, nodeNext, nodePrevious)"""
        
        newNode = self.__class__(self.type, self.token, self.lineNum, self.charNum)

        # logging.debug(debugHelper(inspect.currentframe()) + "attempting to copyDeep node"+ "\n" + str((
        #         self.type,
        #         self.token,
        #         self.lineNum,
        #         self.charNum,
        #         self.child))
        #     )

        i : int
        for i in range(len(self.child)):
            newNode.append(self.child[i].copyDeep())
        return newNode

    def replace(self, oldNode : ParseNode, newNode : ParseNode):
        """Takes in an oldNode that is child of self, and replaces it with newNode. Deletes oldNode"""
        
        assert type(oldNode) is self.__class__
        assert type(newNode) is self.__class__

        index = None
        i : int
        for i in range(len(self.child)):
            if self.child[i] is oldNode:
                index = i
        
        if index == None:
            raise Exception("oldNode not found, can not replace oldNode. oldNode = \n" + str(oldNode))

        removeNode = self.child[index]
        
        # 'rewires' the references of the children nodes
        newNode.parent = self
        if len(self.child) == 1: # case where oldNode is the only child in the list
            # logging.debug(debugHelper(inspect.currentframe()) + "only child detected")
            pass
        elif index == 0: # case where oldNode is first child in the list, but not the only child in the list
             #logging.debug(debugHelper(inspect.currentframe()) + "first child detected")

            newNode.nodeNext = self.child[1]
            self.child[1].nodePrevious = newNode
        elif index == len(self.child) - 1: # case where oldNode is the last child in the list, but not the only child in the list
            # logging.debug(debugHelper(inspect.currentframe()) + "last child detected")

            newNode.nodePrevious = self.child[-1]
            self.child[-1].nodeNext = newNode
        elif 0 < index < len(self.child) -1: # case where oldNode is between two other nodes
            # logging.debug(debugHelper(inspect.currentframe()) + "middle child detected")

            newNode.nodePrevious = self.child[index - 1]
            newNode.nodeNext = self.child[index + 1]

            self.child[index - 1] = newNode
            self.child[index + 1] = newNode

        self.child[index] = newNode

        # deletes oldNode
        removeNode.parent = None
        removeNode.nodeNext = None
        removeNode.nodePrevious = None

        i : int
        for i in range(len(removeNode.child) - 1, -1, -1):
            removeNode.remove(removeNode.child[i])

    def remove(self, node : ParseNode):
        """Takes in a node that is a child of self, removes node. raises exception if node is not a child
        
        deletes references to other nodes from Node, recursively removes child nodes of Node using remove()
        This is to make it easier to the python garbage collecter to destroy it, because cyclic references"""
        
        assert type(node) is self.__class__

        index : int = None
        i : int
        for i in range(len(self.child)):
            if self.child[i] is node:
                index = i

        if index == None:
            raise Exception("node is not found, can not remove. node = \n" + str(node))

        removeNode : self.__class__ = self.child[index]

        # logging.debug(debugHelper(inspect.currentframe()) + "attempting to remove node"+ "\n" + str((
        #         self.type,
        #         self.token,
        #         self.lineNum,
        #         self.charNum,
        #         self.child)))

        # 'rewires' the references of the children nodes to remove removeNode
        if len(self.child) == 1: # case where removeNode is the only child in the list
            # logging.debug(debugHelper(inspect.currentframe()) + "only child detected")
            pass
        elif index == 0: # case where removeNode is first child in the list, but not the only child in the list
            # logging.debug(debugHelper(inspect.currentframe()) + "first child detected")
            if type(removeNode.nodeNext) is self.__class__: #TODO figure out why this is neccissary to avoid a specific error.
                removeNode.nodeNext.nodePrevious = None
        elif index == len(self.child) - 1: #case where removeNode is the last child in the list, but not the only child in the list
            # logging.debug(debugHelper(inspect.currentframe()) + "last child detected")
            if type(removeNode.nodePrevious) is self.__class__:
                removeNode.nodePrevious.nodeNext = None
        elif 0 < index < len(self.child) -1: # case where removeNode is between two other nodes
            # logging.debug(debugHelper(inspect.currentframe()) + "middle child detected")
            if type(removeNode.nodePrevious) is self.__class__:
                removeNode.nodePrevious.nodeNext = removeNode.nodeNext
            if type(removeNode.nodeNext) is self.__class__:
                removeNode.nodeNext.nodePrevious = removeNode.nodePrevious
        
        removeNode.parent = None
        removeNode.nodeNext = None
        removeNode.nodePrevious = None
        
        self.child.pop(index)
        
        i : int
        for i in range(len(removeNode.child) - 1, -1, -1):
            removeNode.remove(removeNode.child[i])

    def dataEqual(self, a : ParseNode) -> bool:
        """Compairs the data of a different node recursively, returns True if equal, False otherwise"""
        
        assert type(a) is self.__class__

        result : bool = True

        if a.token != self.token:
            result = False
        if a.type != self.type:
            result = False
        if a.lineNum != self.lineNum:
            result = False
        if a.charNum != self.charNum:
            result = False

        if len(a.child) != len(self.child):
            result = False
        else:
            i : int
            for i in range(len(self.child)):
                if not self.child[i].dataEqual(a.child[i]):
                    result = False

        return result

    def __repr__(self, depth : int = 1) -> str:
        """Recursivly composes a string representing the node hierarchy, returns a string.
        
        Called by print() to display the object"""
        
        assert type(depth) is int
        assert depth >= 1

        block : str = ""
        line : str = ""
        for _ in range(depth):
            line += "    "
        line += repr(self.token)
        line = line.ljust(64, " ")
        line += ":" + str(self.type).ljust(32)
        line += "" + str(depth).ljust(8)

        line += ("lineNum=" + str(self.lineNum)).ljust(16)
        line += ("charNum=" + str(self.charNum)).ljust(16)

        line += "\n"

        childLines : list[str] = [i.__repr__(depth+1) for i in self.child]
        block += line
        i : str
        for i in childLines:
            block += i

        return block
        
    def __eq__(self, other : Any) -> bool:
        """A custom equals comparision. Takes in another object other, and compaires it to self.token. Returns True if equal, False otherwise"""
        # logging.debug(debugHelper(inspect.currentframe()) + "Custom equals comparison")

        # return self.token == other
        if type(other) is self.__class__:
            return self.token == other.token
        else:
            return self.token == other

    def __ne__(self, other : Any) -> bool:
        """A custom not equals comparision. Takes in another object other, and compaires it to self.token. Returns True if not equal, False otherwise"""
        # logging.debug(debugHelper(inspect.currentframe()) + "Custom equals comparison")

        # return self.token != other
        if type(other) is self.__class__:
            return self.token != other.token
        else:
            return self.token != other

    # No longer needed since remove() cleans up enough recursivly for the python garbage collector to pick it up. This function might be useful for debugging purposes
    def __del__(self):
        """Decontructor, needed because the various inter-node references may make it harder for the python garbage collector to properly delete an entire tree.
        
        will not touch pointers to this node from other nodes. IE: nodeNext's pointer to this node could be set to None, but that could get messy?"""
        
        # logging.debug(debugHelper(inspect.currentframe()) + "Deleting Node" + "\n" + str((
        #         self.type,
        #         self.token,
        #         self.lineNum,
        #         self.charNum))
        #         )
        
        self.parent = None
        self.nodeNext = None
        self.nodePrevious = None

        while len(self.child) != 0:
            self.remove(self.child[0])

class CPUsim_v4:
    """
    API #TODO overview:
        class CPUsim
            def __init__                            #TODO
            def setInstructionSet                   #TODO #Passthrough
            def setParser                           #TODO #Passthrough
            def setDecoder                          #TODO #Passthrough
            def setPostTickMemoryAdjuster           #TODO #Passthrough
            def setMMMU                             #TODO #Passthrough
            class NodeParse
                self.token                          #TODO token should be type 'Any'
            class DisplaySimpleAndClean             #TODO
            class DisplaySilent                     #TODO
            class InstructionSetDefault
                def opCopy                          #NotImplimented
            class MMMU                              #TODO #NotImplimented
            class ParserDefault
                def __init__                        #Eliminate
                    var Node = NodeParse            #TODO should import 'class NodeParse' but name refers to old code with old name
                def updateNameSpace                 #Eliminate
                def update                          #Eliminate
                def ruleFilterBlockComments         #TODO #NotImplimented
                def ruleFindDirectives              #TODO #NotImplimented
                def _tokenizeChar                   #NotImplimented
            class CompilerDefault                   #TODO #NotImplimented
            class DecoderDefault                    #TODO #NotImplimented

    """
    """ Random Design Notes
    Stats:
        [every memory cell] (branchNode, poolEntryPoint, hyperThreadContext, key, index)
            reads
            writes
            energy access
            energy maintiance
            #energy saved from cache hits?
        [every instruction]
            executions
            energy
            energy idle
            time latency
            time idle
        [every execution unit]
            executions
            energy
            energy idle
            time idle

    Energy Estimation:
        1 energy = 1 logic gate =_approx 1 * 10 ^ -12 Joules = 1 picoJoule / Gate
        1 latency = 1 logic gate =_approx 1 * 10 ^ -12 Seconds = 1 picoSecond / Gate
        1 cycle =_approx 1 64-bit add operation register to register =_approx 1000 picoJoules, 1000 picoSeconds = 10 ^ -9 Joules, 10 ^ -9 Seconds = 1 nanoJoule / Operation, 1 nanoSecond / Operation

        Characterizing the Energy Consumption of Data Transfers and Arithmetic Operations on x86-64 Processors [2010-xx-xx], Daniel Molka, Daniel Hackenberg, Robert Schone and Matthias S. Muller

    Ideal Computation Logic Gate running at ideal temperature of 2.73 Kelvin (temperature of the Universe)
        1 bitflip = k * T * ln(2); k = Boltzmann constant @ 1.38 * 10 ^ -23 J/K, T = Temperature in Kelvin
        1 bitflip = (1.38 * 10 ^ -23 J/K) * (2.73 K) * ln(2) = 2.611 * 10 ^ -23 Joules
        1 bitflip = 2.611 * 10 ^ -23 Joules
        https://youtu.be/__YWDi78Mco?t=847
        https://en.wikipedia.org/wiki/Landauer%27s_principle#Equation

        1 quantum orthogonalization ('bitflip') = 1.666 * 10 ^ -34 Joules
        https://en.wikipedia.org/wiki/Margolus%E2%80%93Levitin_theorem
    """

    def __init__(self, setup : Optional[Literal["default", "default+", None]] = "default"):
        """#TODO
        
        """

        assert type(setup) is str or type(setup) is None
        assert setup in ["default", "default+", None]

        self._InstructionSet_Instance : Type[self.InstructionSetDefault] = None
        self._Display_Instance : Type[self.DisplaySilent] = None
        self._Parser_Instance : Type[self.ParserDefault] = None
        self._MMMU_Instance : Type[self.MMMUDefault] = None
        self._Compiler_Instance : Type[self.CompilerDefault] = None
        self._Decoder_Instance : Type[self.DecoderDefault] = None

        self._postTickMemoryAdjuster : Callable[[], None] = None

        self._nameSpace : dict[str, dict[Literal["type", "replace"], Any]] = {}

        self.setDisplay(self.DisplaySimpleAndClean())
        self.setInstructionSet(self.InstructionSetDefault())
        self.setParser(self.ParserDefault())
        self.setDecoder(self.DecoderDefault())
        self.setPostTickMemoryAdjuster(self._postTickMemoryAdjusterDefault)

        MMMU = self.MMMUDefault()
        self.setMMMU(MMMU)

    def setInstructionSet(self, instructionSet_Instance) -> None:
        """Takes in a instatiated instruction set
        
        #TODO pass through, needs proper implimentation
        """

        assert type(instructionSet_Instance) != None
        assert type(instructionSet_Instance.instructionSet) is dict

        self._InstructionSet_Instance = instructionSet_Instance

    def setParser(self, parser_Instance) -> None:
        """Takes in a instatiated parser
        
        #TODO pass through, needs proper implimentation
        """

        assert type(parser_Instance) != None
        assert parser_Instance.parseCode
        assert callable(parser_Instance.parseCode)

        self._Parser_Instance = parser_Instance

    def setDecoder(self, decoder_Instance) -> None:
        """Takes in a instatiated decoder
        
        #TODO pass through, needs proper implimentation
        """

        assert type(decoder_Instance) != None

        self._Decoder_Instance = decoder_Instance

    def setPostTickMemoryAdjuster(self, postTickMemoryAdjust : Callable[[], None]) -> None:
        """
        
        #TODO pass through, needs proper implimentation
        """

        assert callable(postTickMemoryAdjust)

        self._postTickMemoryAdjuster = postTickMemoryAdjust

    def setMMMU(self, MMMU_Instance) -> None:
        """Takes in a instatiated MMMU
        
        #TODO pass through, needs proper implimentation
        """

        assert type(MMMU_Instance) != None

        self._MMMU_Instance = MMMU_Instance

    class DisplaySimpleAndClean:
        #TODO

        def __init__(self):
            self.textRed : str = "\u001b[31m"               # forground red
            self.textYellow : str = "\u001b[33m"            # forground yellow, meant for register pending read/write
            self.textTeal : str = "\u001b[96m"              # forground teal, meant for register activity (read/write)
            self.textGreen : str = "\u001b[92m"             # forground green
            self.textGrey : str = "\u001b[90m"              # forground grey
            self.backDeepBlue : str = "\u001b[48;5;17m"     # background deep blue
            self.ANSIend : str = "\u001b[0m"                # resets ANSI colours

        # def runtime(self, 
        #     readStateOld : Callable[[int, int, int or str, int or str], int], readStateOldStatus : Callable[[int, int, int or str, int or str], dict],
        #     readStateNew : Callable[[int, int, int or str, int or str], int], readStateNewStatus : Callable[[int, int, int or str, int or str], dict],
        #     getRegisterConfig : Callable[[int or str, int or str], dict],
        #     getAllMemoryElements : Callable[[], tuple[int, int, int or str, int or str]]
        #     ):
        #     pass

        def runtime(self,
            MMMUStateOld : int, MMMUStateNew : int,
            MMMUGetMemoryKeys : Callable[[int], tuple[int, int, int, int | str, int | str]],
            MMMUGetRegisterConfig : Callable[[int, int, int, int | str, int | str], dict]
            ):
            pass

        def postrun(self):
            pass

    class DisplaySilent:
        """An intentionally empty definition, that will display nothing to the screen"""

        def __init__(self):
            pass

        def runtime(): #TODO
            """An intentionally empty definition, that will display nothing to the screen"""
            pass

        def postrun(): #TODO
            """An intentionally empty definition, that will display nothing to the screen"""
            pass

    class InstructionSetDefault:
        """A Mockup of the default instruction set for future use
        
        A simplified instruction set implimentation, along with the building blocks for base instructions to help build an instruction set.

        Terminology
            Instruction - Generic term refering to an instruction that is loaded, or an instruction that is implimented in the instructionSet, 
                or a building block function used for the instructionSet milicode
            User Instruction - Refers to the instruction loaded from a program and run on the CPU engine. IE: "add r0 r1 r2"
            ISA Instruction/ISA Instruction Set - Refers to the instruction implimented and accessable from the ISA. IE: "add" is an accessable instruction implimented by the ISA
            Milicode - Refers to the instruction implimentation (defined in __init__) from smaller building block functions (Base Instructions). 
                IE: {"add" : lambda e1, e2, e3, e4, e5, des, a, b: self.opAdd(e1, e2, e3, e4, e5, des, a, b)}"
                Note: multiple functions can be stacked together in the definition, but the engine treats it's execution as a single ISA Instruction execution
            Base Instruction - Refers to the base instruction functions defined in this class used in milicode to impliment ISA Instructions. IE: see "def opAdd" for how addition is implimented
                These functions are writen in a such a way that they are:
                    able to run on registers of arbitrary length
                    have a signiture where first 5 arguments are for the engine, next arguments are for destination and input register key/index pairs (if applicable), then optional arguments which may or may not be register key/index pairs
                    they do not return a value (return None)
                    run/complete in a finite bounded time
                Note: Some Base Instructions are implimented, but not included as part of the ISA Instruction Set.
            
            Microcode - A single User Instruction, that when docoded, actually 'jumps' to a micro program stored in a seperate memory bank

            SysCall - Generic term refering to interaction outside of the user program to an OS which may or may not exist
                #TODO system calls are implimented as a wrapper which calls a engine lookup table for what to do (Halting, jumping to OS to handle halting, execute special function to handle halting).
                    This allows for a simple user program to run without implimenting and running an OS (IE: output gets printed to the screen, without using an OS)
                    Or allows for rerouting a syscall to a device or something else (IE: output gets routed to a device function which THEN buffers and prints it out to the screen, when needed, because it's buffered)

        API: #TODO Update
            class InstructionSetDefault
                def __init__
                    var bitLength
                    var instructionSet
                    var instructionStats
                def assertEnvironment
                def enforceAccess
                def int2bits
                def bits2int
                def opSyscall                               #TODO
                def opNop
                def opAdd
                def opMultiply
                def opTwosCompliment
                def opAND
                def opOR
                def opXOR
                def opNOT
                def opJump
                def opShiftL
                def opShiftR
                def opRotate

        Note: when adding instructions, use opAddCarryOverflow() as a reference for adding a function
        """

        def __init__(self):
            """Initializes instruction set

            bitLength is used to caluculate energy and latency of instructions.
            """

            self.instructionSet :   dict[
                                        tuple[str, ...],                                        # Instruction 'op-code', will automatically (#TODO) get converted to a Tuple on import
                                        tuple[                                                  # Instruction functions will automatically (#TODO) get converted to a list in import
                                            Callable[
                                                [
                                                    Callable[[int | str, int | str], int],      # MMMU read function
                                                    Callable[[int | str, int | str], None],     # MMMU write function
                                                    Callable[[int | str, int | str], dict],     # MMMU get config function
                                                    dict[                                       # Engine Functions
                                                        str,
                                                        Callable[[Any], Any]                                                    
                                                    ],                                   
                                                    dict,                                       # Engine info
                                                    tuple[int | str, int | str],                # Optional Additional register arguments passed to instruction
                                                    Any
                                                ],                                              # Optional Additional register arguments passed to instruction
                                                None
                                            ]
                                        ]
                                    ]
            self.instructionSet = {
                ("nop",)        : (lambda fRead, fWrite, fConfig, EFunc, EStatus,                               : self.opNop(fRead, fWrite, fConfig, EFunc, EStatus)), #full syntax

                ("add",)        : (lambda fRead, fWrite, fConfig, EFunc, EStatus,      des, a, b                : self.opAdd(fRead, fWrite, fConfig, EFunc, EStatus,            des, a, b)), #full syntax
                ("mult",)       : self.opMultiply,
                ("twos",)       : self.opTwosCompliment,
                ("copy",)       : self.opCopyElement,

                ("and",)        : self.opAND,
                ("or",)         : self.opOR,
                ("xor",)        : self.opXOR,
                ("not",)        : self.opNOT,

                ("jumpeq",)     : (lambda fRead, fWrite, fConfig, EFunc, EStatus,       pointer, a, b           : self.opJump(fRead, fWrite, fConfig, EFunc, EStatus,           "==", pointer, a, b)),
                ("jumpne",)     : (lambda fRead, fWrite, fConfig, EFunc, EStatus,       pointer, a, b           : self.opJump(fRead, fWrite, fConfig, EFunc, EStatus,           "!=", pointer, a, b)),
                ("jump",)       : (lambda fRead, fWrite, fConfig, EFunc, EStatus,       pointer                 : self.opJump(fRead, fWrite, fConfig, EFunc, EStatus,           "goto", pointer)),

                ("shiftl",)     : (lambda fRead, fWrite, fConfig, EFunc, EStatus,       des, a                  : self.opShiftL(fRead, fWrite, fConfig, EFunc, EStatus,         des, a, fWrite("imm", 0, 1))), #TODO #Allows adding an immediate value, and returns an immediate key/index pair
                ("shiftr",)     : (lambda fRead, fWrite, fConfig, EFunc, EStatus,       des, a                  : self.opShiftR(fRead, fWrite, fConfig, EFunc, EStatus,         des, a, fWrite("imm", 0, 1), False)), #TODO #Allows adding an immediate value, and returns an immediate key/index pair

                #TODO # This essentially makes a table-lookup to datastructure in another part of the CPU simulator where you can define what happens (IE: a direct function call, or a jump to an OS subroutine)
                ("halt",)       : (lambda fRead, fWrite, fConfig, EFunc, EStatus,                               : self.sysCallSimple(fRead, fWrite, fConfig, EFunc, EStatus,    "halt"))
                #"halt"     : self.microcode(0xFFFF)    #TODO # This explicidly jumps to a predefined subroutine that is outside of the typical memory layout (IE: a special memory section kind of like how IMM registers is handled now)

                #"addTest"  : (lambda fRead, fWrite, fConfig, EFunc, EStatus,       des, a, b               : self.opAdd(fRead, fWrite, fConfig, EFunc, EStatus,        des, ("m", fRead(a)), b))   #Indirect Memory Addressing
            }

            self.instructionEnergy :    dict[
                                            tuple[str, ...],
                                            tuple[
                                                Callable[
                                                    [
                                                        Callable[[int | str, int | str], int],          # MMMU read function
                                                        Callable[[int | str, int | str], None],         # MMMU write function
                                                        Callable[[int | str, int | str], dict],         # MMMU get config function
                                                        tuple[int | str, int | str],                    # Optional Additional register arguments passed to instruction
                                                        Any
                                                    ],
                                                    dict[                                               # Returns energy/latency info to engine for tabulation
                                                        Literal["energy", "latency"],
                                                        int | Decimal
                                                    ]
                                                ]
                                            ]
                                        ]
            self.instructionEnergy = {
                ("nop",)        : (lambda fRead, fWrite, fConfig,                               : {"energy" : 0, "latency" : 0}),

                ("add",)        : self.englatAdd_RippleCarry,
                ("mult",)       : self.englatMultiply_ShiftAdd2,
                ("twos",)       : (lambda fRead, fWrite, fConfig,       des, a                  : { 
                    "energy"    : self.englatAdd_RippleCarry(fRead, fWrite, fConfig, des, a, a)["energy"] + self.englatNOT(fRead, fWrite, fConfig, des, a)["energy"], 
                    "latency"   : self.englatAdd_RippleCarry(fRead, fWrite, fConfig, des, a, a)["latency"] + self.englatNOT(fRead, fWrite, fConfig, des, a)["latency"]
                    }),
                ("copy",)       : self.englatAND,

                ("and",)        : self.englatAND,
                ("or",)         : self.englatAND,
                ("xor",)        : self.englatAND,
                ("not",)        : self.englatNOT,

                ("jumpeq",)     : (lambda fRead, fWrite, fConfig,       pointer, a, b           : self.englatAdd_RippleCarry(fRead, fWrite, fConfig,            a, b)),
                ("jumpne",)     : (lambda fRead, fWrite, fConfig,       pointer, a, b           : self.englatAdd_RippleCarry(fRead, fWrite, fConfig,            a, b)),
                ("jump",)       : (lambda fRead, fWrite, fConfig,       pointer                 : self.englatNOT(fRead, fWrite, fConfig,            pointer, pointer)),

                ("shiftl",)     : self.englatNOT,
                ("shiftr",)     : self.englatNOT,

                ("halt",)       : (lambda fRead, fWrite, fConfig,                               : {"energy" : 0, "latency" : 0})
            }

            """
            #self.instructionStats is optional, and will be automatically (#TODO) filled in when loaded
            #for energy and latency, 1 is normalized to 1-ish logic gates-ish
            #length is unused, but is for the assembler to compute how much memory each instruction takes, 1 is 1 byte (don't know all the edge cases that could break a simple assignment like this)
            self.instructionStats :     dict[
                                            tuple[str, ...],
                                            dict[
                                                Literal["energy", "latency", "cycles", "length", "executionUnit"],
                                                int or str or Literal["none", "alu", "int", "float", "branch", "load", "vector"]
                                            ]
                                        ] = {
                "nop"       : {"energy"         : 0,                "latency"       : 0,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "none"            },

                "add"       : {"energy"         : 5 * bitLength,    "latency"       : 3 * bitLength,    "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },
                "mult"      : {"energy"         : (5*bitLength)**2, "latency"       : (4*bitLength)*2,  "cycles"        : bitLength,        "length"        : 4,                "executionUnit" : "alu"             },
                "twos"      : {"energy"         : 6 * bitLength,    "latency"       : 3 * bitLength,    "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },

                "and"       : {"energy"         : 1 * bitLength,    "latency"       : 1,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },
                "or"        : {"energy"         : 1 * bitLength,    "latency"       : 1,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },
                "xor"       : {"energy"         : 1 * bitLength,    "latency"       : 1,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },
                "not"       : {"energy"         : 1 * bitLength,    "latency"       : 1,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },

                "jumpeq"    : {"energy"         : 0,                "latency"       : 0,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "branch"          },
                "jumpne"    : {"energy"         : 0,                "latency"       : 0,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "branch"          },
                "jump"      : {"energy"         : 0,                "latency"       : 0,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "branch"          },

                "shiftl"    : {"energy"         : 1 * bitLength,    "latency"       : 1,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },
                "shiftr"    : {"energy"         : 1 * bitLength,    "latency"       : 1,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "alu"             },

                "halt"      : {"energy"         : 0,                "latency"       : 0,                "cycles"        : 1,                "length"        : 4,                "executionUnit" : "none"            },
            }
            """

            # self.instructionStats is optional, and will be automatically (#TODO) filled in when loaded
            # for energy and latency, 1 is normalized to 1-ish logic gates-ish
            self.instructionStats :     dict[
                                            tuple[str, ...],
                                            dict[
                                                Literal["cycles", "executionUnit"],
                                                None | str | Literal["none", "alu", "int", "float", "branch", "load", "vector"]
                                            ]
                                        ]
            self.instructionStats = {
                "nop"       : {"cycles"         : 1,                "executionUnit" : None              },

                "add"       : {"cycles"         : 1,                "executionUnit" : "alu"             },
                "mult"      : {"cycles"         : None,             "executionUnit" : "alu"             },
                "twos"      : {"cycles"         : 1,                "executionUnit" : "alu"             },
                "copy"      : {"cycles"         : 1,                "executionUnit" : "alu"             },

                "and"       : {"cycles"         : 1,                "executionUnit" : "alu"             },
                "or"        : {"cycles"         : 1,                "executionUnit" : "alu"             },
                "xor"       : {"cycles"         : 1,                "executionUnit" : "alu"             },
                "not"       : {"cycles"         : 1,                "executionUnit" : "alu"             },

                "jumpeq"    : {"cycles"         : 1,                "executionUnit" : "branch"          },
                "jumpne"    : {"cycles"         : 1,                "executionUnit" : "branch"          },
                "jump"      : {"cycles"         : 1,                "executionUnit" : "branch"          },
                "shiftl"    : {"cycles"         : 1,                "executionUnit" : "alu"             },
                "shiftr"    : {"cycles"         : 1,                "executionUnit" : "alu"             },

                "halt"      : {"cycles"         : 1,                "executionUnit" : None            },
            }

        def isISARegisterVector(self, register : Any) -> bool:
            """returns True if register is a register vector of the correct form, False otherwise
            
            register must be a tuple or list of length 2, with elements being a string or int greater than 2
            """

            if type(register) is not list and type(register) is not tuple:
                return False
            if len(register) != 2:
                return False
            if type(register[0]) is not str and type(register[0]) is not int:
                return False
            if type(register[1]) is not str and type(register[1]) is not int:
                return False
            if type(register[0]) is int:
                if register[0] < 0:
                    return False
            if type(register[1]) is int:
                if register[1] < 0:
                    return False

            return True

        def assertEnvironment(self, funcRead : Callable[[int | str, int | str], int]) -> bool:
            """Checks if the memory layout is compatible by attempting to read necissary elements from memory, returns true is compatible"""

            assert callable(funcRead)

            try:
                funcRead(("r", 0))
                funcRead(("m", 0))
            except:
                logging.info(debugHelper(inspect.currentframe()) + "InstructionSet not compatible with current Memory Layout")
            
        def int2bits(self, number : int, bitLength : int) -> list[Literal[0, 1]]:
            """Takes a bitLength, and a number where ((0 - 2**bitLength) // 2 <= number < 2**bitLength). Returns a bit int array representing the number, zero index is least significant bit
            
            For numbers < 0, twos compliment is applied (python represents negative numbers correctly when appling bitise operations)
            """

            assert type(bitLength) is int
            assert bitLength > 0
            assert type(number) is int
            assert (0 - 2**bitLength) // 2 <= number < 2**bitLength

            number = number & (2**bitLength - 1)
            bitArray : list[Literal[0, 1]] = [number >> i & 1 for i in range(bitLength)] # index 0 is least significant bit

            return bitArray

        def bits2int(self, bitArray : list[Literal[0, 1] or bool]) -> int:
            """Takes in a bit (int or bool) array where zero index is least significant bit. Returns the positive number is represents"""

            assert type(bitArray) is list
            assert len(bitArray) > 0
            assert all([(type(i) is int or type(i) is bool) for i in bitArray])
            assert all([i in [0, 1, False, True] for i in bitArray])

            # This algorithm causes massive memory usage (>50GB) if bitLength is large (== 2**20)
            # return sum([bit << i for i, bit in enumerate(bitArray)])

            # This algorithm uses far less memory then using alternate method
            result : int = 0
            i : int
            bit : int
            for i, bit in enumerate(bitArray):
                result += bit << i

            return result

        def microEnforceAccess(self, register : tuple[int | str, int | str], key : str | int) -> tuple[int | str, int | str]:
            """returns register tuple iff register[0] matches key, raises exception otherwise"""

            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert type(register[0]) is int or type(register[0]) is str 
            assert type(register[1]) is int or type(register[1]) is str
            assert type(key) is int or type(key) is str

            if key != register[0]:
                raise Exception("Instruction not allowed access to specified register: " + str(key))
            return register

        def microSyscall(self,
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], engineFunc : dict[str, Callable[[Any], Any]], engineStatus : dict,
            operation : str):
            """Takes in a string indicating what syscall to call, and passes that call to the engine"""

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)
            assert type(engineFunc) is dict
            assert all([callable(j) for _, j in engineFunc.items()])
            assert type(engineStatus) is dict

            assert type(operation) is str
            assert len(str) != 0

            engineFunc["syscall"](operation)

        def microInjectImmediateValue(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None | tuple[str, int]],

            value : int
        ) -> tuple[str, int]:
            """Takes in a value (positive or negative), and returns an immediate register vector that contains the specified value.
            
            bitLength of created '_imm' will be minimum required to store the value
            for a negative value, absolute of value will be taken, and the leading 1 bit will be removed, the rest is stored
                this allows for the controlling of bitLength
                including the non-sensical case of a zero-bitLength _imm register =S

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_microInjectImmediateValue_valueOne
                value = [1] -> [['_imm', 0] = (value = 0b1, bitLength = 1)]
                ->
                value = 0b1
                registerRead = {
                }
                ->
                microInjectImmadiateValue(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    value                       = 0b1
                )
                -> # input
                value = 0b01
                -> # output
                registerRead = {
                    ('_imm', 0)                 : 0b01
                }
                -> # written
                ['_imm', 0];                    value = 1;          bitLength = 1
                -> # returned
                ['_imm', 0]

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_microInjectImmediateValue_valueZero
                value = [0] -> [['_imm', 0] = (value = 0b0, bitLength = 1)]
                ->
                value = 0b0
                registerRead = {
                }
                ->
                microInjectImmadiateValue(
                    funcRead                    = funcDummyRead
                    funcWrite                   = self.functionNull
                    value                       = 0b0
                )
                -> # input
                value = 0b0
                -> # output
                registerRead = {
                    ('_imm', 0)                 : 0b0
                }
                -> # written
                ['_imm', 0];                    value = 0;          bitLength = 1
                -> # returned
                ['_imm', 0]

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_microInjectImmediateValue_valueNegativeOne
                value = [-1] -> [['_imm', 0] = (value = 0, bitLength = 0)]
                ->
                value = -0b1
                registerRead = {
                }
                ->
                microInjectImmadiateValue(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    value                       = -0b1
                )
                -> # input
                value = -0b1
                -> # output
                registerRead = {
                    ('_imm', 0)                 : 0
                }
                -> # written
                ['_imm', 0];                    value = 0;         bitLength = 0
                -> # returned
                ['_imm', 0]

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_microInjectImmediateValue_largeValue03
                value = [-0x100000000] -> [['_imm', 0] = (value = 0x00000000, bitLength = 32)]
                ->
                value = -0x100000000 = 0x00000000
                registerRead = {
                }
                ->
                microInjectImmadiateValue(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    value                       = -0x100000000
                )
                -> # input
                value = -0x100000000
                -> # output
                registerRead = {
                    ('_imm', 0)                 : 0x00000000
                }
                -> # written
                ['_imm', 0];                    value = 0x00000000;    bitLength = 32
                -> # returned
                ['_imm', 0]
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert type(value) is int

            return funcWrite(("_imm", 0), value)

        def microSelectBits(self,
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None],
            registerA : tuple[str, int | str],
            bitStart : int, bitEnd: int
        ) -> tuple[int | str, int | str]:
            """Takes a register, selects the bits starting at bitStart inclusive and ending at bitEnd inclusive. Takes result, adds it as an immediate register, returns the register address
            
            Note: bit 0 is least significant bit
            """

            assert callable(funcRead)
            assert callable(funcWrite)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str

            assert type(bitStart) is int
            assert bitStart >= 0
            assert type(bitEnd) is int
            assert bitEnd >= 0
            assert bitEnd >= bitStart

            a : int = funcRead(registerA)
            
            a = a >> bitStart
            a = a & (2 ** (bitEnd - bitStart + 1) - 1)

            registerB = funcWrite("_imm", 0, a)
            return registerB

        def opNop(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], engineFunc : dict[str, Callable[[Any], Any]], engineStatus : dict):
            """The 'No Operation' instruction, it does nothing"""

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)
            assert type(engineFunc) is dict
            assert all([callable(j) for _, j in engineFunc.items()])
            assert type(engineStatus) is dict
            
            pass #Does nothing

        def opAdd(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str]
        ) -> None:
            """Adds registerA and registerB, stores result in registerDestination"""

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            a : int = funcRead(registerA)
            b : int = funcRead(registerB)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            c : int = a + b
            result : int = c & (2**bitLength - 1)

            funcWrite(registerDestination, result)

        def opAddCarryOverflow(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str],

            registerCarry : Optional[tuple[int | str, int | str] | None] = None, 
            registerOverflow : Optional[tuple[int | str, int | str] | None] = None
        ) -> None:
            """Adds registerA and registerB, stores result in registerDestination, stores carry in registerCarry iff specified, stores overflow in registerOverflow iff specified
            
            Algorithm Overview - Add with Carry and Overflow:
                registerA of arbitrary length
                registerB of arbitrary length
                result = registerA + registerB
                result is trucated to size of registerDestination
                registerDestination = result
                
                iff registerCarry is specified:
                    if result is bigger then registerDestination can store:
                        store 1 in registerCarry
                    else:
                        store 0 in registerCarry
                iff registerOverflow is specified:
                    # https://www.allaboutcircuits.com/textbook/digital/chpt-2/binary-overflow/#:~:text=The%20answer%20to%20this,of%20the%20bit%20field.
                    size = size of registerDesitnation
                    signA = takes registerA bit[size - 1]
                    signB = takes registerB bit[size - 1]
                    signR = takes result bit[size - 1]
                    if signA == signB and signA != signR:
                        store 1 in registerOverflow
                    else:
                        store 0 in registerOverflow

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_opAddCarryOverflow_addSingleElement01
                'r0 + r0 = r0' with bitLength '1, 1, 1' -> '0 + 0 = 0'
                -> # create registers
                r0 = [0, 0];                    value = 0; bitLength = 1                |
                ->
                opAddCarryOverflow(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    funcGetConfig               = funcDummyConfig
                    registerDestination         = [0, 0]                                |
                    registerA                   = [0, 0]                                |
                    registerB                   = [0, 0]                                |
                    registerCarry               = None
                    registerOverflow            = None
                )
                -> # input
                registerA                       = 0 
                registerB                       = 0
                ->
                '0 + 0 = 0'
                -> # output
                registerDestination             = 0
                registerCarry                   = None
                registerOverflow                = None
                -> # written
                r0 = [0, 0];                    value = 0; bitLength = 1                |

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_opAddCarryOverflow_integration02
                'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 2'
                -> # create registers
                r0 = [0, 0];                    value = 1;          bitLength = 8
                r1 = [0, 1];                    value = 1;          bitLength = 8
                r2 = [0, 2];                    value = 0;          bitLength = 8
                ->
                opAddCarryOverflow(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    funcGetConfig               = funcDummyConfig
                    registerDestination         = [0, 2]
                    registerA                   = [0, 0]
                    registerB                   = [0, 1]
                    registerCarry               = None
                    registerOverflow            = None
                )
                -> # input
                registerA                       = 1
                registerB                       = 1
                ->
                '1 + 1 = 2, c = 0, o = 0'
                -> # output
                registerDestination             = 2
                registerCarry                   = None
                registerOverflow                = None
                -> # written
                r2 = [0, 2];                    value = 2;          bitLength = 8

            Case: # Test_InstructionSetDefault_BuildingBlocks.test_opAddCarryOverflow_integration05
                'r0 + r1 = r2, c = c0, o = o0' with bitLength '2, 2, 2, 1, 1' -> '3 + 2 = 1, c = 1, o = 1'
                -> # create registers
                r0 = [0, 0];                    value = 3;             bitLength = 2
                r1 = [0, 1];                    value = 2;             bitLength = 2
                r2 = [0, 2];                    value = 0;             bitLength = 2
                c0 = ['c', 0];                  value = 0;             bitLength = 1
                o0 = ['o', 0];                  value = 0;             bitLength = 1
                ->
                opAddCarryOverflow(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    funcGetConfig               = funcDummyConfig
                    registerDestination         = [0, 2]
                    registerA                   = [0, 0]
                    registerB                   = [0, 1]
                    registerCarry               = ['c', 0]
                    registerOverflow            = ['o', 0]
                )
                -> # input
                registerA                       = 3
                registerB                       = 2
                ->
                '3 + 2 = 1, c = 1, o = 1'
                -> # output
                registerDestination             = 1
                registerCarry                   = 1
                registerOverflow                = 1
                -> # written
                r2 = [0, 2];                    value = 1;             bitLength = 2
                c0 = ['c', 0];                  value = 1;             bitLength = 1
                o0 = ['o', 0];                  value = 1;             bitLength = 1
                
            Case: # Test_InstructionSetDefault_BuildingBlocks.test_opAddCarryOverflow_8bitFullCombination
                'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['x + y = ?' for x in range(256) for y in range(256)]
                -> # create registers
                r0 = [0, 0];                    value = x;             bitLength = 8
                r1 = [0, 1];                    value = y;             bitLength = 8
                r2 = [0, 2];                    value = 0x00;          bitLength = 8
                ->
                opAddCarryOverflow(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    funcGetConfig               = funcDummyConfig
                    registerDestination         = [0, 2]
                    registerA                   = [0, 0]
                    registerB                   = [0, 1]
                    registerCarry               = None
                    registerOverflow            = None
                )
                -> # input
                registerA                       = x
                registerB                       = y
                ->
                'x + y = ?'
                -> # output
                registerDestination             = ?
                registerCarry                   = None
                registerOverflow                = None
                -> # written
                r2 = [0, 2];                    value = ?;             bitLength = 8
            
            Case: # Test_InstructionSetDefault_BuildingBlocks.test_opAddCarryOverflow_zfighting01
                'r0 + r0 = r0, c = r0, o = r0' with bitLength '8, 8, 8, 8, 8' -> '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
                -> # create registers
                r0 = [0, 0];                    value = 0xff; bitLength = 8             |
                ->
                opAddCarryOverflow(
                    funcRead                    = funcDummyRead
                    funcWrite                   = funcDummyWrite
                    funcGetConfig               = funcDummyConfig
                    registerDestination         = [0, 0]                                |
                    registerA                   = [0, 0]                                |
                    registerB                   = [0, 0]                                |
                    registerCarry               = [0, 0]                                |
                    registerOverflow            = [0, 0]                                |
                )
                -> # input
                registerA                       = 0xff                                  |
                registerB                       = 0xff                                  |
                ->
                '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
                -> # output
                registerDestination             = 0xfe                                  |
                registerCarry                   = 1                                     |
                registerOverflow                = 0                                     |
                -> # written
                r0 = [0, 0];                    value = 0xfe; bitLength = 8             | # register will be in an undetermined value, due to write conflics
                r0 = [0, 0];                    value = 1                               |
                r0 = [0, 0];                    value = 0                               |
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            assert type(registerCarry) is tuple or type(registerCarry) is list or registerCarry is None
            if registerCarry is not None:
                assert len(registerCarry) == 2
                assert all([type(i) is str or type(i) is int for i in registerCarry])
                assert all([i >= 0 for i in registerCarry if type(i) is int])
                assert self.isISARegisterVector(registerCarry)

            assert type(registerOverflow) is tuple or type(registerOverflow) is list or registerOverflow is None
            if registerOverflow is not None:
                assert len(registerOverflow) == 2
                assert all([type(i) is str or type(i) is int for i in registerOverflow])
                assert all([i >= 0 for i in registerOverflow if type(i) is int])
                assert self.isISARegisterVector(registerOverflow)

            a : int = funcRead(registerA)
            b : int = funcRead(registerB)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            c : int = a + b
            result : int = c & (2**bitLength - 1) # trunk result
            funcWrite(registerDestination, result)

            # carry
            carry : int = 0
            if c > (2**bitLength - 1):
                carry = 1
            if registerCarry is not None:
                carryBitLength : int = funcGetConfig(registerCarry)["bitLength"]
                resultCarry : int = carry & (2**carryBitLength - 1) # trunk result
                funcWrite(registerCarry, resultCarry)

            # overflow
            # if the sign bit of the inputs are the same, and the sign bit of the result is different, then overflow
            # also applies to and works with twos compliment subtraction
            #TODO figure out how arbritrary length input registers should affect it
            overflow : int = 0
            if (a & 2**(bitLength - 1) == b & 2**(bitLength - 1)) and (a & 2**(bitLength - 1) != c & 2**(bitLength - 1)):
                overflow = 1
            if registerOverflow is not None:
                overflowBitLength : int = funcGetConfig(registerOverflow)["bitLength"]
                resultOverflow : int = overflow & (2**overflowBitLength - 1) # trunk result
                funcWrite(registerOverflow, resultOverflow)

        def opMultiply(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str]
        ) -> None:
            """Multiplies registerA and registerB, stores result in registerDestination
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            a : int = funcRead(registerA)
            b : int = funcRead(registerB)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            c : int = a * b
            result : int = c & (2**bitLength - 1) # trunk result

            funcWrite(registerDestination, result)

        def opMultiplySignedMultiElement(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[tuple[int | str, int | str], ...], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str],
            
            endiness : Literal['big', 'little'] = 'little'
        ) -> None:
            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) > 0
            for register in registerDestination:
                assert len(register) == 2
                assert all([type(i) is str or type(i) is int for i in register])
                assert all([i >= 0 for i in register if type(i) is int])
                assert self.isISARegisterVector(register)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            assert type(endiness) is str
            assert endiness in ['big', 'little']

            raise NotImplementedError

        def opTwosCompliment(self, 
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str]
        ) -> None:
            """Takes value from registerA, performs twos compliment, stores result in registerDestination
            
            #TODO if destination register is larger, should extend most significant bit to larger register size
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            a : int = funcRead(registerA)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            # the input number would usually be cut down to the correct size before operating on it
            # but since this is a logical xor operation, all relavent bits stay within the 'trunk result' later on
            # inputNumber : int = a & (2**bitLength - 1) # Cuts down number to correct bitLength BEFORE operating on it
            result : int = ((2**bitLength - 1) ^ a) + 1 # Performs Twos compliment <= (Not inputnumber) + 1 <= (bitmask xor inputnumber) + 1

            result = result & (2**bitLength - 1) # trunk result

            funcWrite(registerDestination, result)

        def opAND(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str]
        ) -> None:
            """Performs AND operation between registerA and registerB, stores result in registerDestination
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            a : int = funcRead(registerA)
            b : int = funcRead(registerB)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            c : int = a & b
            result : int = c & (2**bitLength - 1) # trunk result

            funcWrite(registerDestination, result)

        def opOR(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],
            
            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str]
        ) -> None:
            """Performs OR operation between registerA and registerB, stores result in registerDestination
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            a : int = funcRead(registerA)
            b : int = funcRead(registerB)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            c : int = a | b
            result : int = c & (2**bitLength - 1) # trunk result

            funcWrite(registerDestination, result)

        def opXOR(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],
            
            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerB : tuple[int | str, int | str]
        ) -> None:
            """Performs XOR operation between registerA and registerB, stores result in registerDestination
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert all([type(i) is str or type(i) is int for i in registerB])
            assert all([i >= 0 for i in registerB if type(i) is int])
            assert self.isISARegisterVector(registerB)

            a : int = funcRead(registerA)
            b : int = funcRead(registerB)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            c : int = a ^ b
            result : int = c & (2**bitLength - 1) # trunk result

            funcWrite(registerDestination, result)

        def opNOT(self, 
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],
            
            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str]
        ) -> None:
            """Performs NOT operation on registerA, stores result in registerDesintation
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            a : int = funcRead(registerA)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            # the input number would usually be cut down to the correct size before operating on it
            # but since this is a logical xor operation, all relavent bits stay within the 'trunk result' later on
            # inputNumber : int = a & (2**bitLength - 1) # Cuts down number to correct bitLength BEFORE operating on it
            result : int = ((2**bitLength - 1) ^ a) # Performs Not inputNumber <= (bitmask xor inputNumber)

            """
            bitArray : list[Literal[0, 1]] = [inputNumber >> i & 1 for i in range(bitLength)] # Converts to bit array, index 0 is least significant bit
            bitArray = [not i for i in bitArray] # performs the bitwise NOT operation
            # This algorithm uses far less memory then using alternate method
            result : int = 0
            i : int
            bit : Literal[0, 1]
            for i, bit in enumerate(bitArray):
                result |= bit << i
            """

            # This algorithm causes massive memory usage (>50GB) if bitLength is large (== 2**20)
            # result : int = sum([bit << i for i, bit in enumerate(bitArray)])

            result = result & (2**bitLength - 1) # Cuts down number to correct bitLength again

            funcWrite(registerDestination, result)

        def opJump(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], engineFunc : dict[str, Callable[[Any], Any]], engineStatus : dict, 
            mode : Literal["goto", "<", "<=", ">", ">=", "==", "!="],
            gotoIndex : tuple[int | str, int | str], registerA : tuple[int | str, int | str] = None, registerB : tuple[int | str, int | str] = None):
            """Conditional jump to gotoIndex, conditional on mode, and optional registers a and b

            #TODO needs to handle signed and unsigned ints

            mode:
                goto                    - a simple jump without any condition testing, a and b must be set to None
                <                       - less than
                <=                      - less than or equal to
                >                       - greater than
                >=                      - greater than or equal to
                ==                      - equal
                !=                      - not equal
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)
            assert type(engineFunc) is dict
            assert all([callable(j) for _, j in engineFunc.items()])
            assert type(engineStatus) is dict
            
            assert type(mode) is str
            assert len(mode) > 0
            mode = mode.lower()
            assert mode in ("goto", "<", "<=", ">", ">=", "==", "!=")
            assert type(gotoIndex) is tuple or type(gotoIndex) is list
            assert len(gotoIndex) == 2
            assert type(gotoIndex[0]) is int or type(gotoIndex[0]) is str 
            assert type(gotoIndex[1]) is int or type(gotoIndex[1]) is str
            if mode != "goto":
                assert type(registerA) is tuple or type(registerA) is list
                assert len(registerA) == 2
                assert type(registerA[0]) is int or type(registerA[0]) is str 
                assert type(registerA[1]) is int or type(registerA[1]) is str
                assert type(registerB) is tuple or type(registerB) is list
                assert len(registerB) == 2
                assert type(registerB[0]) is int or type(registerB[0]) is str 
                assert type(registerB[1]) is int or type(registerB[1]) is str
            else: # mode == "goto"
                assert type(registerA) is type(None)
                assert type(registerB) is type(None)
            
            pointer : int = funcRead(gotoIndex)
            pc : list[str, int] = ("pc", 0)

            if mode == "goto":
                funcWrite(pc, pointer)
            else:
                a : int = funcRead(registerA)
                b : int = funcRead(registerB)

                if mode == "<" and a < b:
                    funcWrite(pc, pointer)
                elif mode == "<=" and a <= b:
                    funcWrite(pc, pointer)
                elif mode == ">" and a > b:
                    funcWrite(pc, pointer)
                elif mode == ">=" and a >= b:
                    funcWrite(pc, pointer)
                elif mode == "==" and a == b:
                    funcWrite(pc, pointer)
                elif mode == "!=" and a != b:
                    funcWrite(pc, pointer)

        def opShiftL(self,
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[int | str, int | str], 
            registerA : tuple[int | str, int | str], 
            registerShiftOffset : tuple[int | str, int | str]
        ) -> None:
            """Takes registerA, shifts left by amount registerShiftOffset, stores result in registerDestination
            
            #TODO documentation
            """

            assert callable(funcRead)

            assert callable(funcWrite)

            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert all([type(i) is str or type(i) is int for i in registerDestination])
            assert all([i >= 0 for i in registerDestination if type(i) is int])
            assert self.isISARegisterVector(registerDestination)

            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert all([type(i) is str or type(i) is int for i in registerA])
            assert all([i >= 0 for i in registerA if type(i) is int])
            assert self.isISARegisterVector(registerA)

            assert type(registerShiftOffset) is tuple or type(registerShiftOffset) is list
            assert len(registerShiftOffset) == 2
            assert all([type(i) is str or type(i) is int for i in registerShiftOffset])
            assert all([i >= 0 for i in registerShiftOffset if type(i) is int])
            assert self.isISARegisterVector(registerShiftOffset)

            a : int = funcRead(registerA)
            shiftAmount : int = funcRead(registerShiftOffset)
            bitLength : int = funcGetConfig(registerDestination)["bitLength"]

            result : int = a << shiftAmount if shiftAmount < bitLength else 0 # 0 if shiftAmount pushes entire number out of bounds

            result = result & (2**bitLength - 1)

            funcWrite(registerDestination, result)

        def opShiftR(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], engineFunc : dict[str, Callable[[Any], Any]], engineStatus : dict, 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str], registerShiftOffset : tuple[int | str, int | str], arithmetic : bool = False):
            """Takes registerA, shifts it right by registerShiftOffset (performs arithmetic right shift if arithmetic == True), stores result in registerDestination
            
            If registerDestination bitLength is greater then registerA bitLength:
                registerA most significant bit is extended to registerDestiantion bitLength AFTER arithmetic shift right
            will raise exception if value of registerShiftOffset > 8*max(256, registerDesintation bitLength, registerA bitLength) 
                a wide margine of error is given as that value does need to be bounded, but a small enough margine of error could break user source code unexpectidly
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)
            assert type(engineFunc) is dict
            assert all([callable(j) for _, j in engineFunc.items()])
            assert type(engineStatus) is dict
            
            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str
            assert type(registerShiftOffset) is tuple or type(registerShiftOffset) is list
            assert len(registerShiftOffset) == 2
            assert type(registerShiftOffset[0]) is int or type(registerShiftOffset[0]) is str 
            assert type(registerShiftOffset[1]) is int or type(registerShiftOffset[1]) is str
            assert type(arithmetic) is bool

            a : int = funcRead(registerA)
            amount : int = funcRead(registerShiftOffset)

            bitLengthSource : int = funcGetConfig(registerA)
            bitLengthDestination : int = funcGetConfig(registerDestination)

            if amount > 8 * max(256, bitLengthSource, bitLengthDestination):
                raise Exception("Instruction input 'registerShiftOffset' is too large to be valid")

            result : int = a
            for _ in range(amount): # shift a right WITHIN bitLengthSource
                msb : int = 0
                if arithmetic:
                    msb = 2**(bitLengthSource - 1) & result
                result = result >> 1
                result = result | msb

            if bitLengthSource < bitLengthDestination: # Takes msb, and extends it out to larger bitLength bitLengthDestination if needed
                msb : int = 2**(bitLengthSource - 1) & result
                for _ in range(bitLengthSource - 1, bitLengthDestination):
                    msb = msb | (msb << 1)
                result = result | msb
            
            result = result & (2**bitLengthDestination - 1)

            funcWrite(registerDestination, result)

        def opRotate(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], engineFunc : dict[str, Callable[[Any], Any]], engineStatus : dict, 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str], registerShiftOffset : tuple[int | str, int | str], 
            leftOrRight : Literal["left", "right"]):
            """Takes registerA, rotates bits left or right (depending on leftOrRight) by rigsterShiftOffset amount. Result is then trunked to fit into registerDestination
            
            will raise exception if value of registerShiftOffset > 8*max(256, registerDesintation bitLength, registerA bitLength) 
                a wide margine of error is given as that value does need to be bounded, but a small enough margine of error could break user source code unexpectidly
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)
            assert type(engineFunc) is dict
            assert all([callable(j) for _, j in engineFunc.items()])
            assert type(engineStatus) is dict

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str
            assert type(registerShiftOffset) is tuple or type(registerShiftOffset) is list
            assert len(registerShiftOffset) == 2
            assert type(registerShiftOffset[0]) is int or type(registerShiftOffset[0]) is str 
            assert type(registerShiftOffset[1]) is int or type(registerShiftOffset[1]) is str

            assert type(leftOrRight) is str
            assert leftOrRight in ("left", "right")

            a : int = funcRead(registerA)
            amount : int = funcRead(registerShiftOffset)

            bitLengthSource : int = funcGetConfig(registerA)
            bitLengthDestination: int = funcGetConfig(registerDestination)

            if amount > 8 * max(256, bitLengthSource, bitLengthDestination):
                raise Exception("Instruction input 'registerShiftOffset' is too large to be valid")

            if leftOrRight == "right":
                for _ in range(amount):
                    lsb = a & 1
                    a = a >> 1
                    a = a | (lsb << (bitLengthSource - 1))
            elif leftOrRight == "left":
                for _ in range(amount):
                    msb = a & (2**(bitLengthSource - 1))
                    a = a << 1
                    a = a | (1 if msb == 0 else 0)
                    a = a & (2**bitLengthSource - 1)
            
            result = a & (2**bitLengthDestination - 1)

            funcWrite(registerDestination, result)

        def opCopyElement(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], engineFunc : dict[str, Callable[[Any], Any]], engineStatus : dict, 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str],
            trunkOrExtend : Literal["trunk", "extend"] = 'trunk'):
            """Copies a value from registerA to registerDestination
            
            if trunkOrExtend == 'trunk':
                value from registerA is trunked to fit into registerDestination
            elif trunkOrExtend == 'extend':
                value from registerA is arithmatically extended to fit into registerDestination (IE: signed integer copy)
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)
            assert type(engineFunc) is dict
            assert all([callable(j) for _, j in engineFunc.items()])
            assert type(engineStatus) is dict

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str

            assert type(trunkOrExtend) is str
            assert len(trunkOrExtend) > 0
            assert trunkOrExtend == "trunk" or trunkOrExtend == "extend"

            sourceBitLength : int = funcGetConfig(registerA)
            destinationBitLength : int = funcGetConfig(registerDestination)

            a : int = funcRead(registerA)
            result : int = 0
            
            if trunkOrExtend == "trunk":
                result = a & (2**destinationBitLength - 1)
            elif trunkOrExtend == "extend":
                msb : int = 2**(sourceBitLength - 1) & 1
                result = a
                for _ in range(destinationBitLength - sourceBitLength): # Takes msb, and extends it out to larger bitLength bitLengthDestination if needed
                    msb = msb << 1
                    result = result & msb
                result = result & (2**destinationBitLength - 1)

            funcWrite(registerDestination, result)

        def opCopyMultiElement(self, 
            funcRead : Callable[[tuple[int | str, int | str]], int], 
            funcWrite : Callable[[tuple[int | str, int | str], int], None], 
            funcGetConfig : Callable[[tuple[int | str, int | str]], dict[str, Any]],

            registerDestination : tuple[tuple[int | str, int | str], ...], 
            registerA : tuple[tuple[int | str, int | str], ...], 

            bitsToCopy : int,
            arithimetic : bool = False,
            endiness : Literal['big', 'little'] = 'little',
        ) -> None:
            """Copies a value from registerA to registerDestination
            
            Use Cases:
                copy register to register
                copy byte to memory and vice versa
                copy word to memory and vice versa
                trunk or arithmatic extend value while copying
            
            #TODO
            """
            raise NotImplementedError

        def englatAdd_RippleCarry(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str], registerB : tuple[int | str, int | str]
        ) -> dict[Literal["energy", "latency"], int]:
            """Takes in registerA, registerB, and registerDestination, and compute the energy and latency of ripple carry add operation on those registers. Returns the energy and latency as a dictionary
            
            The value of the registers are not used, only the size of the registers
            energy = 1 is normalized to one logic gate
            latency = 1 is normalized to one logic gate
            
            Circuit used:
            def (a, b, c_in) -> s, c_out:
                s = ((a xor b) xor c_in)
                c_out = (((a xor b) and c_in) or (a and b))
                return s, c_out
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str
            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert type(registerB[0]) is int or type(registerB[0]) is str 
            assert type(registerB[1]) is int or type(registerB[1]) is str

            bitLength : int = max(funcGetConfig(registerA), funcGetConfig(registerB))

            energy : int = bitLength * 5
            latency : int = bitLength * 3

            return {"energy" : energy, "latency" : latency}

        def englatMultiply_ShiftAdd1(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str], registerB : tuple[int | str, int | str]
        ) -> dict[Literal["energy", "latency"], int]:
            """Takes in registerA, registerB, and registerDestination, and compute the energy and latency of multiply via shift add. Returns the energy and latency as a dictionary

            The value of the registers are not used, only the size of the registers
            energy = 1 is normalized to one logic gate
            latency = 1 is normalized to one logic gate

            Doubles the length of input registers
            for every bit:
                uses an ripple carry add of (energy = 5 * bitLength, latency = 3)
                uses a shift of (energy = 1 * bitLength, latency = 1)
            This is a very simplistic and unoptimized algorithm
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str
            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert type(registerB[0]) is int or type(registerB[0]) is str 
            assert type(registerB[1]) is int or type(registerB[1]) is str

            bitLength : int = max(funcGetConfig(registerA), funcGetConfig(registerB)) * 2

            energy : int = (bitLength * (5 + 1)) * bitLength
            latency : int = (bitLength * (3 + 1)) * 2
            
            return {"energy" : energy, "latency" : latency}

        def englatMultiply_ShiftAdd2(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str], registerB : tuple[int | str, int | str]
        ) -> dict[Literal["energy", "latency"], int]:
            """Takes in registerA, registerB, and registerDestination, and compute the energy and latency of multiply via shift add. Returns the energy and latency as a dictionary

            The value of the registers are not used, only the size of the registers
            energy = 1 is normalized to one logic gate
            latency = 1 is normalized to one logic gate

            Doubles the length of input registers
            for every bit:
                uses an ripple carry add of (energy = 5 * bitLength, latency = 3)
                uses a shift of (energy = 1 * bitLength, latency = 1)
            Since leading bits remain zero until after some shifts, and trailing bits remain unchanged after some shifts, it's only the middle bits that actually require computation.
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str
            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert type(registerB[0]) is int or type(registerB[0]) is str 
            assert type(registerB[1]) is int or type(registerB[1]) is str

            bitLength : int = max(funcGetConfig(registerA), funcGetConfig(registerB))

            energy : int = (bitLength * (5 + 1)) * bitLength
            latency : int = (bitLength * (3 + 1)) * 2
            
            return {"energy" : energy, "latency" : latency}

        def englatAND(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str], registerB : tuple[int | str, int | str]
        ) -> dict[Literal["energy", "latency"], int]:
            """Takes in registerA, registerB, and registerDestination, and compute the energy and latency of AND operation on those registers. Returns the energy and latency as a dictionary
            
            The value of the registers are not used, only the size of the registers
            energy = 1 is normalized to one logic gate
            latency = 1 is normalized to one logic gate
            
            Circuit used:
            def (a, b) -> x:
                x = (a and b)
                return x
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str
            assert type(registerB) is tuple or type(registerB) is list
            assert len(registerB) == 2
            assert type(registerB[0]) is int or type(registerB[0]) is str 
            assert type(registerB[1]) is int or type(registerB[1]) is str

            bitLength : int = max(funcGetConfig(registerA), funcGetConfig(registerB))

            energy : int = bitLength
            latency : int = 1

            return {"energy" : energy, "latency" : latency}

        def englatNOT(self, 
            funcRead : Callable[[int | str, int | str], int], funcWrite : Callable[[int | str, int | str], None], funcGetConfig : Callable[[int | str, int | str], dict], 
            registerDestination : tuple[int | str, int | str], registerA : tuple[int | str, int | str]
        ) -> dict[Literal["energy", "latency"], int]:
            """Takes in registerA, registerB, and registerDestination, and compute the energy and latency of AND operation on those registers. Returns the energy and latency as a dictionary
            
            The value of the registers are not used, only the size of the registers
            energy = 1 is normalized to one logic gate
            latency = 1 is normalized to one logic gate
            
            Circuit used:
            def (a) -> x:
                x = (not a)
                return x
            """

            assert callable(funcRead)
            assert callable(funcWrite)
            assert callable(funcGetConfig)

            assert type(registerDestination) is tuple or type(registerDestination) is list
            assert len(registerDestination) == 2
            assert type(registerDestination[0]) is int or type(registerDestination[0]) is str 
            assert type(registerDestination[1]) is int or type(registerDestination[1]) is str
            assert type(registerA) is tuple or type(registerA) is list
            assert len(registerA) == 2
            assert type(registerA[0]) is int or type(registerA[0]) is str 
            assert type(registerA[1]) is int or type(registerA[1]) is str

            bitLength : int = funcGetConfig(registerA)

            energy : int = bitLength
            latency : int = 1

            return {"energy" : energy, "latency" : latency}

    class ParserDefault(ParserAbstract):
        """Parses strings into an (almost) execution tree.
        ParseDefault.Node is the dataclass for storing tokens in a Node Tree.

        ParseDefault.parseCode("source code") is called which returns a Node Tree representing the "source code"

            ParseDefault.parseCode() calls ParseDefault.tokenize() to do the initial tokenization of the "source code"
            root -> Node
                    |- Token "test"
                    |- Token " "
                    |- Token "123"
                    |- ...

            "rule functions" are called to apply various rules to the Node Tree
            all "rule functions" are functional, and return a COPY of Nodes
            Note: most do not recurse
            by combining "rule functions" in different ways in ParseDefault.parseCode(), different syntaxes can be proccessed
            root = self.ruleRemoveToken(root, " ")
            root -> Node
                    |- Token "test"
                    |- Token "123"
                    |- ...
            root = ruleCastInts(root)
            root -> Node
                    |- Token "test"
                    |- Token 123
                    |- ...

            return root
        """

        def __init__(self):

            self.nameSpace : dict[str, NameSpaceObject] = {}

            self.externalNameSpace : dict[str, NameSpaceObject] = {} # Used for keeping track of external nameSpace elements

            self.Node : ParseNode = NodeParse

        
        def updateNameSpace(self, nameSpace : dict[str, NameSpaceObject]) -> dict[str, NameSpaceObject]:
            """Takes in nameSpace a dictionary whose keys represent the CPU flags, registers, instructions, etc. 
            Returns nameSpace elements contained in this module that are not contained in input nameSpace
            
            #TODO
            """

            assert type(nameSpace) is dict
            assert all([type(i) is NameSpaceObject for _, i in nameSpace.items()])

            #TODO should compair current namespace with new namespace and only update the new ones
            self.externalNameSpace : dict[str, NameSpaceObject] = nameSpace
            self.nameSpace : dict[str, NameSpaceObject] = {}

            #TODO should return all elements that are in nameSpace, but not in externalNameSpace
            return {}

        def tokenize(self, code : str) -> list[tuple[str, int, int]]:
            """Takes in a string of code, returns a list of tuples representing the code in the form of (string/tuple, line location, character location in line)(zero indexed). 
            
            No characters are filtered out
            
            Case: # TestParseDefaultBuildingBlocks.test_tokenizer_HelloWorld
                "Hello World!" 
                ->
                [
                    ('Hello',   0, 0),
                    (' ',       0, 5),
                    ('World',   0, 6),
                    ('!',       0, 11)
                ]

            Case: # TestParseDefaultBuildingBlocks.test_tokenizer_IntegrationMultiline
                "test\n\nHello World!" 
                ->
                [
                    ('test',    0, 0),
                    ('\n',      0, 4),
                    ('\n',      1, 0),
                    ('Hello',   2, 0),
                    (' ',       2, 5),
                    ('World',   2, 6),
                    ('!',       2, 11)
                ]
            """

            assert type(code) is str
            assert len(code) > 0

            # done like this to easily add extra characters
            _isName : Callable[[str], bool] = lambda x : x.isalnum() or x in "_" # returns True is character can be in a name, False otherwise

            tokenList : list[tuple[str, int, int]] = []
            token : str = ""
            lineNum : int = 0
            characterNum : int = 0
            tokenLength : int = 0
            j : str # char
            for j in code:
                if _isName(j): # creates tokens from everything that could be a variable name
                    token += j
                    tokenLength += 1
                else: # everything else is a special character
                    if token != "":
                        tokenList.append((token, lineNum, characterNum - tokenLength))
                        token = ""
                        tokenLength = 0
                    tokenList.append((j, lineNum, characterNum))
                    tokenLength = 0

                # keeps track of line and positition numbers
                if j == "\n":
                    lineNum += 1
                    characterNum = 0
                else:
                    characterNum += 1
            if token != "": # adds last token
                tokenList.append((token, lineNum, characterNum - tokenLength))
                token = ""
                tokenLength = 0

            return tokenList

        def tokenizeCharacter(self, code : str) -> list[tuple[str, int, int]]:
            """Takes in a string of code, returns a list of tuples representing the code in the form of (single character, line location, character location in line)(zero indexed). 
            
            No characters are filtered out
            """

            assert type(code) is str
            assert len(code) > 0

            raise NotImplementedError

        def ruleCastInts(self, tree : ParseNode) -> ParseNode:
            """Takes in a Node Tree of depth 2, casts all children that are integers to integers (with labels). Returns a Node Tree of depth 2. Does not recurse 
            
            #TODO should recerse

            Case: # TestParseDefaultBuildingBlocks.test_ruleCastInts_Integration01
                "123 456 789" 
                ->
                Node
                    '123'               | Cast
                    ' '
                    '456'               | Cast
                    ' '
                    '789'               | Cast
                ->
                Node
                    123                 |
                    ' '
                    456                 |
                    ' '
                    789                 |
            """

            assert type(tree) is self.Node

            root : ParseNode = tree.copyInfo()

            i : ParseNode
            for i in tree.child:
                if type(i.token) is str:
                    if i.token.isdigit():
                        temp = i.copyDeep()
                        temp.token = int(i.token)
                        temp.type = "int"
                        root.append(temp)
                    else:
                        root.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root

        def ruleCastHex(self, tree : ParseNode) -> ParseNode:
            """Takes in a Node Tree of depth 2, casts all children that are in hex format to integers (with format of '0xFFFF' with arbitrary length). Returns a node tree of depth 2. Does not recurse.

            #TODO should recurse

            Case: # TestParseDefaultBuildingBlocks.test_ruleCastHex_Integration02
                "0x0 0x000A 0xff" 
                ->
                Node
                    '0x0'                Cast
                    ' '
                    '0x000A'            | Cast
                    ' '
                    '0xff'              | Cast
                ->
                Node
                    0                   |
                    ' '
                    10                  |
                    ' '
                    255                 |
            """

            assert type(tree) is self.Node

            root : ParseNode = tree.copyInfo()

            i : ParseNode
            for i in tree.child:
                if type(i.token) == str:
                    if i.token.startswith("0x") or i.token.startswith("0X"):
                        temp : ParseNode = i.copyDeep()
                        temp.token = int(i.token, 16)
                        temp.type = "int"
                        root.append(temp)
                    else:
                        root.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root

        def ruleRemoveEmptyLines(self, tree : ParseNode) -> ParseNode:
            """Takes in a Node Tree of depth 2. Removes all empty lines. Returns a Node Tree of depth 2.

            Does not recurse

            Case 1:  # TestParseDefaultBuildingBlocks.test_ruleRemoveEmptyLines_Integration02
                "test\ntest\n\n\ntest\n" 
                ->
                Node
                    'test'
                    '\n'
                    'test'
                    '\n'    
                    '\n'                |
                    '\n'                |
                    'test'
                    '\n'
                ->
                Node
                    'test'
                    '\n'
                    'test'
                    '\n'                _V_
                    'test'               A
                    '\n'
            """

            assert type(tree) is self.Node

            root : ParseNode = tree.copyInfo()

            stack : str = "\n"

            i : ParseNode
            for i in tree.child:
                # if previous == "\n" and current == "\n" do nothing, else copy Node
                if i != "\n" or stack != "\n":
                    root.append(i.copyDeep())
                    stack = i.token

            return root

        def ruleRemoveLeadingWhitespace(self, tree : ParseNode, whiteSpace : list[str] = [" ", "\t", "\r", "\f"]) -> ParseNode:
            """Takes in a Node Tree of depth 2, removes all white space tokens between a new line token and the next token. Returns a Node Tree of depth 2. Does not recurse

            Case: # TestParseDefaultBuildingBlocks.test_ruleRemoveLeadingWhitespace_Integration02
                "test test \ntest\n  \ttest\t\n     \n" 
                -> 
                Node
                    'test'
                    ' '
                    'test'
                    ' '
                    '\n'
                    'test'
                    '\n'
                    ' '                 |
                    ' '                 |
                    '\t'                |
                    'test'
                    '\t'
                    '\n'
                    ' '                 |
                    ' '                 |
                    ' '                 |
                    ' '                 |                               
                    ' '                 |
                    '\n'
                ->
                Node
                    'test'
                    ' '
                    'test'
                    ' '
                    '\n'
                    'test'
                    '\n'                _V_
                    'test'               A
                    '\t'
                    '\n'                _V_
                    '\n'                 A

            Case: # TestParseDefaultBuildingBlocks.test_ruleRemoveLeadingWhitespace_Children01
                'test\n\t\t\ttest[abc 123]' 
                ->
                Node
                    'test'
                    '\n'
                    '\t'                |
                    '\t'                |
                    '\t'                |
                    'test'              # Children of Node are not affected unless they are children of whitespace
                        'abc'
                        ' '
                        '123'
                ->
                Node
                    'test'
                    '\n'                _V_
                    'test'               A      # Children of Node are not affected unless they are children of whitespace
                        'abc'
                        ' '
                        '123'

            Case: # TestParseDefaultBuildingBlocks.test_ruleRemoveLeadingWhitespace_Children02
                'test\n\t\t\t[abc 123]test'
                ->
                Node
                    'test'
                    '\n'
                    '\t'                |
                    '\t'                |
                    '\t'                | This node will be removed, along with children
                        'abc'           |
                        ' '             |
                        '123'           |
                    'test'
                ->
                Node
                    'test'
                    '\n'                _V_
                    'test'               A
            """

            assert type(tree) is self.Node
            assert type(whiteSpace) is list
            assert all([type(i) is str for i in whiteSpace])
            assert all([len(i) == 1 for i in whiteSpace])

            root : ParseNode = tree.copyInfo()

            stack : str = "\n" # initialize to State 0
            if len(tree.child) != 0:
                if tree.child[0] == "\n":
                    stack = None # initialize to State 1

            ''' Finite State Machine
            State 0: at beginning of line
            State 1: after first token
            Edge: 0 -> 0: found whitespace, not copying
            Edge: 0 -> 1: found token, copying
            Edge: 1 -> 0: found newline
            Edge: 1 -> 1: did not find newline, copy token
            '''
            i : ParseNode
            for i in tree.child:
                logging.debug(debugHelper(inspect.currentframe()) + repr(i.token))
                if stack != None: # State 0: at beginning of line
                    if i.token in whiteSpace: # Edge: 0 -> 0: found whitespace, not copying
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 0 -> 0")
                        pass
                    else: # Edge: 0 -> 1: found token, copying
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 0 -> 1")
                        root.append(i.copyDeep())
                        stack = None
                else: # State 1: after first token
                    if i == "\n": # Edge: 1 -> 0: found newline
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 1 -> 0")
                        stack = "\n"
                        root.append(i.copyDeep())
                    else: # Edge: 1 -> 1: did not find newline, copy token
                        logging.debug(debugHelper(inspect.currentframe()) + "\tEdge 1 -> 1")
                        root.append(i.copyDeep())

            return root

        def ruleStringSimple(self, tree : ParseNode) -> ParseNode:
            """Takes in a Node Tree of depth 2, combines all the tokens that are contained by quote tokens into a string node. Returns a Node Tree of depth 2.
            #TODO allow for arbitrary definition of list of 'quote like characters'
            #TODO question: should make 'string' tokens also include the quote characters?
                rational: may cause confusion with instruction namespaces unless token labels are strictly followed
                    "add(\"add\")"
                    ->
                    Node
                        'add'
                        '('
                        '\"'            |
                        'add'           |
                        '\"'            |
                        ')'
                    ->
                    Node
                        'add'
                        '('
                        'add'           |   # labeled string
                        ')'

            Does not recurse
            
            Case: # TestParseDefaultBuildingBlocks.test_ruleStringSimple_Integration04
                "test 'test'" 
                ->
                Node
                    'test'
                    ' '
                    '\''                | Convert
                    'test'              |
                    '\''                |
                ->
                Node
                    'test'
                    ' '
                    "test"              | string

            Case: # TestParseDefaultBuildingBlocks.test_ruleStringSimple_Integration05
                "\'test\n\\\'test\\\'\'\ntest" 
                ->
                Node
                    '\''                | Convert
                    'test'              |
                    '\n'                |
                    '\\'                |
                    '\''                |
                    'test'              |
                    '\\'                |
                    '\''                |
                    '\''                |
                    '\n'
                    'test'
                ->
                Node
                    "test\n\\\'test\\\'"| string
                    '\n'
                    'test'

            Case: # TestParseDefaultBuildingBlocks.test_ruleStringSimple_Integration06
                "\'test\n\'test\'\'\ntest" 
                ->
                Node
                    '\''                | Convert
                    'test'              |
                    '\n'                |
                    '\''                |
                    'test'
                    '\''                | Convert
                    '\''                |
                    '\n'
                    'test'
                ->
                Node
                    "test\n"            | string
                    "test"
                    ""                  | string
                    "\n"
                    "test"

            Case: # TestParseDefaultBuildingBlocks.test_ruleStringSimple_Integration07
                "test1\"abc\'123\'abc\"test2" 
                ->
                Node
                    'test1'
                    '\"'                | Convert
                    'abc'               |
                    '\''                |
                    '123'               |
                    '\''                |
                    'abc'               |
                    '\"'                |
                    'test2'
                ->
                Node
                    "test1"
                    "abc\'123\'abc"     | string
                    "test2"

            Case: # TestParseDefaultBuildingBlocks.test_ruleStringSimple_Null
                "" 
                ->
                Node
                    None
                ->
                Node
                    None
            """

            assert type(tree) is self.Node

            root : ParseNode = tree.copyInfo()
            string : str = ""

            stack : str = None
            lineNum : int = None
            charNum : int = None

            '''Finite State Machine
            State 0 # Looking for an opening quote
            State 1 # Looking for a closing quote
            Edge 0 -> 0 iff token != quote: append node to root
            Edge 0 -> 1 iff token == quote: setup looking for closing quote
            Edge 1 -> 1 iff token != quote: append string with token
            Edge 1 -> 0 iff token == quote: copy string to node, append to root
            '''
            i : ParseNode
            for i in tree.child:
                if stack == None: # the 'looking for an opening quote' State 0
                    if i != "\"" and i != "\'": # Edge 0 -> 0
                        root.append(i.copyDeep())
                    if i == "\"" or i == "\'":
                        if i.nodePrevious != "\\": # Edge 0 -> 1
                            stack = i.token
                            lineNum = i.lineNum
                            charNum = i.charNum
                        elif i.nodePrevious == "\\": # Edge 0 -> 0
                            root.append(i.copyDeep())
                elif stack != None: # the 'in a quote' State 1
                    if i != stack: # Edge 1 -> 1
                        string += str(i.token)
                    if i == stack:
                        if i.nodePrevious != "\\": # Edge 1 -> 0
                            temp = self.Node("string", string, lineNum, charNum)
                            root.append(temp)

                            stack = None
                            lineNum = None
                            charNum = None
                            string = ""
                        elif i.nodePrevious == "\\": # Edge 1 -> 1
                            string += str(i.token)

            if stack != None: #TODO handle mis-matched quotes
                raise Exception("Parse Error: Mismatched quotes")

            return root

        def ruleFilterLineComments(self, tree : ParseNode, character : str = "#") -> ParseNode:
            """Takes in a Node Tree of depth 2, removes any tokens between a "#" token and a new line token. Returns a Node Tree of depth 2.

            Does not recurse

            #TODO allow for alternate escape characters

            Case: # TestParseDefaultBuildingBlocks.test_ruleFilterLineComments_Integration03
                "test #test\n #test\n\t\\#test" 
                ->
                Node
                    'test'
                    ' '
                    '#'                 | comment
                    'test'              |
                    '\n'
                    ' '
                    '#'                 | comment
                    'test'              |
                    '\n'
                    '\t'
                    '\\'
                    '#'
                    'test'
                -> 
                "test \n \n\t\\#test" 
                ->
                Node
                    'test'
                    ' '                 _V_
                    '\n'                 A
                    ' '                 _V_
                    '\n'                 A
                    '\t'
                    '\\
                    '#'
                    'test'
            
            Case: # TestParseDefaultBuildingBlocks.test_ruleFilterLineComments_Integration04
                "test test \\# test #abc abc abc \\n abc \n test test" 
                ->
                Node
                    'test'
                    ' '
                    'test'
                    ' '
                    '\\'
                    '#'
                    ' '
                    'test'
                    ' '
                    '#'                 | comment
                    'abc'               |
                    ' '                 |
                    'abc'               |
                    ' '                 |
                    'abc'               |
                    ' '                 |
                    '\\'                |
                    'n'                 |
                    ' '                 |
                    'abc'               |
                    ' '                 |
                    '\n'
                    ' '
                    'test'
                    ' '
                    'test'
                ->
                Node
                    'test'
                    ' '
                    'test'
                    ' '
                    '\\'
                    '#'
                    ' '
                    'test'
                    ' '                 _V_
                    '\n'                 A
                    ' '
                    'test'
                    ' '
                    'test'
            """

            assert type(tree) is self.Node
            assert type(character) is str 
            assert len(character) == 1

            root : ParseNode = tree.copyInfo()

            stack : str = None

            '''Finite State Machine
            State 0: Looking for comment begin
            State 1: Looking for comment end
            0 -> 0 iff token != # : append token to root
            0 -> 1 iff token == # : setup looking for \n
            1 -> 1 iff token != \n : do nothing
            1 -> 0 iff token == \n : append \n to root
            '''
            i : ParseNode
            for i in tree.child:
                if stack == None:
                    if i != character:
                        root.append(i.copyDeep())
                    elif i == character:
                        if i.nodePrevious != "\\":
                            stack = character
                        elif i.nodePrevious == "\\":
                            root.append(i.copyDeep())
                elif stack != None:
                    if i != "\n":
                        pass
                    elif i == "\n":
                        if i.nodePrevious != "\\":
                            stack = None
                            root.append(i.copyDeep())
                        elif i.nodePrevious == "\\":
                            pass

            return root

        def ruleContainer(self, tree : ParseNode, containers : dict[str, str] = {"(":")", "[":"]", "{":"}"}, nodeType : str | None = "container") -> ParseNode:
            """Takes in a Node Tree of depth 2, finds containers "([{}])" and rearranges nodes to form a tree respecting the containers. Returns a Node Tree of arbitrary depth.

            Containers are of the form {"opening bracket" : "closing bracket", ...}
            Does not copy closing brackets
            Does not recurse

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_NestedContainers01
                '[Hello {World}]'
                ->
                containers = {"(":")", "[":"]", "{":"}"} = Default
                nodeType = 'container' = Default
                Node
                    '['                 A
                    'Hello'             |
                    ' '                 |
                    '{'                 |   A
                    'World'             |   |
                    '}'                 |   V
                    ']'                 V
                ->
                Node
                    '['                 A
                        'Hello'         |
                        ' '             |
                        '{'             |   A
                            'World'     V   V

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_integration02
                'test[abc abc{123 123}{456 456}](abc)'
                ->
                containers = {"(":")", "[":"]", "{":"}"} = Default
                nodeType = 'container' = Default
                Node
                    'test'
                    '['                 A
                    'abc'               |
                    ' '                 |
                    'abc'               |
                    '{'                 |   A
                    '123'               |   |
                    ' '                 |   |
                    '123'               |   |
                    '}'                 |   V
                    '{'                 |   A
                    '456'               |   |
                    ' '                 |   |
                    '456'               |   |
                    '}'                 |   V
                    ']'                 V
                    '('                 A
                    'def'               |
                    ')'                 V
                ->
                Node
                    'test'
                    '['                 A
                        'abc'           |
                        ' '             |
                        'abc'           |
                        '{'             |   A
                            '123'       |   |
                            ' '         |   |
                            '123'       |   V
                        '{'             |   A
                            '456'       |   |
                            ' '         |   |
                            '456'       V   V
                    '('                 A
                        'def'           V

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_SimpleContainerCustomContainer02
                'a b c d 1 2 3 4'
                ->
                containers = {"a" : "4", "c" : "2"}
                nodeType = 'container' = Default
                Node
                    'a'                 A
                    ' '                 |
                    'b'                 |
                    ' '                 |
                    'c'                 |   A
                    ' '                 |   |
                    'd'                 |   |
                    ' '                 |   |
                    '1'                 |   |
                    ' '                 |   |
                    '2'                 |   V
                    ' '                 |
                    '3'                 |
                    ' '                 |
                    '4'                 V
                ->
                Node
                    'a'                 A
                        ' '             |
                        'b'             |
                        ' '             |
                        'c'             |   A
                            ' '         |   |
                            'd'         |   |
                            ' '         |   |
                            '1'         |   |
                            ' '         |   V
                        ' '             |
                        '3'             |
                        ' '             V

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_integration04
                '1 a b c 2'
                ->
                containers = {'1' : '2'} = Default
                nodeType = 'container' = Default
                Node
                    '1'                 A   # labeled 'number'
                    ' '                 |
                    'a'                 |
                    ' '                 |
                    'b'                 |
                    ' '                 |
                    'c'                 |
                    ' '                 |
                    '2'                 V
                ->
                Node
                    '1'                 A   # labeled 'container'
                        ' '             |
                        'a'             |
                        ' '             |
                        'b'             |
                        ' '             |
                        'c'             |
                        ' '             V

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_integration05
                '1 a b c 2'
                ->
                containers = {'1' : '2'} = Default
                nodeType = None
                Node
                    '1'                 A   # labeled 'number'
                    ' '                 |
                    'a'                 |
                    ' '                 |
                    'b'                 |
                    ' '                 |
                    'c'                 |
                    ' '                 |
                    '2'                 V
                ->
                Node
                    '1'                 A   # labeled 'number'
                        ' '             |
                        'a'             |
                        ' '             |
                        'b'             |
                        ' '             |
                        'c'             |
                        ' '             V

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_ExceptionContainerMismatch01
                # Will raise Exception 'ParserError' when an opening bracket is not closed
                '[Hello'
                ->
                containers = {"(":")", "[":"]", "{":"}"} = Default
                nodeType = 'container' = Default
                Node
                    '['                 |
                    'Hello'
                ->
                Raises Exception 'ParserError'

            Case: # TestParseDefaultBuildingBlocks.test_ruleContainer_ExceptionContainerMismatch02
                # Will raise Exception 'ParserError' when a closing bracket is not opened
                ']Hello'
                ->
                containers = {"(":")", "[":"]", "{":"}"} = Default
                nodeType = 'container' = Default
                Node
                    ']'                 |
                    'Hello'
                ->
                Raises Exception 'ParserError'
            """

            assert type(tree) is self.Node
            assert type(containers) is dict
            assert len(containers) >= 1
            assert all([True if type(i) is str else False for i in containers.keys()])
            assert all([True if type(containers[i]) is str else False for i in containers.keys()])
            # cantainer tokens can be of len >= 1, as this function is compairing tokens, and not characters in a string
            # assert all([True if len(i) == 1 else False for i in containers.keys()])
            # assert all([True if len(containers[i]) == 1 else False for i in containers.keys()])
            assert all([True if containers[i] != i else False for i in containers.keys()]) # asserts that the 'matching bracket' isn't the same characters
            assert all([all([True if containers[i] != j else False for j in containers.keys()]) for i in containers.keys()]) # asserts that the 'closing bracket' isn't an 'opening bracket'
            assert type(nodeType) is str or type(nodeType) is type(None)

            root : ParseNode = tree.copyInfo()
            stack : list[tuple[str, ParseNode]] = []

            i : ParseNode
            for i in tree.child:
                '''
                if openbracket
                    append to stack
                if closing bracket on stack
                    pop from stack
                    append to root
                else
                    if len(stack) == 0
                        append to root
                    else
                        append to last element in stack
                '''
                if i.token in list(containers.keys()): # if open bracket
                    # append to stack
                    temp : ParseNode = i.copyDeep()
                    if nodeType != None:
                        temp.type = nodeType
                    else:
                        temp.type = i.type
                    stack.append((i.token, temp))
                elif len(stack) != 0:
                    if containers[stack[-1][0]] == i.token: # if closing bracket
                        temp : ParseNode = stack.pop()[1] # pop from stack

                        if len(stack) != 0: # append to last element in stack, otherwise append to root
                            stack[-1][1].append(temp)
                        else:
                            root.append(temp)
                    else: # not container, append to last element in stack
                        stack[-1][1].append(i.copyDeep())
                else: # not container, append to last element in stack, otherwise append to root
                    if len(stack) == 0:
                        root.append(i.copyDeep())
                    else:
                        stack[-1][1].append(i.copyDeep())

            if len(stack) != 0:
                raise ParserError("Parse Error: mismatching brackets")

            return root

        def ruleFindLabels(self, tree : ParseNode) -> tuple[ParseNode, dict[str, ParseNode]]:
            """Takes in a Node Tree of depth 2, attempts to find a label that is immidiatly followed by a ":", returns a Node Tree of depth 2, and a dictionary of labels
            
            Does not recurse"""

            assert type(tree) is self.Node

            root : ParseNode = tree.copyInfo()
            previous : str = "\n"
            skipToken : bool = False

            labels : dict[str, ParseNode] = {}

            i : ParseNode
            for i in tree.child:
                if (i.nodePrevious == previous or i.nodePrevious == None) and i.nodeNext == ":":
                    temp : ParseNode = i.copyDeep()
                    temp.type = "label"
                    root.append(temp)

                    labels[i.token] = temp.copyInfo()

                    previous = i.token
                    skipToken = True
                elif skipToken == True:
                    skipToken = False
                else:
                    root.append(i.copyDeep())
                    previous = i.token

            return (root, labels)

        def ruleLabelNamespace(self, tree : ParseNode, nameSpace : dict[str, NameSpaceObject]) -> ParseNode:
            """Takes in a node tree, and a nameSpace. Labels all nodes that are in nameSpace as 'NameSpace'. Returns Node Tree of depth 2.
            
            Does not recurse
            """

            assert type(tree) is self.Node
            assert type(nameSpace) is dict
            #TODO assert that all keys are strings
            #TODO assert that all values are NameSpaceObjects?

            root : ParseNode = tree.copyInfo()
            keys : list[str] = [i.lower() for i in nameSpace.keys()]

            i : ParseNode
            for i in tree.child:
                if type(i.token) is str:
                    if i.token.lower() in keys:
                        temp : ParseNode = i.copyDeep()
                        temp.type = f"NameSpace-{nameSpace[i.token.lower()].type}"
                        root.append(temp)
                    else:
                        root.append(i.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root
        
        def ruleRemoveToken(self, tree : ParseNode, token : Any, recurse : bool = True) -> ParseNode:
            """Takes in a Node Tree of arbitrary depth, and a token. Removes all instances of token in tree.child. Will remove children of token. Returns a Node Tree of arbitrary depth.
            
            Case 1: # TestParseDefaultBuildingBlocks.test_ruleRemoveToken_Integration03
                "test1\ntest2"
                ->
                token = '\n'
                Node
                    'test1'
                    '\n'                | Removed
                    'test2'
                ->
                Node
                    'test1'             _V_
                    'test2'              A

            Case 2: # TestParseDefaultBuildingBlocks.test_ruleRemoveToken_Integration04
                'add(arg1,arg2),mult(arg1,arg2)'
                -> some parsing later (containerization, arg folding, etc)
                token = ','
                Node
                    'add'
                        'arg1'
                        ','             | Removed
                        'arg2'
                    ','                 | Removed
                    'mult'
                        'arg1'
                        ','             | Removed
                        'arg2'
                ->
                Node
                    'add'
                        'arg1'          _V_
                        'arg2'           A _V_
                    'mult'                  A
                        'arg1'          _V_
                        'arg2'           A

            Case 3: # TestParseDefaultBuildingBlocks.test_ruleRemoveToken_Integration06
                'a[1,2,3],b[1,2,3],c[1,b,3]' (brackets are not removed, but are folded in as children)
                ->
                token = 'b'
                Node
                    a
                        [
                        1
                        ,
                        2
                        ,
                        3
                        ]
                    ,
                    b                   | Removed
                        [               | Children are also removed
                        1               |
                        ,               |
                        2               |
                        ,               |
                        3               |
                        ]               |
                    ,
                    c
                        [
                        1
                        ,
                        b               | Removed
                        ,
                        3
                        ]
                ->
                Node
                    a
                        [
                        1
                        ,
                        2
                        ,
                        3
                        ]
                    ,                   _V_
                    ,                    A
                    c
                        [
                        1
                        ,               _V_
                        ,                A
                        3
                        ]
            """

            assert type(tree) is self.Node
            assert type(recurse) is bool
            
            root : ParseNode = tree.copyInfo()

            i : ParseNode
            for i in tree.child:
                if i != token:
                    root.append(i.copyDeep())

            if recurse:
                newRoot : ParseNode = tree.copyInfo()
                i : ParseNode
                for i in root.child:
                    newRoot.append(self.ruleRemoveToken(i.copyDeep(), token, True))
                root = newRoot

            return root
        
        def ruleSplitLines(self, tree : ParseNode, tokenType : str = "line", splitToken : str = "\n") -> list[ParseNode]:
            """Takes in a Node Tree of arbitrary depth. Returns a list of Node Trees of arbitrary depth, split by the splitToken (default "\n") with the splitToken ommited. Does not recurse.
            
            #TODO should be able to recurse

            Case 1: # TestParseDefaultBuildingBlocks.test_ruleSplitLines_Integration01
                "Hello World"
                ->
                splitToken = '\n'
                Node                    | This node is not carried over
                    'Hello'
                    ' '
                    'World'
                ->
                [
                    Node                | New container node
                        'Hello'
                        ' '
                        'World'
                ]

            Case 2: # TestParseDefaultBuildingBlocks.test_ruleSplitLines_Integration02
                "test1\ntest2"
                ->
                splitToken = '\n'
                Node
                    'test1'
                    '\n'                | To split
                    'test2'
                ->
                [
                    Node                | New container node
                        'test1'
                    ,                   | splitToken is removed
                    Node                | New container node
                        'test2'
                ]

            Case 3: # TestParseDefaultBuildingBlocks.test_ruleSplitLines_Integration05
                "[test1]\t[test2\ttest3]"
                ->
                splitToken = '\t'
                Node
                    Node
                        'test1'
                    '\t'                | To split
                    Node
                        'test2'
                        '\t'            | Will not split, because nested
                        'test3'
                ->
                [
                    Node                | New container node
                        Node
                            'test1'
                    Node                | New container node
                        Node
                            'test2'
                            '\t'        | Not Removed
                            'test3'
                ]

            """

            assert type(tree) is self.Node
            assert type(tokenType) is str
            assert type(splitToken) is str
            assert len(splitToken) != 0

            result : list[ParseNode] = []
            current : ParseNode = self.Node(tokenType, None, 0, 0)

            i : ParseNode
            for i in tree.child:
                if i == splitToken:
                    result.append(current)
                    current = self.Node(tokenType, None, 0, 0)
                else:
                    current.append(i.copyDeep())

            if len(current.child) >= 1:
                result.append(current)

            # Goes through all 'lines' and sets lineNum and charNum to the values of the first child Node in them
            i : ParseNode
            for i in result:
                if len(i.child) != 0:
                    i.lineNum = i.child[0].lineNum
                    i.charNum = i.child[0].charNum

            return result

        def ruleSplitTokens(self, tree : ParseNode, tokenType : str = "line", splitToken : str = "\n", recurse : bool = True) -> ParseNode:
            """Takes in a Node Tree of arbitrary depth. Returns a Node Trees of arbitrary depth, split by the splitToken ("\n") with the splitToken ommited, and in containers. Will recurse (default).

            Case 1: # TestParseDefaultBuildingBlocks.test_ruleSplitTokens_Integration03
                "test\nabc"
                ->
                splitToken = "\n"
                Node
                    'test'
                    '\n'                | To Split
                    'abc'
                ->
                Node
                    None
                        'test'          _V_  notice the splitToken '\n' is omitted
                    None                 A
                        'abc' 

            Case 2: # TestParseDefaultBuildingBlocks.test_ruleSplitTokens_Integration04
                "test1 test2[abc1,abc2,abc3 abc4]"
                ->
                splitToken = ','
                recurse = True
                Node
                    'test1'
                    ' '
                    'test2'
                        'abc1'
                        ','             | To Split
                        'abc2'
                        ','             | To Split
                        'abc3'
                        ' '
                        'abc4'
                ->
                Node
                    'test1'
                    ' '
                    'test2'
                        None
                            'abc1'      _V_
                        None             A
                            'abc2'      _V_
                        None             A
                            'abc3'
                            ' '
                            'abc4'
            
            Case 3: # TestParseDefaultBuildingBlocks.test_ruleSplitTokens_Integration06
                "test1[abc1,abc2],test2"
                ->
                splitToken = ','
                recurse = True
                Node
                    'test1'
                        'abc1'
                        ','             | To Split
                        'abc2'
                    ','                 | To Split
                    'test2'
                ->
                Node
                    None
                        'test1'
                            None
                                'abc1'  _V_
                            None         A
                                'abc2'  _V_
                    None                 A
                        'test2'

            Case 4: # TestParseDefaultBuildingBlocks.test_ruleSplitTokens_Integration08
                "test1 test2 test3"
                ->    
                splitToken = '\n'
                Node
                    'test1'
                    ' '
                    'test2'
                    ' '
                    'test3'
                ->
                Node                    | Notice how containers are NOT created if splitToken is not found
                    'test1'
                    ' '
                    'test2'
                    ' '
                    'test3'
            """

            assert type(tree) is self.Node
            assert type(tokenType) is str
            assert len(tokenType) > 0
            assert type(splitToken) is str
            assert len(splitToken) > 0
            assert type(recurse) is bool

            logging.debug(debugHelper(inspect.currentframe()) + "\n" + str(tree))
            root : ParseNode = tree.copyInfo()
            tokenFound : bool = False

            # checks if there is a splitToken in children
            i : ParseNode
            for i in tree.child:
                if i == splitToken:
                    tokenFound = True
            logging.debug(debugHelper(inspect.currentframe()) + "tokenFound=\t" + str(tokenFound))

            if tokenFound:
                stack : list[ParseNode] = []
                i : ParseNode
                for i in tree.child:
                    if i == splitToken:
                        logging.debug(debugHelper(inspect.currentframe()) + str(stack))
                        temp : ParseNode = self.Node(tokenType, None, stack[0].lineNum, stack[0].charNum)
                        while len(stack) != 0:
                            temp.append(stack.pop(0))
                        root.append(temp)
                    else:
                        # stack.append(self.ruleSplitTokens(i.copyDeep(), tokenType, splitToken, recurse) if recurse else i.copyDeep())
                        temp : ParseNode = None
                        if recurse:
                            temp = self.ruleSplitTokens(i.copyDeep(), tokenType, splitToken, recurse)
                        else:
                            temp = i.copyDeep()
                        stack.append(temp)

                if len(stack) != 0:
                    temp : ParseNode = self.Node(tokenType, None, stack[0].lineNum, stack[0].charNum)
                    while len(stack) != 0:
                        temp.append(stack.pop(0))
                    root.append(temp)
                    
            else: # the splitToken not found case
                i : ParseNode
                for i in tree.child:
                    temp : ParseNode = None
                    if recurse:
                        temp = self.ruleSplitTokens(i.copyDeep(), tokenType, splitToken, recurse)
                    else:
                        temp = i.copyDeep()
                    root.append(temp)
            
            return root

        def ruleNestContainersIntoInstructions(self, tree : ParseNode, nameSpace : dict[str, NameSpaceObject], recurse : bool = True) -> ParseNode: 
            #TODO rename, as nameSpace is more generic then just 'instruction'
            """Takes in a Node Tree of arbitrary depth, and a nameSpace dict represeting instructions, registers, etc. 
            If a container node follows a nameSpace node, make container node a child of the nameSpace node.
            Returns a Node Tree of arbitrary depth.

            Recurses by default            
            """

            assert type(tree) is self.Node
            assert type(nameSpace) is dict
            
            logging.debug(debugHelper(inspect.currentframe()) + "EnterFunction \n" + str(tree))
            root : ParseNode = tree.copyInfo()

            i : ParseNode
            for i in tree.child:
                logging.debug(debugHelper(inspect.currentframe()) + "i \n" + str(i))
                if i.type == "container":  
                    temp : ParseNode = None
                    if recurse:
                        temp = self.ruleNestContainersIntoInstructions(i.copyDeep(), nameSpace, True)
                    else:
                        temp = i
                    logging.debug(debugHelper(inspect.currentframe()) + "temp \n" + str(temp))

                    if type(i.nodePrevious) is self.Node: # IE: the node exists
                        if i.nodePrevious.token in nameSpace:
                            root.child[-1].append(temp.copyDeep())
                        else:
                            root.append(temp.copyDeep())
                    else:
                        root.append(temp.copyDeep())
                else:
                    root.append(i.copyDeep())

            return root

        def ruleLowerCase(self, tree : ParseNode, recurse : bool = True) -> ParseNode:
            """Takes in a Node Tree of arbitrary depth. Sets all tokens in the Node Tree's children as lower case. Recurses by default. Returns a Node Tree of arbitrary depth.
            
            Case 1: # TestParseDefaultBuildingBlocks.test_ruleLowerCase_Integration02
                "Hello World"
                ->
                Recurse = False
                Node
                    'Hello'             |
                    ' '
                    'World'             |
                ->
                Node
                    'hello'             |
                    ' '
                    'world'             |

            Case 2: # TestParseDefaultBuildingBlocks.test_ruleLowerCase_Integration03
                "Hello World[ABC 123]"
                ->
                Recurse = False
                Node
                    'Hello'             |
                    ' '
                    'World'             |
                        'ABC'
                        ' '
                        '123'
                ->
                Node
                    'hello'             |
                    ' '
                    'world'             |
                        'ABC'           # Notice this is not changed
                        ' '
                        '123'

            Case 3: # TestParseDefaultBuildingBlocks.test_ruleLowerCase_Integration04
                "Hello World[ABC 123]"
                ->
                Recurse = True
                Node
                    'Hello'             |
                    ' '
                    'World'             |
                        'ABC'           |
                        ' '
                        '123'
                ->
                Node
                    'hello'             |
                    ' '
                    'world'             |
                        'abc'           |
                        ' '
                        '123'

            """

            assert type(tree) is self.Node
            assert type(recurse) is bool

            root : ParseNode = tree.copyInfo()
            i : ParseNode
            for i in tree.child:
                temp : ParseNode = i.copyDeep()
                if type(temp.token) is str:
                    temp.token = temp.token.lower()
                if recurse:
                    temp = self.ruleLowerCase(temp, True)
                root.append(temp)
            
            return root

        def ruleApplyAlias(self, tree : ParseNode, alias : dict[str, str]) -> ParseNode:
            """Takes in a Node Tree of Depth 2. If a token is in alias, replaces that token, then tokenizes it. Returns a Node Tree of Depth 2.
            
            Case 1: alias = {'123': 'hello world'}
            Node
                'test'
                ' '
                '123'                   |
                ' '
                'abc'
            =>
            Node
                'test'
                ' '
                'hello'                 | #notice how the string 'hello world' was tokenized
                ' '                     |
                'world'                 |
                ' '
                'abc'
            
            Case 2: alias = {'abc' : '1 2 3'}
            Node
                'test'
                ' '
                'abc'                   |
                    'hello'             |
                    ' '                 |
                    'world'             |
                ' '
                'temp
            =>
            Node
                'test'
                ' '
                '1'                     | #notice how the children of 'abc' was added to the first of the replacement nodes
                    'hello'             |
                    ' '                 |
                    'world'             |
                ' '                     |
                '2'                     |
                ' '                     |
                '3'                     |
                ' '
                'temp'
            """

            assert type(tree) is self.Node
            assert type(alias) is dict
            assert all([type(i) is str for i in alias.keys()])
            assert all([type(i) is str for i in alias.values()])
            assert all([i != j for i, j in alias.items()])

            root : ParseNode = tree.copyInfo()

            i : ParseNode
            for i in tree.child:
                temp : list[ParseNode] = []
                if type(i.token) is str and i.token in alias: #if alias token found, tokenize it's replacement string, and add that series of tokens to root
                    j : tuple[str, int, int]
                    for j in self.tokenize(alias[i.token]):
                        temp.append(self.Node("token", j[0], i.lineNum, i.charNum))
                else:
                    temp.append(i.copyInfo())

                j : ParseNode
                for j in i.child: #if alias token has children, add children to first token of the replacement tokens
                    temp[0].append(j.copyDeep)
                
                #append tokens to root
                j : ParseNode
                for j in temp:
                    root.append(j)

            return root

        def ruleFilterContainerKeepChildren(self, tree : ParseNode, filterTokens : list[Any]) -> ParseNode:
            """Takes in a Node Tree of arbitrary depth, recursivly removes any tokens in token (containers) while keeping children. Returns a Node Tree.

            Example 01: 
                    "add(r[0], r[1], r[2])" 
                ->
                    Node
                        add
                            (
                                r
                                    [
                                        0
                                r
                                    [
                                        1
                                r
                                    [
                                        2
                -> token = ["(", "["]
                    Node
                        add
                            r
                                0
                            r
                                1
                            r
                                2

            Example 02:
                    "add(r[0], (r[1], r[2]))"
                ->
                    Node
                        add
                            (
                                r
                                    [
                                        0
                                (
                                    r
                                        [
                                            1
                                    r
                                        [
                                            2
                -> token = ["(", "["]
                    Node
                        add
                            r
                                0
                            None                                                | # Notice how the container was replaced with 'None', in order to maintain the structure of the tree
                                r                                               |
                                    1                                           |
                                r                                               |
                                    2                                           |
            
            """

            assert type(tree) is self.Node
            assert type(filterTokens) is list
            assert len(filterTokens) > 0

            root : ParseNode = tree.copyInfo()

            ''' # rough algorithm
            if tree.child == None:
                return tree
            if len(tree.child) == 1:
                if tree.child is container:
                    delete child, children of child become children of tree
            if len(tree.child) > 1:
                if tree.child is container:
                    child token set to None
            recurse on all tree.child
            '''
            children : list[ParseNode] = []
            if tree.child == None:
                pass
            if len(tree.child) == 1:
                if tree.child[0].token in filterTokens:
                    i : ParseNode
                    for i in tree.child[0].child:
                        children.append(i.copyDeep())
                else:
                    children.append(tree.child[0].copyDeep())
            if len(tree.child) > 1:
                i : ParseNode
                for i in tree.child:
                    if i.token in filterTokens:
                        temp = i.copyDeep()
                        temp.token = None
                        children.append(temp)
                    else:
                        children.append(i.copyDeep())

            i : ParseNode
            for i in children:
                root.append(self.ruleFilterContainerKeepChildren(i, filterTokens))
            
            return root

        def parseCode(self, sourceCode : str) -> tuple[ParseNode, dict[str, ParseNode]]:
            """Takes a string of source code, returns a parsed instruction tree and a dictionary representing labels/pointers
            
            Takes source code of the form:
                #This is a comment, non-functional example code
                label1:     add(r[0],r[0],r[0])
                            and(r[1],r[2],r[0]) #Another comment
                label2:     jump(label1)
            Returns:
                None                                                            :Root           1       lineNum=None    charNum=None
                    None                                                        :Line           2       lineNum=2       charNum=31
                        'add'                                                   :Namespace      3       lineNum=2       charNum=31
                            '('                                                 :Container      4       lineNum=2       charNum=31
                                None                                            :Argument       5       lineNum=2       charNum=33
                                    'r'                                         :Namespace      6       lineNum=2       charNum=33
                                        '['                                     :Container      7       lineNum=2       charNum=33
                                            0                                   :Int            8       lineNum=2       charNum=35
                                None                                            :Argument       5       lineNum=2       charNum=38
                                    'r'                                         :Namespace      6       lineNum=2       charNum=38
                                        '['                                     :Container      7       lineNum=2       charNum=38
                                            0                                   :Int            8       lineNum=2       charNum=40
                                None                                            :Argument       5       lineNum=2       charNum=43
                                    'r'                                         :Namespace      6       lineNum=2       charNum=43
                                        '['                                     :Container      7       lineNum=2       charNum=43
                                            0                                   :Int            8       lineNum=2       charNum=45
                    None                                                        :Line           2       lineNum=3       charNum=31
                        'and'                                                   :Namespace      3       lineNum=3       charNum=31
                            '('                                                 :Container      4       lineNum=3       charNum=31
                                None                                            :Argument       5       lineNum=3       charNum=33
                                    'r'                                         :Namespace      6       lineNum=3       charNum=33
                                        '['                                     :Container      7       lineNum=3       charNum=33
                                            1                                   :Int            8       lineNum=3       charNum=35
                                None                                            :Argument       5       lineNum=3       charNum=38
                                    'r'                                         :Namespace      6       lineNum=3       charNum=38
                                        '['                                     :Container      7       lineNum=3       charNum=38
                                            2                                   :Int            8       lineNum=3       charNum=40
                                None                                            :Argument       5       lineNum=3       charNum=43
                                    'r'                                         :Namespace      6       lineNum=3       charNum=43
                                        '['                                     :Container      7       lineNum=3       charNum=43
                                            0                                   :Int            8       lineNum=3       charNum=45
                    None                                                        :Line           2       lineNum=4       charNum=32
                        'jump'                                                  :Namespace      3       lineNum=4       charNum=32
                            '('                                                 :Container      4       lineNum=4       charNum=32
                                'label1'                                        :Token          5       lineNum=4       charNum=39

                Dict
                    "label1"    :   0
                    "label2"    :   2
            """

            assert type(sourceCode) is str

            labels : dict = None
            
            # tokenizes sourceCode, and turns it into a Node Tree
            root : ParseNode = self.Node("root")
            token : str
            lineNum : int
            charNum : int
            for token, lineNum, charNum in self.tokenize(sourceCode):
                root.append(self.Node("token", token, lineNum, charNum))

            logging.debug(debugHelper(inspect.currentframe()) + "this is the original code: " + "\n" + repr(sourceCode))
            logging.debug(debugHelper(inspect.currentframe()) + "tokenized code: " + "\n" + str(root))

            # Note: at this point, rules do operations on the Node Tree, but the depth of the Node Tree remains 2

            root = self.ruleFilterLineComments(root, "#")
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFilterLineComments: " + "\n" + str(root))

            root = self.ruleStringSimple(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleStringSimple: " + "\n" + str(root))

            root = self.ruleLowerCase(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleLowerCase: " + "\n" + str(root))            

            root = self.ruleRemoveLeadingWhitespace(root, [" ", "\t"])
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveLeadingWhitespace: " + "\n" + str(root))

            root = self.ruleRemoveEmptyLines(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveEmptyLines: " + "\n" + str(root))

            root, labels = self.ruleFindLabels(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFindLabels: " + "\n" + str(root) + "\nlabels: " + str(labels))
            i : int = 0
            while i < len(root.child): # removes the label nodes, as they don't need to be executed
                if root.child[i].type == "label":
                    root.remove(root.child[i])
                else:
                    i += 1
            
            root = self.ruleLabelNamespace(root, self.nameSpace)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleLabelNamespace: " + "\n" + str(root))

            root = self.ruleRemoveToken(root, " ", False)
            root = self.ruleRemoveToken(root, "\t", False)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleRemoveToken: " + "\n" + str(root))

            root = self.ruleCastInts(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleCastInts: " + "\n" + str(root))

            root = self.ruleCastHex(root)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleCastHex: " + "\n" + str(root))

            # This is where the Node Tree is allowed to go to depth > 2
            root = self.ruleContainer(root, {"(":")", "[":"]"})
            logging.debug(debugHelper(inspect.currentframe()) + "ruleContainer: " + "\n" + str(root))

            # This will roll containers trailing a namespace object into a child of namespace object
            filteredNameSpace : dict[NameSpaceObject] = {}
            i : str
            j : NameSpaceObject
            for i, j in self.nameSpace.items():
                if j.type in ["instruction", "directive", "registerBank", "registerAlias"]:
                    filteredNameSpace[i] = j
            root = self.ruleNestContainersIntoInstructions(root, filteredNameSpace, True)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleNestContainersIntoInstructions: " + "\n" + str(root))

            temp : list[ParseNode] = self.ruleSplitLines(root, "line", "\n")
            root = self.Node("root")
            i : ParseNode
            for i in temp:
                root.append(i)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleSplitLines: " + "\n" + str(root))

            # removes empty lines/empty line nodes
            i : int = 0
            while i < len(root.child):
                if len(root.child[i].child) == 0:
                    root.remove(root.child[i])
                else:
                    i += 1
            logging.debug(debugHelper(inspect.currentframe()) + "remove empty line nodes: " + "\n" + str(root))

            root = self.ruleSplitTokens(root, "argument", ',', True)
            logging.debug(debugHelper(inspect.currentframe()) + "ruleSplitTokens: " + "\n" + str(root))

            root = self.ruleFilterContainerKeepChildren(root, ["[", "("])
            logging.debug(debugHelper(inspect.currentframe()) + "ruleFilterContainerKeepChildren: " + "\n" + str(root))

            return root, labels

    class MMMUDefault:
        """
        MMMU requirements:
            Modular Meta Memory Managment Unit
            Must be able to support multiple cache pools
                Must allow modification of pools (adding pools, resizing pools, changing algorithm of pools)
            Must allow for memory 'versioning'. IE: an instruction is pipelined, and the memory is 'branched' for that instruction until it's commited or discarded.
            Must allow for different algorithms to be used for moving/caching data between pools.
                IE: L3 is an eviction cache, L1D is for data cache, L1I is for instructions cache, L2 uses round robin, etc...
            Figure out weather it should be accessable as though it's a single large multidimensional python dictionary
                It's probably better if that memory is accessed through a function instead of moving around massive arrays of diplicate data with each instruction call...
                will be harder to learn to use if not implimented properly
            Will require rewriting self.config and everything that goes with it

        Terminoligy: #Because damnit I'll confuse myself if I don't put time into naming things right
            Registers - Generic term used for Memory Elements that are registers implying most instructionSet instruction interact directly with these Memory Elements
            Memory - Generic term used for Memory Elements that are not registers implying most instructionSet instructions can't directly access them
            Transparient - Memory Elements that is directly addressable and accessable from an instruction context (EX: reading from DRAM)
            Opauqe - Memory Elements that are not directly addressable and accessable from an instruction context (EX: reading from L2 Cache that then reads from DRAM, L2 Cache is not individually addressable from DRAM)
            Memory Element - One individual memeory unit, comprised of multiple bits. The smallest amount of memory that is uniquely addressable.
            Memory Pool - A collection of memory that shares a similar propertiy (IE: L1 cache). Does not need to have uniquely addressable Memory Elements accessable from 
            Memory Bank - A logical seperation of memory addressing in namespace only. (EX: Registers and Memory might be addressed using 'r' and 'm' as different Memory Banks, but they both reside in the same Memory Pool)
            Special Registers - Special system registers (EX: program counter, immediate registers, program counter Memory Bank pointer, Microcode Registers, etc) which act like regualr registers, but have special functionality and should be treated with attention and care
            HyperThreadContext - Enables processing multiple threads at the same time without causing comflicts accessing Special Registers (the value seen is translated to a value relavent in that context) while still allowing access to the same Memory Pools
                IE:
                    Thread1 -> Special Registers, Registers, L1, DRAM
                    Thread2 -> Special Registers, Registers, L1, DRAM
                    Special Register values are unique to and only accessable by each thread
                    Register values could be unique to and only accessable by each thread, or they could be shared.
                    L1 and DRAM is shared between the threads


        Possible API
            class MMMU
                def __init__

                def createPool
                def configPool
                def connectPool

                class pool                  #handles low level stuff of memory storage elements (IE: DRAM charge levels)
                    def __init__
                        var type
                        var data

                    def readReal            #reads a value, activates all stat tracking functions
                    def writeReal           #writes a value, activates all stat tracking functions
                    def readVirtual         #reads a value without stat tracking, meanly used for the display class, data integrity check, etc
                    def writeVirtual        #wrotes a value without stat tracking, meanly used for overriding an writeReal. (IE: store a value in register R0, but R0 is hardwired to have a value of zero, like in RISCV)
                    def readRaw             #reads a value directly from a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)
                    def writeRaw            #writes a value directly to a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)

                    def config

                    def tick                #should TICK return a random number generator state value, so it can be restored in another branch?

                class poolStack     #TODO
                    def __init__
                        var type
                        var data

                    def readReal            #reads a value, activates all stat tracking functions
                    def writeReal           #writes a value, activates all stat tracking functions
                    def readVirtual         #reads a value without stat tracking, meanly used for the display class, data integrity check, etc
                    def writeVirtual        #wrotes a value without stat tracking, meanly used for overriding an writeReal. (IE: store a value in register R0, but R0 is hardwired to have a value of zero, like in RISCV)
                    def readRaw             #reads a value directly from a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)
                    def writeRaw            #writes a value directly to a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)

                    def config

                    def tick

                class controller            #handles what caching algorithm to use, passes through cache misses, and bufferes IO to slower cache tiers, strictly abstract data handling (IE: reads bindary data from a pool, doesn't read analogue data to process from pool)
                    def __init__

                    def readReal            #reads a value, activates all stat tracking functions
                    def writeReal           #writes a value, activates all stat tracking functions
                    def readVirtual         #reads a value without stat tracking, meanly used for the display class, data integrity check, etc
                    def writeVirtual        #wrotes a value without stat tracking, meanly used for overriding an writeReal. (IE: store a value in register R0, but R0 is hardwired to have a value of zero, like in RISCV)
                    def readRaw             #reads a value directly from a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)
                    def writeRaw            #writes a value directly to a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)

                    def writeEvict          #data from a higher level memory pool gets 'evicted' from that pool, and writen to a lower level cache. 

                    def tick

                    def setPool
                    def setCacheMiss

                class splitter              #handles incoming requists, and routes them to the correct pools/controllers
                    def __init__

                    def readReal            #reads a value, activates all stat tracking functions
                    def writeReal           #writes a value, activates all stat tracking functions
                    def readVirtual         #reads a value without stat tracking, meanly used for the display class, data integrity check, etc
                    def writeVirtual        #wrotes a value without stat tracking, meanly used for overriding an writeReal. (IE: store a value in register R0, but R0 is hardwired to have a value of zero, like in RISCV)
                    def readRaw             #reads a value directly from a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)
                    def writeRaw            #writes a value directly to a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)

                    def writeEvict          #data from a higher level memory pool gets 'evicted' from that pool, and writen to a lower level cache. 

                    def tick

                class externalPassThrough   #used for connected memory pools from other threads into this processor
                    def __init__

                    def readReal            #reads a value, activates all stat tracking functions
                    def writeReal           #writes a value, activates all stat tracking functions
                    def readVirtual         #reads a value without stat tracking, meanly used for the display class, data integrity check, etc
                    def writeVirtual        #wrotes a value without stat tracking, meanly used for overriding an writeReal. (IE: store a value in register R0, but R0 is hardwired to have a value of zero, like in RISCV)
                    def readRaw             #reads a value directly from a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)
                    def writeRaw            #writes a value directly to a pool, without stat tracking, without routing to another pool (IE: L2 cache is Opauqe, but this allows reading of L2 without the request being rerouted to L3)

                    def writeEvict          #data from a higher level memory pool gets 'evicted' from that pool, and writen to a lower level cache. 

                    def tick

                    def connectThread

                class cacheAlgorithm
                    def __init__

                def tick

                def lock                    #locks data reads and writes, allows for passing access to data to another function without requireing a complete copy
                def unlock                  #unlocks data reads and writes
                def fork                    #creates a forked memory version, returns an identifier
                def commit                  #takes an identifier, and commits it to the master copy of memory in all pools
                def trackingOn
                def trackingOff
                def trackingReset           #resets all statistic tracking data

                #Note: reading/writing to oldState and newState should be done with two different versionNodes
                def read(self, virtualOperation : bool, hyperThreadContext, versionNode, poolEntryPoint, shortPath, key, index) -> int
                    This function is passed to the InstructionSet instructions, for reading from memory/registers/pools
                    This function is curried so that only key and index arguments are passed to the instruction
                    Throws an exception if memory element doesn't exist
                def write(self, virtualOperation : bool, hyperThreadContext, versionNode, poolEntryPoint, shortPath, key, index, value) -> None or registerAddress
                    This function is passed to the instructionSet instructions, for writing values to memory/registers/pools
                    The engine should make a wrapper function around this function before passing it to instructionSet instruction to allow for intercepting of writes to imm registers
                    This function is curried so that only key and index arguments are passed to the instruction
                    Throws an exception if memory element doesn't exist

                def writeWrapper(self, hyperThreadContext, versionNode, oldVersionNode, poolEntryPoint, shortPath, key, index, value) -> None or registerAddress #TODO
                    This should be implimented in the engine, not in the memory module
                    just like regular write, only writes to immediate registers are intercepted and written to the previous versionNode
                    Writing to an imm registers adds it to the OLD state, and returns a registerAddress
                        When adding an imm, the imm register generated should have a bitLength only as large as required to store the value (plus one leading to to indicate a positive or negative value)

                def writeWrapper(self, hyperThreadContext, versionNode, oldVersionNode, poolEntryPoint, shortPath, [key, index], value) -> None or registerAddress #TODO
                    This should be implimented in the engine when calling InstructionSet instructions.
                    The [key, index] is a tuple for convinence inside and InstructionSet instruction. Allows passing a register [key, index] without having to manually seperate the values

                def configInfo(key, index) -> dict
                    This function is passed to teh instructionSet instructions, for qurying information on memory elements, see "#register config datastructure"
                    Throws an exception if memory element doesn't exist

                def getmemoryKeys(self, versionNode) -> Tuple(hyperThreadContext, key, index):
                    returns a 'memory map' of all key/index that are being used, does not return stored values of those Memory Elements

                def memoryTransactions(self, versionNode) -> A linked list of memory transactions, tracing data access:
                    returns a list of all memory transactions in the current fork since last TICK

        Use Cases:
            Read data and instruction
                Setup:
                    Registers -> DataL1, InstructionL1
                    DataL1 -> SRAM
                    InstructionL1 -> SRAM
                Reading data and instructions at the same time will cause two consecitive reads in the same tick
                Two different pools connect to SRAM
                Instruction Reads and Data Loads should be treated differently
            CPU Flags
                Setup:
                    Registers -> SRAM
                    Flags -> None
                Must be able to support multiple unconnected pools, like in the case of reading/writing CPU flags
            Spectulative Execution
                Setup:
                    Registers -> SRAM
                Should be able to have a version history of multiple different read/write histories as different branches that can be merged and forked
                Should be able to see which individual memory transactions are taking place, to find out if different InstructionSet instructions are conflicting.
                    IE: (A+B=C), (C+D=E); both instructions can't execute at the same time since (C+D=E) is reading "C" while (A+B=C) is writing to "C" in the same TICK
            Caching
                Setup:
                    Registers -> L1 -> DRAM
                Read the same data from DRAM twice, will result in data being cached in L1. The second read may occure before L1 technically 'loaded' the data from DRAM.
                    This means all data in cache needs to have a latency timer on it, to know for sure wheather each byte is 'in flight' when being read, or is actually stored.
            Expected Use Case 1
                Setup
                    Single Execution Port
                    Registers -> L1 -> DRAM
                Execution Loop:
                    Get instruction
                    (Speculative) Execute instruction
                        get memory transactions (data read/written, time latency data, data path routing, energy use, #TODO)
                        check if memory transactions conflict with other memory transactions
                        Commit memory reads
                        Store instruction in (re-order buffer) until read memory latency
                        Execute instruction
                        Commit memory writes
                    Next Instruction
            Expected Use Case 2
                Setup
                    Multiple Executions Ports
                    Registers -> DataL1, InstructionL1
                    DataL1, InstructionL1 -> L2
                    L2 -> DRAM (DRAM has controller which constrains bandwidth)
                Execution Loop:
                    Tick
                        Var MemoryWriteLock?
                        Get list of Instructions
                            Var ReOrderBuffer : List
                            (Re-order buffer) execute instruction
                                Get memory transactions (data read/write, time latency data, data path routing, energy use, #TODO)
                                check if memory transactions conflict with other memory transactions
                                check if memory transactions conflict with 'locked off' memory writes
                                check if port use conflicts with other port use
                                queue instruction execution to ReOrderBuffer
                            For Instructions in ReOrderBuffer
                                Commit read Memory transactions
                                instruction waits for memory read latency
                                'execute' instruction
                                Commit write memory transactions
                                Lock memory write elements
            Simple Setup Case
                Setup:
                    Registers('r', 'm')
                        ('r', 0, alias='x1', memoryLatency=5)
                        ('r', 1, alias='x2', memoryLatency=10)
                        ('m', 0, memoryLatency=100)

        """

        def __init__(self):
            self.poolArray : dict[int, Any] = {}

        def read(self, virtualOperation : bool, transactionType : str, branchNode : int, poolEntryPoint : int, hyperThreadContext : int, key : int | str, index : int | str):
            """

            virtualOperation - indicates wheater the read should tabulate stats, or not. IE: reading data for an ISA Instruction vs reading for a debug output
            branchNode - the idea of s specific memory version branch to read from
            poolEntryPoint - this read gets routed through a specific memory pool initially. IE: fetching an instruction goes through L1Instruction vs a data load which goes through L1Data
            transactionType - what part of the engine made this transaction. IE: the engine automatically changed the instruction pointer, vs an ISA instruction jump changing the instruction pointer
            hyperThreadContext - what hyperthread context is being accessed. IE: each thread will need to have a different instruction pointer register
            key - the memory element key
            index - the memory element index

            (branchNode, poolEntryPoint, hyperThreadContext, key, index) together form a kind of address for every memory element
                hyperThreadContext should be zero when not applicable
                using a key of "__" should be reserved for reading the raw values of a pool, without being routed through cache or other nodes
                EX:
                    (1234, L1Instruction, 0, 'm', 255) 
                        -> accesses memory version node 1234, fetch memory element '255' from bank 'm', with hyperThreadContext of '0', via the 'L1Instruction' memory pool
                    (1234, L1Instruction, 0, '__', 255) 
                        -> accesses memory version node 1234, fetch raw memory element '255' from 'L1Instruction' memory pool. hyperThreadContext is not realavent
            """
            pass

        def getMemoryKeys(self, versionNode : int) -> tuple[int, int, int, int | str, int | str]:
            """
            Returns a tuple of (branchNode, poolEntryPoint, hyperThreadContext, key, index)
            """
            pass

    class CompilerDefault:
        """

        #TODO notes:
            compile should take in an assembly program execution tree
            var instruction array # holds instruction nodes
            var data array # holds binary data
            var jump array # holds jump pointers
            recursivly evaluate every line
                call instructionset functions to encode each node
                dump data
                    binary into data array
                    execution node tree into instruction array
                calculate how long the instruction is, and where the next instruction should be to jump to
                    record that data into jump array
        
        """

        def __init__(self, endianess : Literal["big", "little"] = "little", memoryElementSize : int = 8):
            """

            endianess           - the endianess of the binary data, used for properly storing data (64-bit int, 16-bit float, etc)
            memoryElementSize   - the size of the memory unit, used in case of odd unit sizes (7-bit system, or a system that enforces 64-bit aligned access)
            """

            assert type(endianess) is str
            assert endianess in ["big", "little"]
            assert type(memoryElementSize) is int
            assert memoryElementSize > 0

            self.Node : ParseNode = NodeParse

            self.endianess : Literal["big", "little"] = endianess
            self.memoryElementSize : int = memoryElementSize

            self.defaultDirective : Callable[[ParseNode, Any], tuple[0, None]] = self.null # used to autofill undefined instructions from instructionSet
            
            self.instructionSet :   dict[
                                        Tuple(str, ...),                        # Instruction or directive
                                        Callable[
                                            [
                                                ParseNode,                      # The parse/execution tree for a line, for feeding in arguments into a function
                                                dict[                           # A dictionary of pointers to labels within the assembly source code given
                                                    str,                        # The label
                                                    int                         # The pointer index int (will only point to a memory bank WITHIN the current bank the)
                                                ],
                                                dict[                           # A dictionary of aliases for memory, IE: register rt -> register r[5]
                                                    str,
                                                    tuple[int | str]            # A register
                                                ]
                                            ],
                                            list[                               # A list because should allow for the possibility of a node outputing more then one instruction
                                                tuple[
                                                    list[int],                  #TODO
                                                                                # A series of ints representing the instruction in binary, each int is one memory element. 
                                                                                # More then one int represents an instruction longer then one memory element
                                                    ParseNode,                  # The parse/execution tree to be written to memory
                                                    Callable[[int], list[int]], #TODO
                                                                                # a lambda function that takes in a memory offset, and returns an output similar to the above, but taking into account the memory offset
                                                    Any                         #TODO still figuring out what it needs to output, this should be some sort of readable code that could be reprocessed to adjust jumps for linking?
                                                ]
                                            ]
                                        ]
                                    ]
            self.instructionSet = {
                ("nop",)            : (lambda node, labels, alias                                       : self.opNop(node, labels, alias)),
                ("add",)            : (lambda node, labels, alias,      des, a, b                       : self.null(node, labels, alias,            des, a, b)),
                (".ascii",)         : (lambda node, labels, alias,      text                            : self.dirAscii(node, labels, alias,        (text + "\0"))),
                (".int8",)          : (lambda node, labels, alias,      n                               : self.dirInt(node, labels, alias,          n, 8))
            }

        def updateNameSpace(self, nameSpace : dict[str, NameSpaceObject]) -> dict[str, NameSpaceObject]:
            """Takes in a namespace, and updates all relavent variables. Returns a dictionary representing NameSpaceObjects to be added to the NameSpace
            
            #TODO filter out instructions, 'autofill' the self.instructionSet with opNull for any instruction not defined
            """
            
            return {}

        def link(self, parseTree : ParseNode, labels : dict[str, int], alias : dict[str, tuple[int | str]]) -> tuple[list[int], list[int], list[ParseNode]]:
            """Takes in a parseNode representing the parse tree for the entire program, a dict of labels, and outputs a list of ints and a list of instruction lengths and execution tree nodes.

            for each line in the parse tree
                Recursivly searches through an exectuion tree
                    if the node token is in self.instructionSet 
                        will execute the function to properly execute it recursivly
                        (returns int representing instruction, int represeting instruction length, ParseNode representing the exectution tree so far)
                    else
                        do nothing
                        (returns 0, 0, ParseNode as was passed in)
                
            """
            
            root : ParseNode = parseTree
            lines : list[ParseNode] = [node for node in root.child]

            memory : list[int | Callable[[dict[str, int]], list[int]]] = []
            memoryNodes : list[None | ParseNode] = []

            for i in lines:
                pass

        def __recursiveSearch(self, node : ParseNode) -> tuple[list[int], ParseNode | None, list[int]]: #TODO return annotation needs rethinking
            """
            
            Case 1:
                if node.token in self.instructionSet
            Case 2:
                container
            Case 3:
                register
            Case 4:
                litteral (str, int, etc)
            else:
                pass through
            
            Example:
                "add(r0, r1, r2)" 
                -> # Handled by parser
                Line # This is what's fed info __recursiveSearch()
                    Add
                        (
                            r0
                            r1
                            r2
                -> # partially processed midway through recursion
                Line
                    Add                                                         | Note that the 'containers' are eliminated
                        ['r', 0]                                                | Note how the register alaises were converted to key/index pairs
                        ['r', 1]                                                |
                        ['r', 2]                                                |
                -> # opAdd is called
                Line
                    Tuple(
                        list[int, ...]
                        Tuple(
                            Add                                                 # ParseNode
                                ['r', 0]
                                ['r', 1]
                                ['r', 2]
                        )
                        list[int, ...]
                    )
            Example:
                "add(r[0], r[1], r[2])"
                -> # Handled by parser
                Line # This is what's fed info __recursiveSearch()
                    Add
                        (
                            r
                                [
                                    0
                            r
                                [
                                    1
                            r
                                [
                                    2
                -> # partially processed midway through recursion
                Line
                    Add                                                         | Note that the 'containers' are eliminated
                        ['r', 0]                                                | Note how the register alaises were converted to key/index pairs
                        ['r', 1]                                                |
                        ['r', 2]                                                |
                -> # opAdd is called
                Line
                    Tuple(
                        list[int, ...]
                        Tuple(
                            Add                                                 # ParseNode
                                ['r', 0]
                                ['r', 1]
                                ['r', 2]
                        )
                        list[int, ...]
                    )
            Example:
                "add(r[0], r[1], r[2]), mult(r[4], r[1], r[2])"
                -> # Handled by parser
                Line # This is what's fed info __recursiveSearch()
                    Add
                        (
                            r
                                [
                                    0
                            r
                                [
                                    1
                            r
                                [
                                    2
                    Mult
                        (
                            r
                                [
                                    4
                            r
                                [
                                    1
                            r
                                [
                                    2
                -> # partially processed midway through recursion
                Line
                    Add                                                         | Note that the 'containers' are eliminated
                        ['r', 0]                                                | Note how the register alaises were converted to key/index pairs
                        ['r', 1]                                                |
                        ['r', 2]                                                |
                    Mult
                        ['r', 0]
                        ['r', 1]
                        ['r', 2]
                -> # opAdd and opMult is called
                Line
                    Tuple(
                        list[int, ...]
                        Tuple(
                            Add                                                 # ParseNode
                                ['r', 0]
                                ['r', 1]
                                ['r', 2]
                            Mult                # ParseNode
                                ['r', 0]
                                ['r', 1]
                                ['r', 2]
                        )
                        list[int, ...]
                    )

            """
            pass

        def int2bits(self, number : int, bitLength : int) -> list[int]:
            """Takes a bitLength, and a number where ((0 - 2**bitLength) // 2 <= number < 2**bitLength). Returns a bit int array representing the number, zero index is least significant bit
            
            For numbers < 0, twos compliment is applied (python represents negative numbers correctly when appling bitise operations)
            """

            assert type(bitLength) is int
            assert bitLength > 0
            assert type(number) is int
            assert (0 - 2**bitLength) // 2 <= number < 2**bitLength

            number = number & (2**bitLength - 1)
            bitArray = [number >> i & 1 for i in range(bitLength)] # index 0 is least significant bit

            return bitArray

        def null(self,
            node : ParseNode, labels : dict, alias : dict,
            *null
            ) -> tuple[list[int], ParseNode]:
            """Takes in an arbitrary number of arguments. Returns a list of zero representing no instruction, and the node passed in
            
            'Passes through' the ParseNode, while ignoring a variable number of arguments, allowing the instruction encoiding details to be undefined
            """

            return [0], node

        def opNop(self, 
            node : ParseNode, labels : dict, alias : dict 
            ) -> tuple[list[int], ParseNode]:
            
            return [0], node

        def dirAscii(self,
            node : ParseNode, labels : dict, alias : dict,
            text : str
            ) -> tuple[list[int], ParseNode]:
            """ Takes in a string, and outputs a list of ints representing the ascii of the string + None

            memoryElementSize must by 7 bits or greater
            Every character gets put into a single Memory Element, there is no 'packing' multiple characters into a single Memory Element. #TODO should this be allowed?
            Every character gets 'squashed' to 7-bits before being stored
            """

            assert self.memoryElementSize >= 7
            assert type(text) is str
            assert len(text) > 0

            result : list[int] = []

            character : int = 0
            i : str # chr
            for i in text:
                character = ord(i) & (2**7 - 1) # Squashish ascii to 7-bits
                result.append(character)

            return result, None

        def dirInt(self,
            node : ParseNode, labels : dict, alias : dict,
            n : int, bitSize : int
            ) -> tuple[list[int], ParseNode]:
            """ Takes in a number, and a bitSize, and returns a list of ints representing the number's 'not bytes' + None

            If the bitSize is not a multiple of self.memoryElementSize, the number will still be represented. 
                IE: n=255, bitSize=7 will return [127, 1] (where the '1' is the most significant 'not byte')

            Example:
                endianess               = 'little'
                memoryElementSize       = 8
                bitLength               = 16
                n                       = 255
                result                  = ([255, 0], None)
            Example:
                endianess               = 'little'
                memoryElementSize       = 8
                bitLength               = 16
                n                       = 256
                result                  = ([0, 1], None)
            Example:
                endianess               = 'big'
                memoryElementSize       = 8
                bitLength               = 16
                n                       = 256
                result                  = ([1, 0], None)
            Example:
                endianess               = 'little'
                memoryElementSize       = 7
                bitLength               = 8
                n                       = 255
                result                  = ([127, 1], None)
            Example:
                endianess               = 'little'
                memoryElementSize       = 7
                bitLength               = 8
                n                       = 256
                result                  = ([0, 2], None)
            Example:
                endianess               = 'big'
                memoryElementSize       = 7
                bitLength               = 8
                n                       = 256
                result                  = ([2, 0], None)
            """

            assert self.memoryElementSize > 1
            assert type(n) is int
            assert n >= 0
            assert type(bitSize) is int
            assert bitSize > 0

            assert n < 2**bitSize

            numberBits : list[int] = self.int2bits(n, bitSize) # LSB is first
            result : list[int] = []

            modulus : int = 0
            memoryElement : int = 0
            i : int
            for i in numberBits: # Takes Least Significant 'not Byte' and appends it to the result
                memoryElement = memoryElement + (i << modulus)
                modulus += 1
                if modulus == self.memoryElementSize:
                    result.append(memoryElement)
                    memoryElement = 0
                    modulus = 0
            
            if modulus > 0: # the remander will be the Most Significant 'not Byte'
                result.append(memoryElement)

            # result now contains 'not byte' elements such that the Least Significant 'not Byte' is First
            if self.endianess == "big":
                result.reverse()
            
            return result, None
        
    class DecoderDefault:
        pass

#=============================================================================================================================================================== Unit Tests

class Test_CompilerDefault_BuildingBlocks(unittest.TestCase):
    def setUp(self):
        self.compiler = CPUsim_v4.CompilerDefault

    def test_dirInt_Int8(self):
        """Tests 8-bit ints, nothing fancy"""

        compiler = self.compiler(endianess = "little", memoryElementSize = 8)

        i : int
        for i in range(256):
            result : tuple[list[int], None] = compiler.dirInt(NodeParse(), {}, {},
                                                                i, 8)

            self.assertEqual(result, ([i], None))

    def test_dirInt_Int16(self):
        """Tests 16-bit ints, over 2 memory elements, with both endianess"""

        endianessTest : str
        for endianessTest in ["little", "big"]:
            with self.subTest(endianessTest = endianessTest):
                compiler = self.compiler(endianess = endianessTest, memoryElementSize = 8)

                i : int
                for i in range(2**16):
                    with self.subTest(i = i):
                        x_0 = i & (2**8 - 1) # takes lower 8 bits
                        x_1 = (i & ((2**8 - 1) << 8)) >> 8 # takes upper 8 bits

                        result : list[int] = compiler.dirInt(NodeParse(), {}, {},
                                                            i, 16)[0]

                        if endianessTest == "little":
                            self.assertEqual(result, [x_0, x_1])
                        else:
                            self.assertEqual(result, [x_1, x_0])

    def test_dirInt_8BitSweep(self):
        """Sweeps a single toggeled bit across multiple bitLengths, for both endianess"""

        endianessTest : str
        for endianessTest in ["little", "big"]:
            with self.subTest(endianessTest = endianessTest):

                compiler = self.compiler(endianess = endianessTest, memoryElementSize = 8)

                bitLength : int
                for bitLength in [8, 16, 32, 64, 128]:
                    with self.subTest(bitLength=bitLength):

                        i : int
                        for i in range(bitLength):
                            with self.subTest(i = i):

                                result : list[int] = compiler.dirInt(NodeParse(), {}, {},
                                                                    (1 << i), bitLength)[0]

                                if endianessTest == "little":
                                    result.reverse()

                                resultProcessed : int = 0
                                for j in range(bitLength // 8):
                                    resultProcessed = (resultProcessed << 8) + result[j]

                                self.assertEqual(resultProcessed, (1 << i))

    def test_dirInt_MaxInt(self):
        """Attempts to store the maxium value in an int of multiple bitLengths and both endianess"""

        endianessTest : str
        for endianessTest in ["little", "big"]:
            with self.subTest(endianessTest = endianessTest):

                compiler = self.compiler(endianess = endianessTest, memoryElementSize = 8)

                byteLength : int
                for byteLength in [2 ** i for i in range(1, 8 + 1)]:
                    with self.subTest(bitLength=byteLength):

                        result : list[int] = compiler.dirInt(NodeParse(), {}, {},
                                                            2**(8 * byteLength) - 1, 8 * byteLength)[0]

                        resultProcessed : int = 0
                        j : int
                        for j in range(byteLength):
                            resultProcessed = (resultProcessed << 8) + result[j]

                        self.assertEqual(resultProcessed, 2**(8 * byteLength) - 1)

    def test_dirInt_MemoryElementSizeMismatch(self):
        """Tests that a number can still be stored when the memoryElementSize and the bitLength of the number being stored are not multiples of each other
        
        Example:
            endianess                   = 'little'
            memoryElementSize           = 7
            bitLength                   = 8
            n                           = 255
            result                      = [127, 1]

        Example:
            endianess                   = 'little'
            memoryElementSize           = 7
            bitLength                   = 8
            n                           = 256
            result                      = [0, 2]

        Example:
            endianess                   = 'big'
            memoryElementSize           = 7
            bitLength                   = 8
            n                           = 256
            result                      = [2, 0]
        """

        endianessTest : str
        for endianessTest in ["little", "big"]:
            with self.subTest(endianessTest = endianessTest):

                compiler = self.compiler(endianess = endianessTest, memoryElementSize = 7)

                i : int
                for i in range(2 ** 10):
                    with self.subTest(i=i):

                        x_0 = i & (2**7 - 1) # takes lower 7 bits
                        x_1 = (i & ((2**7 - 1) << 7)) >> 7 # takes upper 7 bits

                        result : list[int] = compiler.dirInt(NodeParse(), {}, {},
                                                            i, 10)[0] # MemoryElement is 7 bits long, but requesting jamming 8 bits into it

                        if endianessTest == "little":
                            self.assertEqual(result, [x_0, x_1])
                        else:
                            self.assertEqual(result, [x_1, x_0])

    def test_dirAscii_HelloWorld(self):
        """Tests converting 'Hello World!'"""

        compiler = self.compiler(endianess = "little", memoryElementSize = 8)

        result : list[int] = compiler.dirAscii(NodeParse(), {}, {},
                                                "Hello World!")[0]

        self.assertEqual(result, [ord(i) for i in "Hello World!"])

    def test_dirAscii_7bitSquash(self):
        """Tests that input text is properly 'squashed' to 7-bit ASCII"""

        compiler = self.compiler(endianess = "little", memoryElementSize = 8)

        i : int
        for i in range(256):
            with self.subTest(i = i):
                result : list[int] = compiler.dirAscii(NodeParse(), {}, {},
                                                        chr(i))[0]

                self.assertEqual(result, [i & 0b01111111])

class Test_ParserDefault_BuildingBlocks(unittest.TestCase):
    """Tests the default building blocks of ParserDefault"""

    def setUp(self):
        self.parser = CPUsim_v4.ParserDefault()

    def test_tokenize_ExceptionCodeNotString(self):
        """tests tokenize raises an exception when code is not string"""

        codes : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        code : Any
        for code in codes:
            with self.subTest(code=code):
                self.assertRaises(AssertionError, self.parser.tokenize, code)

    def test_tokenize_ExceptionCodeNotEmpty(self):
        """tests tokenize raises an exception when code is not empty"""

        code : str = ''

        self.assertRaises(AssertionError, self.parser.tokenize, code)

    def test_tokenize_HelloWorld(self):
        """Tests tokenize tokinizes correctly on 'Hello World!'
        
        'Hello World!'
        ->
        [
            ('Hello',                   0,      0),
            (' ',                       0,      5),
            ('World',                   0,      6),
            ('!',                       0,      11)
        ]
        """

        argument : str = "Hello World!"

        expected : list[tuple[str, int, int]] = [   
                ("Hello",               0,      0), 
                (" ",                   0,      5), 
                ("World",               0,      6), 
                ("!",                   0,      11)
            ]

        result : list[tuple[str, int, int]] = self.parser.tokenize(argument)

        self.assertEqual(result, expected, f"\nroot:\n{argument}\nexpected:\n{expected}\nresult:\n{result}")

    def test_tokenize_Multiline(self):
        """Tests tokenize on multiline input 'test\n\nHello World!'
        
        'test\n\nHello World!'
        ->
        [
            ('test',                    0,      0),
            ('\n',                      0,      4),
            ('\n',                      1,      0),
            ('Hello',                   2,      0),
            (' ',                       2,      5),
            ('World',                   2,      6),
            ('!',                       2,      11)
        ]
        """

        argument : str = "test\n\nHello World!"

        expected : list[tuple[str, int, int]] = [
                ("test",                0,      0),
                ("\n",                  0,      4),
                ("\n",                  1,      0),
                ("Hello",               2,      0),
                (" ",                   2,      5),
                ("World",               2,      6),
                ("!",                   2,      11)
            ]

        result : list[tuple[str, int, int]] = self.parser.tokenize(argument)

        self.assertEqual(result, expected, f"\nroot:\n{argument}\nexpected:\n{expected}\nresult:\n{result}")

    def test_tokenize_integration01(self):
        """Tests tokenize tokinizes correctly on 'Hello World'
        
        'Hello World'
        ->
        [
            ('Hello',                   0,      0),
            (' ',                       0,      5),
            ('World',                   0,      6)
        ]
        """

        argument : str = "Hello World"

        expected : list[tuple[str, int, int]] = [   
                ("Hello",               0,      0), 
                (" ",                   0,      5), 
                ("World",               0,      6)
            ]

        result : list[tuple[str, int, int]] = self.parser.tokenize(argument)

        self.assertEqual(result, expected, f"\nroot:\n{argument}\nexpected:\n{expected}\nresult:\n{result}")

    def test_tokenize_integration02(self):
        """Tests tokenize tokinizes correctly on 'Hello\u28ffWorld'

        'Hello\u28ffWorld'
        ->
        [
            ('Hello',                   0,      0),
            ('\u28ff',                  0,      5),
            ('World',                   0,      6)
        ]
        """

        argument : str = "Hello\u28ffWorld"

        expected : list[tuple[str, int, int]] = [   
                ("Hello",               0,      0), 
                ("\u28ff",              0,      5), 
                ("World",               0,      6)
            ]

        result : list[tuple[str, int, int]] = self.parser.tokenize(argument)

        self.assertEqual(result, expected, f"\nroot:\n{argument}\nexpected:\n{expected}\nresult:\n{result}")

    def test_tokenizeCharacter_ExceptionCodeNotString(self):
        """tests tokenizeCharacter raises an exception when code is not string"""

        codes : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        code : Any
        for code in codes:
            with self.subTest(code=code):
                self.assertRaises(AssertionError, self.parser.tokenizeCharacter, code)

    def test_tokenizeCharacter_ExceptionCodeNotEmpty(self):
        """tests tokenizeCharacter raises an exception when code is not empty"""

        code : str = ''

        self.assertRaises(AssertionError, self.parser.tokenizeCharacter, code)

    def test_tokenizeCharacter_singleCharacter(self):
        """Tests tokenizeCharacter on string 'a'

        'a'
        ->
        [
            ('a',                       0,      0,      0)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_multiCharacter(self):
        """Tests tokenizeCharacter on string 'ab'

        'ab'
        ->
        [
            ('a',                       0,      0,      0),
            ('b',                       0,      1,      1)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_multiline(self):
        """Tests tokenizeCharacter on string 'a\nb'

        'a\nb'
        ->
        [
            ('a',                       0,      0,      0),
            ('\n',                      0,      1,      1),
            ('b',                       1,      0,      2)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_onlyNewLines(self):
        """Tests tokenizeCharacter on string '\n\n'

        '\n\n'
        ->
        [
            ('\n',                      0,      0,      0),
            ('\n',                      1,      0,      1)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_Integration01(self):
        """Tests tokenizeCharacter on string 'Hello World'

        'Hello World'
        ->
        [
            ('H',                       0,      0,      0),
            ('e',                       0,      1,      1),
            ('l',                       0,      2,      2),
            ('l',                       0,      3,      3),
            ('o',                       0,      4,      4),
            (' ',                       0,      5,      5),
            ('W',                       0,      6,      6),
            ('o',                       0,      7,      7),
            ('r',                       0,      8,      8),
            ('l',                       0,      9,      9),
            ('d',                       0,      10,     10)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_Integration02(self):
        """Tests tokenizeCharacter on string 'Hello\nWorld'

        'Hello\nWorld'
        ->
        [
            ('H',                       0,      0,      0),
            ('e',                       0,      1,      1),
            ('l',                       0,      2,      2),
            ('l',                       0,      3,      3),
            ('o',                       0,      4,      4),
            ('\n',                      0,      5,      5),
            ('W',                       1,      0,      6),
            ('o',                       1,      1,      7),
            ('r',                       1,      2,      8),
            ('l',                       1,      3,      9),
            ('d',                       1,      4,      10)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_Integration03(self):
        """Tests tokenizeCharacter on string 'Hello\u28ffWorld'

        'Hello\u28ffWorld'
        ->
        [
            ('H',                       0,      0,      0),
            ('e',                       0,      1,      1),
            ('l',                       0,      2,      2),
            ('l',                       0,      3,      3),
            ('o',                       0,      4,      4),
            ('\u28ff',                  0,      5,      5),
            ('W',                       0,      6,      6),
            ('o',                       0,      7,      7),
            ('r',                       0,      8,      8),
            ('l',                       0,      9,      9),
            ('d',                       0,      10,     10)
        ]
        """
        raise NotImplementedError

    def test_tokenizeCharacter_Integration04(self):
        """Tests tokenizeCharacter on string 'a\nb\nc\td\ne\nf\rg\rh\n'

        'a\nb\nc\td\ne\nf\rg\rh\n'
        ->
        [
            ('a',                       0,      0,      0),
            ('\n',                      0,      1,      1),
            ('b',                       1,      0,      2),
            ('\n',                      1,      1,      3),
            ('c',                       2,      0,      4),
            ('\t',                      2,      1,      5),
            ('d',                       2,      2,      6),
            ('\n',                      2,      3,      7),
            ('e',                       3,      0,      8),
            ('\n',                      3,      1,      9),
            ('f',                       4,      0,      10),
            ('\r',                      4,      1,      11),
            ('g',                       4,      2,      12),
            ('\r',                      4,      3,      13),
            ('h',                       4,      4,      14),
            ('\n',                      4,      5,      15)
        ]
        """
        raise NotImplementedError

    def test_ruleCastInts_ExceptionTreeNotNodeParse(self):
        """tests ruleCastInts raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleCastInts, tree)

    def test_ruleCastInts_Integration01(self):
        """tests ruleCastInts basic test case '123 456 789'
        
        '123 456 789'
        ->
        Node
            '123'                       |
            ' '
            '456'                       |
            ' '
            '789'                       |
        ->
        Node
            123                         |
            ' '
            456                         |
            ' '
            789                         |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "123",              0, 0))
        root.append(NodeParse(                                                  "",                 "",                 0, 0))
        root.append(NodeParse(                                                  "",                 "456",              0, 0))
        root.append(NodeParse(                                                  "",                 "",                 0, 0))
        root.append(NodeParse(                                                  "",                 "789",              0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "int",              123,                0, 0))
        expected.append(NodeParse(                                              "",                 "",                 0, 0))
        expected.append(NodeParse(                                              "int",              456,                0, 0))
        expected.append(NodeParse(                                              "",                 "",                 0, 0))
        expected.append(NodeParse(                                              "int",              789,                0, 0))

        result : ParseNode = self.parser.ruleCastInts(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleCastInts_Integration02(self):
        """tests ruleCastInts basic test case 'Hello World!'
        
        'Hello World!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))
        expected.append(NodeParse(                                              "",                 "!",                0, 11))

        result : ParseNode = self.parser.ruleCastInts(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleCastHex_ExceptionTreeNotNodeParse(self):
        """tests ruleCastHex raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleCastHex, tree)

    def test_ruleCastHex_Integration01(self):
        """tests rulesCastHex basic test case '0xff'
        
        '0xff'
        ->
        Node
            '0xff'                      |
        ->
        Node
            255                         |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "0xff",             0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "int",              255,                0, 0))

        result : ParseNode = self.parser.ruleCastHex(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleCastHex_Integration02(self):
        """tests rulesCastHex basic test case '0x0 0x000A 0xff'
        
        '0x0 0x000A 0xff'
        ->
        Node
            '0x0'                       |
            ' '
            '0x000A'                    |
            ' '
            '0xff'                      |
        ->
        Node
            0                           |
            ' '
            10                          |
            ' '
            255                         |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "0x0",              0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 0))
        root.append(NodeParse(                                                  "",                 "0x000A",           0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 0))
        root.append(NodeParse(                                                  "",                 "0xff",             0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "int",              0,                  0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 0))
        expected.append(NodeParse(                                              "int",              10,                 0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 0))
        expected.append(NodeParse(                                              "int",              255,                0, 0))
        
        result : ParseNode = self.parser.ruleCastHex(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleCastHex_Integration03(self):
        """tests rulesCastHex basic test case 'Hello World!'
        
        'Hello World!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))
        expected.append(NodeParse(                                              "",                 "!",                0, 11))

        result : ParseNode = self.parser.ruleCastHex(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleCastHex_MixedCase01(self):
        """tests ruleCastHex if the hex is formatted with mixed cases '0xfFfF'
        
        '0xfFfF'
        ->
        Node
            '0xfFfF'                    |
        ->
        Node
            65535                       |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "0xfFfF",           0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "int",              65535,              0, 0))

        result : ParseNode = self.parser.ruleCastHex(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleCastHex_MixedCase02(self):
        """tests ruleCastHex if the hex is formatted with mixed cases '0Xffff'
        
        '0Xffff'
        ->
        Node
            '0Xffff'                    |
        ->
        Node
            65535                       |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "0xfFfF",           0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "int",              65535,              0, 0))

        result : ParseNode = self.parser.ruleCastHex(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveEmptyLines_Integration01(self):
        """tests ruleRemoveEmptyLines on a single line, 'Hello World!'
        
        'Hello World!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = root.copyDeep()

        result : ParseNode = self.parser.ruleRemoveEmptyLines(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveEmptyLines_Integration02(self):
        """tests ruleRemoveEmptyLines on a multiline input, 'test\ntest\n\n\ntest\n'
        
        'test\ntest\n\n\ntest\n'
        ->
        Node
            'test'
            '\n'
            'test'
            '\n'                        # This node is kept
            '\n'                        |
            '\n'                        |
            'test'
            '\n'
        ->
        Node
            'test'
            '\n'
            'test'
            '\n'                        _V_
            'test'                       A
            '\n'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 4))
        root.append(NodeParse(                                                  "",                 "test",             1, 0))
        root.append(NodeParse(                                                  "",                 "\n",               1, 4))
        root.append(NodeParse(                                                  "",                 "\n",               2, 0))
        root.append(NodeParse(                                                  "",                 "\n",               3, 0))
        root.append(NodeParse(                                                  "",                 "test",             4, 0))
        root.append(NodeParse(                                                  "",                 "\n",               4, 4))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 "\n",               0, 4))
        expected.append(NodeParse(                                              "",                 "test",             1, 0))
        expected.append(NodeParse(                                              "",                 "\n",               1, 4))
        expected.append(NodeParse(                                              "",                 "test",             4, 0))
        expected.append(NodeParse(                                              "",                 "\n",               4, 4))

        result : ParseNode = self.parser.ruleRemoveEmptyLines(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveEmptyLines_AllEmpty(self):
        """tests ruleRemoveEmptyLines in the case of all empty lines '\n\n\n\n'
        
        '\n\n\n\n'
        ->
        Node
            '\n'                        |
            '\n'                        |
            '\n'                        |
            '\n'                        |
        ->
        Node                            _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\n",               0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               1, 0))
        root.append(NodeParse(                                                  "",                 "\n",               2, 0))
        root.append(NodeParse(                                                  "",                 "\n",               3, 0))

        expected : ParseNode = NodeParse()
        
        result : ParseNode = self.parser.ruleRemoveEmptyLines(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveEmptyLines_EmptyLines(self):
        """tests ruleRemoveEmptyLines in the case of empty line ''
        
        ''
        ->
        Node
        ->
        Node
        """

        root : ParseNode = NodeParse()

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleRemoveEmptyLines(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveEmptyLines_ExceptionTreeNotNodeParse(self):
        """tests ruleFilterLineComments raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleFilterLineComments, tree)

    def test_ruleRemoveLeadingWhitespace_Integration01(self):
        """tests ruleRemoveLeadingWhitespace on a single line, 'Hello World!'
        
        'Hello World!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = root.copyDeep()

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_Integration02(self):
        """tests ruleRemoveLeadingWhitespace on a multiline input, 'test test \ntest\n  \ttest\t\n     \n'
        
        'test test \ntest\n  \ttest\t\n     \n'
        -> 
        Node
            'test'
            ' '
            'test'
            ' '
            '\n'
            'test'
            '\n'
            ' '                         |
            ' '                         |
            '\t'                        |
            'test'
            '\t'
            '\n'
            ' '                         |
            ' '                         |
            ' '                         |
            ' '                         |                               
            ' '                         |
            '\n'
        ->
        Node
            'test'
            ' '
            'test'
            ' '
            '\n'
            'test'
            '\n'                        _V_
            'test'                       A
            '\t'
            '\n'                        _V_
            '\n'                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "test",             0, 5))
        root.append(NodeParse(                                                  "",                 " ",                0, 9))
        root.append(NodeParse(                                                  "",                 "\n",               0, 10))
        root.append(NodeParse(                                                  "",                 "test",             1, 0))
        root.append(NodeParse(                                                  "",                 "\n",               1, 4))
        root.append(NodeParse(                                                  "",                 " ",                2, 0))
        root.append(NodeParse(                                                  "",                 " ",                2, 1))
        root.append(NodeParse(                                                  "",                 "\t",               2, 2))
        root.append(NodeParse(                                                  "",                 "test",             2, 3))
        root.append(NodeParse(                                                  "",                 "\t",               2, 7))
        root.append(NodeParse(                                                  "",                 "\n",               2, 8))
        root.append(NodeParse(                                                  "",                 " ",                3, 0))
        root.append(NodeParse(                                                  "",                 " ",                3, 1))
        root.append(NodeParse(                                                  "",                 " ",                3, 2))
        root.append(NodeParse(                                                  "",                 " ",                3, 3))
        root.append(NodeParse(                                                  "",                 " ",                3, 4))
        root.append(NodeParse(                                                  "",                 "\n",               3, 5))

        # "test test \ntest\ntest\t\n\n"
        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))
        expected.append(NodeParse(                                              "",                 "test",             0, 5))
        expected.append(NodeParse(                                              "",                 " ",                0, 9))
        expected.append(NodeParse(                                              "",                 "\n",               0, 10))
        expected.append(NodeParse(                                              "",                 "test",             1, 0))
        expected.append(NodeParse(                                              "",                 "\n",               1, 4))
        expected.append(NodeParse(                                              "",                 "test",             2, 3))
        expected.append(NodeParse(                                              "",                 "\t",               2, 7))
        expected.append(NodeParse(                                              "",                 "\n",               2, 8))
        expected.append(NodeParse(                                              "",                 "\n",               3, 5))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_EmptyLine(self):
        """tests ruleRemoveLeadingWhitespace on an empty line '\n'
        
        '\n'
        ->
        Node
            '\n'
        ->
        Node
            '\n'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\n",               0, 0))

        expected : ParseNode = root.copyDeep()

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_AllWhiteSpace(self):
        """tests ruleRemoveLeadingWhitespace on a single line of all whitespace '    '
        
        '    '
        ->
        Node
            ' '                         |
            ' '                         |
            ' '                         |
            ' '                         |
        ->
        Node                            _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 " ",                0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 2))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingSpace01(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '   Hello World!'
        
        '   Hello World!'
        ->
        Node
            ' '                         |
            ' '                         |
            ' '                         |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node                            _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 " ",                0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingSpace02(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\n  Hello World!'
        
        '\n  Hello World!'
        ->
        Node
            '\n'
            ' '                         |
            ' '                         |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            '\n'                        _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\n",               0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "\n",               0, 0))
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingTabs01(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\t\t\tHello World!'
        
        '\t\t\tHello World!'
        ->
        Node
            '\t'                        |
            '\t'                        |
            '\t'                        |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node                            _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\t",               0, 0))
        root.append(NodeParse(                                                  "",                 "\t",               0, 1))
        root.append(NodeParse(                                                  "",                 "\t",               0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingTabs02(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\n\t\tHello World!'
        
        '\n\t\tHello World!'
        ->
        Node
            '\n'
            '\t'                        |
            '\t'                        |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            '\n'                        _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\n",               0, 0))
        root.append(NodeParse(                                                  "",                 "\t",               0, 1))
        root.append(NodeParse(                                                  "",                 "\t",               0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "\n",               0, 0))
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingCarriageReturn01(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\r\r\rHello World!'
        
        '\r\r\rHello World!'
        ->
        Node
            '\r'                        |
            '\r'                        |
            '\r'                        |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node                            _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\r",               0, 0))
        root.append(NodeParse(                                                  "",                 "\r",               0, 1))
        root.append(NodeParse(                                                  "",                 "\r",               0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingCarriageReturn02(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\n\r\rHello World!'
        
        '\n\r\rHello World!'
        ->
        Node
            '\n'
            '\r'                        |
            '\r'                        |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            '\n'                        _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\n",               0, 0))
        root.append(NodeParse(                                                  "",                 "\r",               0, 1))
        root.append(NodeParse(                                                  "",                 "\r",               0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "\n",               0, 0))
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")
        
    def test_ruleRemoveLeadingWhitespace_LeadingFormFeed01(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\f\f\fHello World!'
        
        '\f\f\fHello World!'
        ->
        Node
            '\f'                        |
            '\f'                        |
            '\f'                        |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node                            _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\f",               0, 0))
        root.append(NodeParse(                                                  "",                 "\f",               0, 1))
        root.append(NodeParse(                                                  "",                 "\f",               0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_LeadingFormFeed02(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace '\n\f\fHello World!'
        
        '\n\f\fHello World!'
        ->
        Node
            '\n'
            '\f'                        |
            '\f'                        |
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            '\n'                        _V_
            'Hello'                      A
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\n",               0, 0))
        root.append(NodeParse(                                                  "",                 "\f",               0, 1))
        root.append(NodeParse(                                                  "",                 "\f",               0, 2))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "!",                0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "\n",               0, 0))
        expected.append(NodeParse(                                              "",                 "Hello",            0, 3))
        expected.append(NodeParse(                                              "",                 " ",                0, 8))
        expected.append(NodeParse(                                              "",                 "World",            0, 9))
        expected.append(NodeParse(                                              "",                 "!",                0, 14))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_Children01(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace 'test\n\t\t\ttest[abc 123]' when some tokens have children
        
        'test\n\t\t\ttest[abc 123]' 
        ->
        Node
            'test'
            '\n'
            '\t'                        |
            '\t'                        |
            '\t'                        |
            'test'
                'abc'
                ' '
                '123'
        ->
        Node
            'test'
            '\n'                        _V_
            'test'                       A
                'abc'
                ' '
                '123'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 4))
        root.append(NodeParse(                                                  "",                 "\t",               0, 5))
        root.append(NodeParse(                                                  "",                 "\t",               0, 6))
        root.append(NodeParse(                                                  "",                 "\t",               0, 7))
        rChild1 : ParseNode = NodeParse(                                        "",                 "test",             0, 8)
        rChild1.append(NodeParse(                                               "",                 "abc",              0, 12))
        rChild1.append(NodeParse(                                               "",                 " ",                0, 15))
        rChild1.append(NodeParse(                                               "",                 "123",              0, 16))
        root.append(rChild1)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 "\n",               0, 4))
        eChild1 : ParseNode = NodeParse(                                        "",                 "test",             0, 8)
        eChild1.append(NodeParse(                                               "",                 "abc",              0, 12))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 15))
        eChild1.append(NodeParse(                                               "",                 "123",              0, 16))
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_Children02(self):
        """tests ruleRemoveLeadingWhitespace on a single line of leading whitespace 'test\n\t\t\t[abc 123]test' when some tokens have children

        'test\n\t\t\t[abc 123]test'
        ->
        Node
            'test'
            '\n'
            '\t'                        |
            '\t'                        |
            '\t'                        |
                'abc'                   |
                ' '                     |
                '123'                   |
            'test'
        ->
        Node
            'test'
            '\n'                        _V_
            'test'                       A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 4))
        root.append(NodeParse(                                                  "",                 "\t",               0, 5))
        root.append(NodeParse(                                                  "",                 "\t",               0, 6))
        rChild : ParseNode = NodeParse(                                         "",                 "\t",               0, 7)
        rChild.append(NodeParse(                                                "",                 "abc",              0, 12))
        rChild.append(NodeParse(                                                "",                 " ",                0, 15))
        rChild.append(NodeParse(                                                "",                 "123",              0, 16))
        root.append(rChild)
        root.append(NodeParse(                                                  "",                 "test",             0, 17))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 "\n",               0, 4))
        expected.append(NodeParse(                                              "",                 "test",             0, 17))

        result : ParseNode = self.parser.ruleRemoveLeadingWhitespace(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveLeadingWhitespace_ExceptionTreeNotNodeParse(self):
        """tests ruleRemoveLeadingWhitespace raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleRemoveLeadingWhitespace, tree)

    def test_ruleRemoveLeadingWhiteSpace_ExceptionWhitespaceNotList(self):
        """tests ruleRemoveLeadingWhitespace raises an exception when whitespace is not a list"""

        whitespaces : list[Any] = [None, 0, False, 'a', {0 : 'a'}, ('a',), {'a',}]

        whitespace : Any
        for whitespace in whitespaces:
            with self.subTest(whitespace=whitespace):
                root : ParseNode = NodeParse()
                self.assertRaises(AssertionError, self.parser.ruleRemoveLeadingWhitespace, root, whitespace)

    def test_ruleRemoveLeadingWhiteSpace_ExceptionWhitespaceNotString(self):
        """tests ruleRemoveLeadingWhitespace raises an exception when whitespace is not a string"""

        whitespaces : list[Any] = [None, 0, False, [0], {0 : [0]}, ('a',), {'a',}]

        whitespace : Any
        for whitespace in whitespaces:
            with self.subTest(whitespace=whitespace):
                root : ParseNode = NodeParse()
                self.assertRaises(AssertionError, self.parser.ruleRemoveLeadingWhitespace, root, [whitespace])

    def test_ruleRemoveLeadingWhiteSpace_ExceptionWhitespaceStringWrongLength(self):
        """tests ruleRemoveLeadingWhitespace raises an exception when whitespace is not a string of length 1"""

        whitespaces : list[str] = [''.join(['a' for _ in range(i)]) for i in range(2, 10)]

        whitespace : Any
        for whitespace in whitespaces:
            with self.subTest(whitespace=whitespace):
                root : ParseNode = NodeParse()
                self.assertRaises(AssertionError, self.parser.ruleRemoveLeadingWhitespace, root, [whitespace])

    def test_ruleStringSimple_Integration01(self):
        """tests ruleStringSimple on a simple string 'Hello World!'
        
        'Hello World!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))
        expected.append(NodeParse(                                              "",                 "!",                0, 11))

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Integration02(self):
        """tests ruleStringSimple on a simple string '\'Hello World!\''
        
        '\'Hello World!\''
        ->
        Node
            '\''                        V
            'Hello'                     |
            ' '                         |
            'World'                     |
            '!'                         |
            '\''                        A
        ->
        Node
            'Hello World!'              |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\'",               0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))
        root.append(NodeParse(                                                  "",                 "!",                0, 12))
        root.append(NodeParse(                                                  "",                 "\'",               0, 13))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "string",           "Hello World!",     0, 0))

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Integration03(self):
        """tests ruleStringSimple on a simple string '\"Hello World!\"'
        
        '\"Hello World!\"'
        ->
        Node
            '\"'                        V
            'Hello'                     |
            ' '                         |
            'World'                     |
            '!'                         |
            '\"'                        A
        ->
        Node
            'Hello World!'              |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\"",               0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))
        root.append(NodeParse(                                                  "",                 "!",                0, 12))
        root.append(NodeParse(                                                  "",                 "\"",               0, 13))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "string",           "Hello World!",     0, 0))

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Integration04(self):
        """tests ruleStringSimple on a simple string 'test \'test\''
        
        'test \'test\''
        ->
        Node
            'test'
            ' '
            '\''                        V
            'test'                      |
            '\''                        A
        ->
        Node
            'test'
            ' '
            'test'                      |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "\'",               0, 5))
        root.append(NodeParse(                                                  "",                 "test",             0, 6))
        root.append(NodeParse(                                                  "",                 "\'",               0, 10))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))
        expected.append(NodeParse(                                              "string",           "test",             0, 5))
        
        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Integration05(self):
        """tests ruleStringSimple on a simple string '\'test\n\\\'test\\\'\'\ntest'
        
        '\'test\n\\\'test\\\'\'\ntest'
        ->
        Node
            '\''                        V
            'test'                      |
            '\n'                        |
            '\\'                        |
            '\''                        |
            'test'                      |
            '\\'                        |
            '\''                        |
            '\''                        A
            '\n'
            'test'
        ->
        Node
            'test\n\\\'test\\\''        |
            '\n'
            'test'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\'",               0, 0))
        root.append(NodeParse(                                                  "",                 "test",             0, 4))
        root.append(NodeParse(                                                  "",                 "\n",               0, 5))
        root.append(NodeParse(                                                  "",                 "\\",               0, 6))
        root.append(NodeParse(                                                  "",                 "\'",               0, 7))
        root.append(NodeParse(                                                  "",                 "test",             0, 8))
        root.append(NodeParse(                                                  "",                 "\\",               0, 12))
        root.append(NodeParse(                                                  "",                 "\'",               0, 13))
        root.append(NodeParse(                                                  "",                 "\'",               0, 14))
        root.append(NodeParse(                                                  "",                 "\n",               0, 15))
        root.append(NodeParse(                                                  "",                 "test",             0, 16))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "string",           "test\n\\\'test\\\'", 0, 0))
        expected.append(NodeParse(                                              "",                 "\n",               0, 15))
        expected.append(NodeParse(                                              "",                 "test",             0, 16))

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Integration06(self):
        """tests ruleStringSimple on a simple string '\'test\n\'test\'\'\ntest'
        
        '\'test\n\'test\'\'\ntest'
        ->
        Node
            '\''                        V
            'test'                      |
            '\n'                        |
            '\''                        A
            'test'
            '\''                        V
            '\''                        A
            '\n'
            'test'
        ->
        Node
            'test\n'                    |
            'test'
            ''                          |
            '\n'
            'test'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\'",               0, 0))
        root.append(NodeParse(                                                  "",                 "test",             0, 1))
        root.append(NodeParse(                                                  "",                 "\n",               0, 5))
        root.append(NodeParse(                                                  "",                 "\'",               0, 6))
        root.append(NodeParse(                                                  "",                 "test",             0, 7))
        root.append(NodeParse(                                                  "",                 "\'",               0, 11))
        root.append(NodeParse(                                                  "",                 "\'",               0, 12))
        root.append(NodeParse(                                                  "",                 "\n",               0, 13))
        root.append(NodeParse(                                                  "",                 "test",             0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "string",           "test\n",           0, 0))
        expected.append(NodeParse(                                              "",                 "test",             0, 7))
        expected.append(NodeParse(                                              "string",           "",                 0, 11))
        expected.append(NodeParse(                                              "",                 "\n",               0, 13))
        expected.append(NodeParse(                                              "",                 "test",             0, 14))

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Integration07(self):
        """tests ruleStringSimple on a simple string 'test1\"abc\'123\'abc\"test2'
        
        'test1\"abc\'123\'abc\"test2'
        ->
        Node
            'test1'
            '\"'                        V
            'abc'                       |
            '\''                        |
            '123'                       |
            '\''                        |
            'abc'                       |
            '\"'                        A
            'test2'
        ->
        Node
            'test1'
            'abc\'123\'abc'             |
            'test2'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 "\"",               0, 5))
        root.append(NodeParse(                                                  "",                 "abc",              0, 6))
        root.append(NodeParse(                                                  "",                 "\'",               0, 9))
        root.append(NodeParse(                                                  "",                 "123",              0, 10))
        root.append(NodeParse(                                                  "",                 "\'",               0, 13))
        root.append(NodeParse(                                                  "",                 "abc",              0, 14))
        root.append(NodeParse(                                                  "",                 "\"",               0, 17))
        root.append(NodeParse(                                                  "",                 "test2",            0, 18))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test1",            0, 0))
        expected.append(NodeParse(                                              "string",           "abc\'123\'abc",    0, 5))
        expected.append(NodeParse(                                              "",                 "test2",            0, 18))

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_Null(self):
        """tests ruleStringSimple on a null string
        
        ''
        ->
        Node
        ->
        Node
        """

        root : ParseNode = NodeParse()

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleStringSimple_AllSpaces(self):
        """tests ruleStringSimple on a string of spaces '    '
        
        '    '
        ->
        Node
            ' '
            ' '
            ' '
            ' '
        ->
        Node
            ' '
            ' '
            ' '
            ' '
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 " ",                0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 2))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))

        expected : ParseNode = root.copyDeep()

        result : ParseNode = self.parser.ruleStringSimple(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")
        
    def test_ruleStringSimple_ExceptionMismatched(self):
        """Tests fuleStringSimple raises an exception on mismatched quotes '\'test'"""

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\'",               0, 0))
        root.append(NodeParse(                                                  "",                 "test",             0, 1))

        self.assertRaises(Exception, self.parser.ruleStringSimple, root)

    def test_ruleStringSimple_ExceptionTreeNotNodeParse(self):
        """tests ruleStringSimple raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleStringSimple, tree)

    def test_ruleFilterLineComments_Integration01(self):
        """tests ruleFilterLineComments on a string 'Hello World!'
        
        'Hello World!'
        ->
        character = '#'
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))
        expected.append(NodeParse(                                              "",                 "!",                0, 11))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_Integration02(self):
        """tests ruleFilterLineComments on a string 'Hello World! #comment'
        
        'Hello World! #comment'
        ->
        character = '#'
        Node
            'Hello'
            ' '
            'World'
            '!'
            ' '
            '#'                         |
            'comment'                   |
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
            ' '                         _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))
        root.append(NodeParse(                                                  "",                 " ",                0, 12))
        root.append(NodeParse(                                                  "",                 "#",                0, 13))
        root.append(NodeParse(                                                  "",                 "comment",          0, 14))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))
        expected.append(NodeParse(                                              "",                 "!",                0, 11))
        expected.append(NodeParse(                                              "",                 " ",                0, 12))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_Integration03(self):
        """tests ruleFilterLineComments on a string 'test #test\n #test\n\t\\#test'
        
        'test #test\n #test\n\t\\#test'
        ->
        character = '#'
        Node
            'test'
            ' '
            '#'                         |
            'test'                      |
            '\n'
            ' '
            '#'                         |
            'test'                      |
            '\n'
            '\t'
            '\\'
            '#'
            'test'
        ->
        Node
            'test'
            ' '                         _V_
            '\n'                         A
            ' '                         _V_
            '\n'                         A
            '\t'
            '\\'
            '#'
            'test'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "#",                0, 5))
        root.append(NodeParse(                                                  "",                 "test",             0, 6))
        root.append(NodeParse(                                                  "",                 "\n",               0, 10))
        root.append(NodeParse(                                                  "",                 " ",                1, 0))
        root.append(NodeParse(                                                  "",                 "#",                1, 1))
        root.append(NodeParse(                                                  "",                 "test",             1, 2))
        root.append(NodeParse(                                                  "",                 "\n",               1, 6))
        root.append(NodeParse(                                                  "",                 "\t",               2, 0))
        root.append(NodeParse(                                                  "",                 "\\",               2, 1))
        root.append(NodeParse(                                                  "",                 "#",                2, 2))
        root.append(NodeParse(                                                  "",                 "test",             2, 3))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))
        expected.append(NodeParse(                                              "",                 "\n",               0, 10))
        expected.append(NodeParse(                                              "",                 " ",                1, 0))
        expected.append(NodeParse(                                              "",                 "\n",               1, 6))
        expected.append(NodeParse(                                              "",                 "\t",               2, 0))
        expected.append(NodeParse(                                              "",                 "\\",               2, 1))
        expected.append(NodeParse(                                              "",                 "#",                2, 2))
        expected.append(NodeParse(                                              "",                 "test",             2, 3))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_Integration04(self):
        """tests ruleFilterLineComments on a string 'test test \\# test #abc abc abc \\n abc \n test test'
        
        'test test \\# test #abc abc abc \\n abc \n test test'
        ->
        character = '#'
        Node
            'test'
            ' '
            'test'
            ' '
            '\\'
            '#'
            ' '
            'test'
            ' '
            '#'                         |
            'abc'                       |
            ' '                         |
            'abc'                       |
            ' '                         |
            'abc'                       |
            ' '                         |
            '\\'                        |
            'n'                         |
            ' '                         |
            'abc'                       |
            ' '                         |
            '\n'
            ' '
            'test'
            ' '
            'test'
        ->
        Node
            'test'
            ' '
            'test'
            ' '
            '\\'
            '#'
            ' '
            'test'
            ' '                         _V_
            '\n'                         A
            ' '
            'test'
            ' '
            'test'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "test",             0, 5))
        root.append(NodeParse(                                                  "",                 " ",                0, 9))
        root.append(NodeParse(                                                  "",                 "\\",               0, 10))
        root.append(NodeParse(                                                  "",                 "#",                0, 11))
        root.append(NodeParse(                                                  "",                 " ",                0, 12))
        root.append(NodeParse(                                                  "",                 "test",             0, 13))
        root.append(NodeParse(                                                  "",                 " ",                0, 17))
        root.append(NodeParse(                                                  "",                 "#",                0, 18))
        root.append(NodeParse(                                                  "",                 "abc",              0, 19))
        root.append(NodeParse(                                                  "",                 " ",                0, 22))
        root.append(NodeParse(                                                  "",                 "abc",              0, 23))
        root.append(NodeParse(                                                  "",                 " ",                0, 26))
        root.append(NodeParse(                                                  "",                 "abc",              0, 27))
        root.append(NodeParse(                                                  "",                 " ",                0, 30))
        root.append(NodeParse(                                                  "",                 "\\",               0, 31))
        root.append(NodeParse(                                                  "",                 "n",                0, 32))
        root.append(NodeParse(                                                  "",                 " ",                0, 33))
        root.append(NodeParse(                                                  "",                 "abc",              0, 34))
        root.append(NodeParse(                                                  "",                 " ",                0, 37))
        root.append(NodeParse(                                                  "",                 "\n",               0, 38))
        root.append(NodeParse(                                                  "",                 " ",                1, 0))
        root.append(NodeParse(                                                  "",                 "test",             1, 1))
        root.append(NodeParse(                                                  "",                 " ",                1, 5))
        root.append(NodeParse(                                                  "",                 "test",             1, 6))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))
        expected.append(NodeParse(                                              "",                 "test",             0, 5))
        expected.append(NodeParse(                                              "",                 " ",                0, 9))
        expected.append(NodeParse(                                              "",                 "\\",               0, 10))
        expected.append(NodeParse(                                              "",                 "#",                0, 11))
        expected.append(NodeParse(                                              "",                 " ",                0, 12))
        expected.append(NodeParse(                                              "",                 "test",             0, 13))
        expected.append(NodeParse(                                              "",                 " ",                0, 17))
        expected.append(NodeParse(                                              "",                 "\n",               0, 38))
        expected.append(NodeParse(                                              "",                 " ",                1, 0))
        expected.append(NodeParse(                                              "",                 "test",             1, 1))
        expected.append(NodeParse(                                              "",                 " ",                1, 5))
        expected.append(NodeParse(                                              "",                 "test",             1, 6))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_Empty(self):
        """tests ruleFilterLineComments on an empty string ''
        
        ''
        ->
        Node
        ->
        Node
        """

        root : ParseNode = NodeParse()

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_LineAllComment(self):
        """tests ruleFilterLineComments on a string '#comment'
        
        '#comment'
        ->
        character = '#'
        Node
            '#'                         |
            'comment'                   |
        ->
        Node                            _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "#",                0, 0))
        root.append(NodeParse(                                                  "",                 "comment",          0, 1))

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_LineAllComment_AlternateCharacter(self):
        """tests ruleFilterLineComments on a string '#comment', where the comment character is different
        
        '#comment'
        ->
        character in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|'
        Node
            character                   |
            'comment'                   |
        ->
        Node                            _V_
                                         A
        """

        characters : list[str] = [i for i in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|']

        character : str # chr
        for character in characters:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 character,          0, 0))
                root.append(NodeParse(                                          "",                 "comment",          0, 1))

                expected : ParseNode = NodeParse()

                result : ParseNode = self.parser.ruleFilterLineComments(root, character)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_MultipleLineAllComment(self):
        """tests ruleFilterLineComments on a string '#comment\n#comment'
        
        '#comment\n#comment'
        ->
        character = '#'
        Node
            '#'                         |
            'comment'                   |
            '\n'
            '#'                         |
            'comment'                   |
        ->
        Node                            _V_
            '\n'                         A  _V_
                                             A
        """         

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "#",                0, 0))
        root.append(NodeParse(                                                  "",                 "comment",          0, 1))
        root.append(NodeParse(                                                  "",                 "\n",               0, 9))
        root.append(NodeParse(                                                  "",                 "#",                0, 10))
        root.append(NodeParse(                                                  "",                 "comment",          0, 11))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "\n",               0, 9))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_MultipleLineAllComment_AlternateCharacter(self):
        """tests ruleFilterLineComments on a string '#comment\n#comment', where the comment character is different
        
        '#comment\n#comment'
        ->
        character in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|'
        Node
            character                   |
            'comment'                   |
            '\n'
            character                   |
            'comment'                   |
        ->
        Node                            _V_
            '\n'                         A  _V_
                                             A
        """

        characters : list[str] = [i for i in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|']

        character : str # chr
        for character in characters:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 character,          0, 0))
                root.append(NodeParse(                                          "",                 "comment",          0, 1))
                root.append(NodeParse(                                          "",                 "\n",               0, 9))
                root.append(NodeParse(                                          "",                 character,          0, 10))
                root.append(NodeParse(                                          "",                 "comment",          0, 11))

                expected : ParseNode = NodeParse()
                expected.append(NodeParse(                                      "",                 "\n",               0, 9))

                result : ParseNode = self.parser.ruleFilterLineComments(root, character)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_LineComment(self):
        """tests ruleFilterLineComments on a string 'test #comment'
        
        'test #comment'
        ->
        character = '#'
        Node
            'test'
            ' '
            '#'                         |
            'comment'                   |
        Node
            'test'
            ' '                         _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "#",                0, 5))
        root.append(NodeParse(                                                  "",                 "comment",          0, 6))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_LineComment_AlternateCharacter(self):
        """tests ruleFilterLineComments on a string 'test #comment', where the comment character is different
        
        'test #comment'
        ->
        character in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|'
        Node
            'test'
            ' '
            character                   |
            'comment'                   |
        ->
        Node
            'test'
            ' '                         _V_
                                         A
        """

        characters : list[str] = [i for i in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|']

        character : str # chr
        for character in characters:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "test",             0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 4))
                root.append(NodeParse(                                          "",                 character,          0, 5))
                root.append(NodeParse(                                          "",                 "comment",          0, 6))

                expected : ParseNode = NodeParse()
                expected.append(NodeParse(                                      "",                 "test",             0, 0))
                expected.append(NodeParse(                                      "",                 " ",                0, 4))

                result : ParseNode = self.parser.ruleFilterLineComments(root, character)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_MultipleLineComment01(self):
        """tests ruleFilterLineComments on a string 'test #comment\n#comment'
        
        'test #comment\n#comment'
        ->
        character = '#'
        Node
            'test'
            ' '
            '#'                         |
            'comment'                   |
            '\n'
            '#'                         |
            'comment'                   |
        ->
        Node
            'test'
            ' '                         _V_
            '\n'                         A  _V_
                                             A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "#",                0, 5))
        root.append(NodeParse(                                                  "",                 "comment",          0, 6))
        root.append(NodeParse(                                                  "",                 "\n",               0, 13))
        root.append(NodeParse(                                                  "",                 "#",                1, 0))
        root.append(NodeParse(                                                  "",                 "comment",          1, 1))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))
        expected.append(NodeParse(                                              "",                 "\n",               0, 13))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_MultipleLineComment02(self):
        """tests ruleFilterLineComments on a string 'test #comment\ntest2#comment'
        
        'test1 #comment\ntest2#comment'
        ->
        character = '#'
        Node
            'test1'
            ' '
            '#'                         |
            'comment'                   |
            '\n'
            'test2'
            '#'                         |
            'comment'                   |
        Node
            'test1'
            ' '                         _V_
            '\n'                         A
            'test2'                     _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "#",                0, 5))
        root.append(NodeParse(                                                  "",                 "comment",          0, 6))
        root.append(NodeParse(                                                  "",                 "\n",               0, 13))
        root.append(NodeParse(                                                  "",                 "test2",            1, 0))
        root.append(NodeParse(                                                  "",                 "#",                1, 0))
        root.append(NodeParse(                                                  "",                 "comment",          1, 1))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 4))
        expected.append(NodeParse(                                              "",                 "\n",               0, 13))
        expected.append(NodeParse(                                              "",                 "test2",            1, 0))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_MultipleLineComment_AlternateCharacter(self):
        """tests ruleFilterLineComments on a string 'test1 #comment\ntest2#comment', where the comment character is different
        
        'test1 #comment\ntest2#comment'
        ->
        character in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|'
        Node
            'test1'
            ' '
            character                   |
            'comment'                   |
            '\n'
            'test2'
            character                   |
            'comment'                   |
        Node
            'test1'
            ' '                         _V_
            '\n'                         A
            'test2'                     _V_
                                         A
        """

        characters : list[str] = [i for i in '!@#$%^&*()_+-=[]{};:\'\",.<>/?\\|']

        character : str # chr
        for character in characters:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "test1",            0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 5))
                root.append(NodeParse(                                          "",                 character,          0, 6))
                root.append(NodeParse(                                          "",                 "comment",          0, 7))
                root.append(NodeParse(                                          "",                 "\n",               0, 14))
                root.append(NodeParse(                                          "",                 "test2",            1, 0))
                root.append(NodeParse(                                          "",                 character,          1, 5))
                root.append(NodeParse(                                          "",                 "comment",          2, 6))

                expected : ParseNode = NodeParse()
                expected.append(NodeParse(                                      "",                 "test1",            0, 0))
                expected.append(NodeParse(                                      "",                 " ",                0, 5))
                expected.append(NodeParse(                                      "",                 "\n",               0, 14))
                expected.append(NodeParse(                                      "",                 "test2",            1, 0))

                result : ParseNode = self.parser.ruleFilterLineComments(root, character)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_EscapedCharacter(self):
        """tests ruleFilterLineComments on a string '\\#comment'
        
        '\\#comment'
        ->
        character = '#'
        Node
            '\\'
            '#'
            'comment'
        ->
        Node
            '\\'
            '#'
            'comment'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "\\",               0, 0))
        root.append(NodeParse(                                                  "",                 "#",                0, 1))
        root.append(NodeParse(                                                  "",                 "comment",          0, 2))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "\\",               0, 0))
        expected.append(NodeParse(                                              "",                 "#",                0, 1))
        expected.append(NodeParse(                                              "",                 "comment",          0, 2))

        result : ParseNode = self.parser.ruleFilterLineComments(root)

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_EscapedCharacter_AlternateCharacter(self):
        """tests ruleFilterLineComments on a string '\\#comment', where the comment character is different
        
        '\\#comment'
        ->
        character != '#'
        Node
            '\\'
            '#'
            'comment'
        ->
        Node
            '\\'
            '#'
            'comment'
        """

        characters : list[str] = ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '+', '=', '~', '`', '|', ';', ':', '\'', '\"', '<', '>', '?', '/', '.', ',']

        character : str # chr
        for character in characters:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "\\",               0, 0))
                root.append(NodeParse(                                          "",                 character,          0, 1))
                root.append(NodeParse(                                          "",                 "comment",          0, 2))

                expected : ParseNode = NodeParse()
                expected.append(NodeParse(                                      "",                 "\\",               0, 0))
                expected.append(NodeParse(                                      "",                 character,          0, 1))
                expected.append(NodeParse(                                      "",                 "comment",          0, 2))

                result : ParseNode = self.parser.ruleFilterLineComments(root, character)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleFilterLineComments_ExceptionCharacterNone(self):
        """tests ruleFilterLineComments raises an exception when character = None"""

        root : ParseNode = NodeParse()

        self.assertRaises(AssertionError, self.parser.ruleFilterLineComments, root, None)

    def test_ruleFilterLineComments_ExceptionCharacterWrongType(self):
        """tests ruleFilterLineComments raises an exception when character is wrong type"""

        character : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, NodeParse(), ('a',), {'a',}]

        character : Any
        for character in character:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()

                self.assertRaises(AssertionError, self.parser.ruleFilterLineComments, root, character)

    def test_ruleFilterLineComments_ExceptionCharacterWrongLength(self):
        """tests ruleFilterLineComments raises an exception when character is wrong length"""

        characters : list[str] = ["".join(["a" for _ in range(i)]) for i in range(2, 32)]

        character : str
        for character in characters:
            with self.subTest(character=character):
                root : ParseNode = NodeParse()

                self.assertRaises(AssertionError, self.parser.ruleFilterLineComments, root, character)

    def test_ruleFilterLineComments_ExceptionTreeNotNodeParse(self):
        """tests ruleFilterLineComments raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleFilterLineComments, tree)

    def test_ruleRemoveToken_Integration01(self):
        """tests ruleRemoveToken on a string 'Hello World!', removing nothing
        
        'Hello World!'
        ->
        token = 'test'
        Node
            'Hello'
            ' '
            'World'
            '!'
        ->
        Node
            'Hello'
            ' '
            'World'
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = root.copyDeep()

        result : ParseNode = self.parser.ruleRemoveToken(root, "test")
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_Integration02(self):
        """tests ruleRemoveToken on a string 'Hello World!', removing ' '
        
        'Hello World!'
        ->
        token = ' '
        Node
            'Hello'
            ' '                         |
            'World'
            '!'
        ->
        Node
            'Hello'                     _V_
            'World'                      A
            '!'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "!",                0, 11))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))
        expected.append(NodeParse(                                              "",                 "!",                0, 11))

        result : ParseNode = self.parser.ruleRemoveToken(root, " ")
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_Integration03(self):
        """tests ruleRemoveToken on a string 'test1\ntest2', removing '\n'
        
        'test1\ntest2'
        ->
        token = '\n'
        Node
            'test1'
            '\n'                        |
            'test2'
        ->
        Node
            'test1'                     _V_
            'test2'                      A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 5))
        root.append(NodeParse(                                                  "",                 "test2",            0, 6))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test1",            0, 0))
        expected.append(NodeParse(                                              "",                 "test2",            0, 6))

        result : ParseNode = self.parser.ruleRemoveToken(root, "\n")
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_Integration04(self):
        """tests ruleRemoveToken on a string 'add(arg1,arg2),mult(arg1,arg2)' (brackets are removed), removing ','
        
        'add(arg1,arg2),mult(arg1,arg2)'
        ->
        token = ','
        recurse = True
        Node
            'add'
                'arg1'
                ','                     |
                'arg2'
            ','                         |
            'mult'
                'arg1'
                ','                     |
                'arg2'
        ->
        Node
            'add'
                'arg1'                  _V_
                'arg2'                   A  _V_
            'mult'                           A
                'arg1'                  _V_
                'arg2'                   A
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode
        rChild1 = NodeParse(                                                    "",                 "add",              0, 0)
        rChild1.append(NodeParse(                                               "",                 "arg1",             0, 5))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 9))
        rChild1.append(NodeParse(                                               "",                 "arg2",             0, 10))
        root.append(rChild1)
        root.append(NodeParse(                                                  "",                 ",",                0, 16))
        rChild2 : ParseNode
        rChild2 = NodeParse(                                                    "",                 "mult",             0, 4)
        rChild2.append(NodeParse(                                               "",                 "arg1",             0, 10))
        rChild2.append(NodeParse(                                               "",                 ",",                0, 14))
        rChild2.append(NodeParse(                                               "",                 "arg2",             0, 15))
        root.append(rChild2)

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode
        eChild1 = NodeParse(                                                    "",                 "add",              0, 0)
        eChild1.append(NodeParse(                                               "",                 "arg1",             0, 5))
        eChild1.append(NodeParse(                                               "",                 "arg2",             0, 10))
        expected.append(eChild1)
        eChild2 : ParseNode
        eChild2 = NodeParse(                                                    "",                 "mult",             0, 4)
        eChild2.append(NodeParse(                                               "",                 "arg1",             0, 10))
        eChild2.append(NodeParse(                                               "",                 "arg2",             0, 15))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleRemoveToken(root, ",")
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_Integration05(self):
        """tests ruleRemoveToken on a string 'add(arg1,arg2),mult(arg1,arg2)' (brackets are removed), removing ',', no recursion
        
        'add(arg1,arg2),mult(arg1,arg2)'
        ->
        token = ','
        recurse = False
        Node
            'add'
                'arg1'
                ','
                'arg2'
            ','                         |
            'mult'
                'arg1'
                ','
                'arg2'
        ->
        Node
            'add'
                'arg1'
                ','
                'arg2'                  _V_
            'mult'                       A
                'arg1'
                ','
                'arg2'
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode
        rChild1 = NodeParse(                                                    "",                 "add",              0, 0)
        rChild1.append(NodeParse(                                               "",                 "arg1",             0, 5))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 9))
        rChild1.append(NodeParse(                                               "",                 "arg2",             0, 10))
        root.append(rChild1)
        root.append(NodeParse(                                                  "",                 ",",                0, 16))
        rChild2 : ParseNode
        rChild2 = NodeParse(                                                    "",                 "mult",             0, 4)
        rChild2.append(NodeParse(                                               "",                 "arg1",             0, 10))
        rChild2.append(NodeParse(                                               "",                 ",",                0, 14))
        rChild2.append(NodeParse(                                               "",                 "arg2",             0, 15))
        root.append(rChild2)

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode
        eChild1 = NodeParse(                                                    "",                 "add",              0, 0)
        eChild1.append(NodeParse(                                               "",                 "arg1",             0, 5))
        eChild1.append(NodeParse(                                               "",                 ",",                0, 9))
        eChild1.append(NodeParse(                                               "",                 "arg2",             0, 10))
        expected.append(eChild1)
        eChild2 : ParseNode
        eChild2 = NodeParse(                                                    "",                 "mult",             0, 4)
        eChild2.append(NodeParse(                                               "",                 "arg1",             0, 10))
        eChild2.append(NodeParse(                                               "",                 ",",                0, 14))
        eChild2.append(NodeParse(                                               "",                 "arg2",             0, 15))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleRemoveToken(root, ",", False)
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_Integration06(self):
        """tests ruleRemoveToken on a string 'a[1,2,3],b[1,2,3],c[1,b,3]' (brackets are not removed, but are folded in as children), removing 'b'
        
        'a[1,2,3],b[1,2,3],c[1,b,3]'
        ->
        token = 'b'
        Node
            'a'
                '['
                '1'
                ','
                '2'
                ','
                '3'
                ']'
            ','
            'b'                         |
                '['                     |
                '1'                     |
                ','                     |
                '2'                     |
                ','                     |
                '3'                     |
                ']'                     |
            ','
            'c'
                '['
                '1'
                ','
                'b'
                ','
                '3'
                ']'
        ->
        Node
            'a'
                '['
                '1'
                ','
                '2'
                ','
                '3'
                ']'
            ','                         _V_
            ','                          A
            'c'
                '['
                '1'
                ','
                'b'
                ','
                '3'
                ']'
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode
        rChild1 = NodeParse(                                                    "",                 "a",                0, 0)
        rChild1.append(NodeParse(                                               "",                 "[",                0, 1))
        rChild1.append(NodeParse(                                               "",                 "1",                0, 2))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 3))
        rChild1.append(NodeParse(                                               "",                 "2",                0, 4))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 5))
        rChild1.append(NodeParse(                                               "",                 "3",                0, 6))
        rChild1.append(NodeParse(                                               "",                 "]",                0, 7))
        root.append(rChild1)
        root.append(NodeParse(                                                  "",                 ",",                0, 8))
        rChild2 : ParseNode
        rChild2 = NodeParse(                                                    "",                 "b",                0, 9)
        rChild2.append(NodeParse(                                               "",                 "[",                0, 10))
        rChild2.append(NodeParse(                                               "",                 "1",                0, 11))
        rChild2.append(NodeParse(                                               "",                 ",",                0, 12))
        rChild2.append(NodeParse(                                               "",                 "2",                0, 13))
        rChild2.append(NodeParse(                                               "",                 ",",                0, 14))
        rChild2.append(NodeParse(                                               "",                 "3",                0, 15))
        rChild2.append(NodeParse(                                               "",                 "]",                0, 16))
        root.append(rChild2)
        root.append(NodeParse(                                                  "",                 ",",                0, 17))
        rChild3 : ParseNode
        rChild3 = NodeParse(                                                    "",                 "c",                0, 18)
        rChild3.append(NodeParse(                                               "",                 "[",                0, 19))
        rChild3.append(NodeParse(                                               "",                 "1",                0, 20))
        rChild3.append(NodeParse(                                               "",                 ",",                0, 21))
        rChild3.append(NodeParse(                                               "",                 "b",                0, 22))
        rChild3.append(NodeParse(                                               "",                 ",",                0, 23))
        rChild3.append(NodeParse(                                               "",                 "3",                0, 24))
        rChild3.append(NodeParse(                                               "",                 "]",                0, 25))
        root.append(rChild3)

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode
        eChild1 = NodeParse(                                                    "",                 "a",                0, 0)
        eChild1.append(NodeParse(                                               "",                 "[",                0, 1))
        eChild1.append(NodeParse(                                               "",                 "1",                0, 2))
        eChild1.append(NodeParse(                                               "",                 ",",                0, 3))
        eChild1.append(NodeParse(                                               "",                 "2",                0, 4))
        eChild1.append(NodeParse(                                               "",                 ",",                0, 5))
        eChild1.append(NodeParse(                                               "",                 "3",                0, 6))
        eChild1.append(NodeParse(                                               "",                 "]",                0, 7))
        expected.append(eChild1)
        expected.append(NodeParse(                                              "",                 ",",                0, 8))
        expected.append(NodeParse(                                              "",                 ",",                0, 17))
        eChild2 : ParseNode
        eChild2 = NodeParse(                                                    "",                 "c",                0, 18)
        eChild2.append(NodeParse(                                               "",                 "[",                0, 19))
        eChild2.append(NodeParse(                                               "",                 "1",                0, 20))
        eChild2.append(NodeParse(                                               "",                 ",",                0, 21))
        eChild2.append(NodeParse(                                               "",                 ",",                0, 23))
        eChild2.append(NodeParse(                                               "",                 "3",                0, 24))
        eChild2.append(NodeParse(                                               "",                 "]",                0, 25))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleRemoveToken(root, "b", True)
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")


    def test_ruleRemoveToken_Empty(self):
        """tests ruleRemoveToken on an empty string ''
        
        ''
        ->
        token = ','
        Node
        ->
        Node
        """

        root : ParseNode = NodeParse()

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleRemoveToken(root, ",")
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_RemoveToken01(self):
        """tests ruleRemoveToken on a string 'test', removing 'test'
        
        'test'
        ->
        token = 'test'
        Node
            'test'                      |
        ->
        Node                            _V_
                                         A
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleRemoveToken(root, "test")
        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_RemoveToken02(self):
        """tests ruleRemoveToken on a string f'{token}', removing token
        
        f'{token}'
        ->
        token = token
        Node
            token                       |
        ->
        Node                            _V_
                                         A
        """

        tokens : list[Any] = [None, 0, False, 'a', [0], {0 : 'a'}, ('a',), {'a',}]

        token : Any
        for token in tokens:
            with self.subTest(token=token):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 token,              0, 0))

                expected : ParseNode = NodeParse()

                result : ParseNode = self.parser.ruleRemoveToken(root, token)
                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_RemoveToken03(self):
        """tests ruleRemoveToken on a string f'Hello {token}', removing token
        
        f'Hello {token}'
        ->
        token = token
        Node
            'Hello'
            ' '
            token                       |
        ->
        Node
            'Hello'
            ' '                         _V_
                                         A
        """

        tokens : list[Any] = [None, 0, False, 'a', [0], {0 : 'a'}, ('a',), {'a',}]

        token : Any
        for token in tokens:
            with self.subTest(token=token):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "Hello",            0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 6))
                root.append(NodeParse(                                          "",                 token,              0, 7))

                expected : ParseNode = NodeParse()
                expected.append(NodeParse(                                      "",                 "Hello",            0, 0))
                expected.append(NodeParse(                                      "",                 " ",                0, 6))

                result : ParseNode = self.parser.ruleRemoveToken(root, token)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_TokenWithChildren(self):
        """tests ruleRemoveToken on a string 'a[1,2,3]'  (brackets are not removed, but are folded in as children), removing 'a' and all children
        
        'a[1,2,3]'
        ->
        token = 'a'
        Node
            'a'                         |
                '['                     |
                    '1'                 |
                    ','                 |
                    '2'                 |
                    ','                 |
                    '3'                 |
                    ']'                 |
        ->
        Node                            _V_
                                         A
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode
        rChild1 = NodeParse(                                                    "",                 "a",                0, 0)
        rChild2 : ParseNode
        rChild2 = NodeParse(                                                    "",                 "[",                0, 1)
        rChild2.append(NodeParse(                                               "",                 "1",                0, 2))
        rChild2.append(NodeParse(                                               "",                 ",",                0, 3))
        rChild2.append(NodeParse(                                               "",                 "2",                0, 4))
        rChild2.append(NodeParse(                                               "",                 ",",                0, 5))
        rChild2.append(NodeParse(                                               "",                 "3",                0, 6))
        rChild2.append(NodeParse(                                               "",                 "]",                0, 7))
        rChild1.append(rChild2)
        root.append(rChild1)

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleRemoveToken(root, "a")

        self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")
        
    def test_ruleRemoveToken_TokenDifferentTypes(self):
        """tests ruleRemoveToken on different token types"""

        tokens : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        token : Any
        for token in tokens:
            with self.subTest(token=token):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 token,              0, 0))

                expected : ParseNode = NodeParse()

                result : ParseNode = self.parser.ruleRemoveToken(root, token)

                self.assertEqual(True, expected.dataEqual(result), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleRemoveToken_ExceptionTreeNotNodeParse(self):
        """tests ruleRemoveToken raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleRemoveToken, tree, None)

    def test_ruleRemoveToken_ExceptionRecurseNotBool(self):
        """tests ruleRemoveToken raises an exception when recurse is not a boolean"""

        variables : list[Any] = [None, 0, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        variable : Any
        for variable in variables:
            with self.subTest(variable=variable):
                self.assertRaises(AssertionError, self.parser.ruleRemoveToken, NodeParse(), None, variable)

    def test_ruleSplitLines_ExceptionSplitTokenNotString(self):
        """tests ruleSplitLines raises an exception when splitToken is not a string"""

        splitTokens : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        splitToken : Any
        for splitToken in splitTokens:
            with self.subTest(splitToken=splitToken):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "Hello",            0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 6))
                root.append(NodeParse(                                          "",                 "World",            0, 7))

                self.assertRaises(AssertionError, self.parser.ruleSplitLines, root, splitToken=splitToken)

    def test_ruleSplitLines_ExceptionSplitTokenEmpty(self):
        """tests ruleSplitLines raises an exception when splitToken is an empty string"""

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))

        self.assertRaises(AssertionError, self.parser.ruleSplitLines, root, splitToken="")

    def test_ruleSplitLines_ExceptionTokenTypeNotString(self):
        """tests ruleSplitLines raises an exception when tokenType is not a string"""

        tokenTypes : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        tokenType : Any
        for tokenType in tokenTypes:
            with self.subTest(tokenType=tokenType):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "Hello",            0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 6))
                root.append(NodeParse(                                          "",                 "World",            0, 7))

                self.assertRaises(AssertionError, self.parser.ruleSplitLines, root, tokenType=tokenType)

    def test_ruleSplitLines_ExceptionTreeNotNodeParse(self):
        """tests ruleSplitLines raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleSplitLines, tree)

    def test_ruleSplitLines_Integration01(self):
        """tests ruleSplitLines on a string 'Hello World'
        
        'Hello World'
        ->
        splitToken = '\n'
        Node
            'Hello'
            ' '
            'World'
        ->
        [
            'Hello'
            ' '
            'World'
        ]
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))

        expected : list[ParseNode] = []
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1.append(NodeParse(                                               "",                 "Hello",            0, 0))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 6))
        eChild1.append(NodeParse(                                               "",                 "World",            0, 7))
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleSplitLines(root)
    
        self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_Integration02(self):
        """tests ruleSplitLines on a string 'test1\ntest2'
        
        'test1\ntest2'
        ->
        splitToken = '\n'
        Node
            'test1'
            '\n'                        |
            'test2'
        ->
        [
            Node            
                'test1'                 _A_
            Node                         V
                'test2'
        ]
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 5))
        root.append(NodeParse(                                                  "",                 "test2",            0, 6))

        expected : list[ParseNode] = []
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1.append(NodeParse(                                               "",                 "test1",            0, 0))
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        eChild2.append(NodeParse(                                               "",                 "test2",            0, 6))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitLines(root)

        self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_Integration03(self):
        """tests ruleSplitLines on a string 'test1\ntest2\n'
        
        'test1\ntest2\n'
        ->
        splitLines = '\n'
        Node
            'test1'
            '\n'                        |
            'test2'
            '\n'                        |
        ->
        [
            Node
                'test1'                 _A_
            Node                         V
                'test2'                 _A_
        ]
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 5))
        root.append(NodeParse(                                                  "",                 "test2",            0, 6))
        root.append(NodeParse(                                                  "",                 "\n",               0, 11))

        expected : list[ParseNode] = []
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1.append(NodeParse(                                               "",                 "test1",            0, 0))
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        eChild2.append(NodeParse(                                               "",                 "test2",            0, 6))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitLines(root)

        self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_Integration04(self):
        """tests RuleSplitLines on a string 'test1\ttest2'
        
        'test1\ttest2'
        ->
        splitToken = '\t'
        Node
            'test1'
            '\t'                        |
            'test2'
        ->
        [
            Node
                'test1'                 _A_
            Node                         V
                'test2'
        ]
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 "\t",               0, 5))
        root.append(NodeParse(                                                  "",                 "test2",            0, 6))

        expected : list[ParseNode] = []
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1.append(NodeParse(                                               "",                 "test1",            0, 0))
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        eChild2.append(NodeParse(                                               "",                 "test2",            0, 6))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitLines(root, splitToken="\t")

        self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_Integration05(self):
        """tests ruleSplitLines on a string '[test1]\t[test2\ttest3]'
        
        '[test1]\t[test2\ttest3]'
        ->
        splitToken = '\n'
        Node
            Node
                'test1'
            '\t'                        |
            Node
                'test2'
                '\t'
                'test3'
        ->
        [
            Node
                'test1'                 _A_
            Node                         V
                Node
                    'test2'
                    '\t'
                    'test3'
        ]
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        rChild1.append(NodeParse(                                               "",                 "test1",            0, 0))
        root.append(rChild1)
        root.append(NodeParse(                                                  "",                 "\t",               0, 5))
        rChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        rChild2.append(NodeParse(                                               "",                 "test2",            0, 6))
        rChild2.append(NodeParse(                                               "",                 "\t",               0, 11))
        rChild2.append(NodeParse(                                               "",                 "test3",            0, 12))
        root.append(rChild2)

        expected : list[ParseNode] = []
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild2.append(NodeParse(                                               "",                 "test1",            0, 0))
        eChild1.append(eChild2)
        expected.append(eChild1)
        eChild3 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        eChild4 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        eChild4.append(NodeParse(                                               "",                 "test2",            0, 6))
        eChild4.append(NodeParse(                                               "",                 "\t",               0, 11))
        eChild4.append(NodeParse(                                               "",                 "test3",            0, 12))
        eChild3.append(eChild4)
        expected.append(eChild3)

        result : ParseNode = self.parser.ruleSplitLines(root, splitToken="\t")

        self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_DifferentSplitTokens01(self):
        """tests ruleSplitLines on a string 'test1{splitToken}test2' where splitToken is in "`~!@#$%^&*()_+-={}[]|\\;:\'\",./<>? \n\t\b\r" 
        
        'test1{splitToken}test2'
        ->
        splitToken in "`~!@#$%^&*()_+-={}[]|\\;:\'\",./<>? \n\t\b\r"
        Node
            'test1'
            splitToken                  |
            'test2'
        ->
        [
            Node
                'test1'                 _A_
            Node                         V
                'test2'        
        ]
        """

        splitTokens : list[str] = [i for i in "`~!@#$%^&*()_+-={}[]|\\;:\'\",./<>? \n\t\b\r"]

        splitToken : str
        for splitToken in splitTokens:
            with self.subTest(splitToken=splitToken):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "test1",            0, 0))
                root.append(NodeParse(                                          "",                 splitToken,         0, 5))
                root.append(NodeParse(                                          "",                 "test2",            0, 6))

                expected : list[ParseNode] = []
                eChild1 : ParseNode = NodeParse(                                typeStr="line",                         lineNum=0, charNum=0)
                eChild1.append(NodeParse(                                       "",                 "test1",            0, 0))
                expected.append(eChild1)
                eChild2 : ParseNode = NodeParse(                                typeStr="line",                         lineNum=0, charNum=6)
                eChild2.append(NodeParse(                                       "",                 "test2",            0, 6))
                expected.append(eChild2)

                result : ParseNode = self.parser.ruleSplitLines(root, splitToken=splitToken)

                self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_DifferentSplitTokens02(self):
        """tests ruleSplitLines on a string 'test1\u2665test2' where splittoken is NOT found in "`~!@#$%^&*()_+-={}[]|\\;:\'\",./<>? \n\t\b\r" 
        
        'test1\u2665test2'
        ->
        splitToken in "`~!@#$%^&*()_+-={}[]|\\;:\'\",./<>? \n\t\b\r"
        Node
            'test1'
            '\u2665'
            'test2'
        ->
        [
            Node
                'test1'
                '\u2665'
                'test2'
        ]
        """

        splitTokens : list[str] = [i for i in "`~!@#$%^&*()_+-={}[]|\\;:\'\",./<>? \n\t\b\r"]

        splitToken : str
        for splitToken in splitTokens:
            with self.subTest(splitToken=splitToken):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "test1",            0, 0))
                root.append(NodeParse(                                          "",                 "\u2665",           0, 5))
                root.append(NodeParse(                                          "",                 "test2",            0, 6))

                expected : list[ParseNode] = []
                eChild1 : ParseNode = NodeParse(                                typeStr="line",                 lineNum=0, charNum=0)
                eChild1.append(NodeParse(                                       "",                 "test1",            0, 0))
                eChild1.append(NodeParse(                                       "",                 "\u2665",           0, 5))
                eChild1.append(NodeParse(                                       "",                 "test2",            0, 6))
                expected.append(eChild1)

                result : ParseNode = self.parser.ruleSplitLines(root, splitToken=splitToken)

                self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitLines_Empty(self):
        """tests ruleSplitLines on an empty string
        
        ''
        ->
        Node
        ->
        [
        ]
        """

        root : ParseNode = NodeParse()

        expected : list[ParseNode] = []

        result : ParseNode = self.parser.ruleSplitLines(root)

        self.assertEqual(True, all([i.dataEqual(j) for i, j in zip(expected, result)]), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_ExceptionTreeNotNodeParse(self):
        """tests ruleSplitTokens raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleSplitTokens, tree)

    def test_ruleSplitTokens_ExceptionTokenTypeNotString(self):
        """tests ruleSplitTokens raises an exception when tokenType is not a string"""

        tokenTypes : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        tokenType : Any
        for tokenType in tokenTypes:
            with self.subTest(tokenType=tokenType):
                root : ParseNode = NodeParse()

                self.assertRaises(AssertionError, self.parser.ruleSplitTokens, root, tokenType=tokenType)


    def test_ruleSplitTokens_ExceptionSplitTokenNotString(self):
        """tests ruleSplitTokens raises an exception when splitToken is not a string"""

        splitTokens : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        splitToken : Any
        for splitToken in splitTokens:
            with self.subTest(splitToken=splitToken):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "Hello",            0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 6))
                root.append(NodeParse(                                          "",                 "World",            0, 7))

                self.assertRaises(AssertionError, self.parser.ruleSplitTokens, root, splitToken=splitToken)

    def test_ruleSplitTokens_ExceptionRecurseNotBool(self):
        """tests ruleSplitTokens raises an exception when recurse is not a bool"""

        recurses : list[Any] = [None, 0, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        recurse : Any
        for recurse in recurses:
            with self.subTest(recurse=recurse):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 "Hello",            0, 0))
                root.append(NodeParse(                                          "",                 " ",                0, 6))
                root.append(NodeParse(                                          "",                 "World",            0, 7))

                self.assertRaises(AssertionError, self.parser.ruleSplitTokens, root, recurse=recurse)

    def test_ruleSplitTokens_Integration01(self):
        """tests ruleSplitTokens on a string 'Hello World'
        
        'Hello World'
        ->
        splitToken = '\n'
        Node
            'Hello'
            ' '
            'World'
        ->
        Node
            'Hello'
            ' '
            'World'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 6))
        expected.append(NodeParse(                                              "",                 "World",            0, 7))

        result : ParseNode = self.parser.ruleSplitTokens(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration02(self):
        """tests ruleSplitTokens on a string 'Hello World' where splittoken is ' '
        
        'Hello World'
        ->
        splitToken = ' '
        Node
            'Hello'
            ' '                         |
            'World'
        ->
        Node
            Node
                'Hello'                 _V_
            Node                         A
                'World'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1.append(NodeParse(                                               "",                 "Hello",            0, 0))
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=7)
        eChild2.append(NodeParse(                                               "",                 "World",            0, 7))
        expected.append(eChild1)
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=" ")

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration03(self):
        """tests ruleSplitTokens on a string 'test\nabc' where splittoken is '\n'
        
        'test\nabc'
        ->
        splitToken = '\n'
        Node
            'test'
            '\n'                        |
            'abc'
        ->
        Node
            Node
                'test'                  _V_
            Node                         A
                'abc'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 "\n",               0, 4))
        root.append(NodeParse(                                                  "",                 "abc",              0, 5))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1.append(NodeParse(                                               "",                 "test",             0, 0))
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=5)
        eChild2.append(NodeParse(                                               "",                 "abc",              0, 5))
        expected.append(eChild1)
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken="\n")

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration04(self):
        """tests ruleSplitTokens on a string 'test1 test2[abc1,abc2,abc3 abc4]' where splittoken is ',' and recurse is True
        
        'test1 test2[abc1,abc2,abc3 abc4]'
        ->
        splitToken = ','
        recurse = True
        Node
            'test1'
            ' '
            'test2'
                'abc1'
                ','                     |
                'abc2'
                ','                     |
                'abc3'
                ' '
                'abc4'
        ->
        Node
            'test1'
            ' '
            'test2'
                Node
                    'abc1'              _V_
                Node                     A
                    'abc2'              _V_
                Node                     A
                    'abc3'
                    ' '
                    'abc4'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        rChild1 : ParseNode = NodeParse(                                        "",                 "test2",            0, 6)
        rChild1.append(NodeParse(                                               "",                 "abc1",             0, 12))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 16))
        rChild1.append(NodeParse(                                               "",                 "abc2",             0, 17))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 21))
        rChild1.append(NodeParse(                                               "",                 "abc3",             0, 22))
        rChild1.append(NodeParse(                                               "",                 " ",                0, 26))
        rChild1.append(NodeParse(                                               "",                 "abc4",             0, 27))
        root.append(rChild1)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test1",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        eChild1 : ParseNode = NodeParse(                                        "",                 "test2",            0, 6)
        eChild1A : ParseNode = NodeParse(                                       typeStr="line",                         lineNum=0, charNum=12)
        eChild1A.append(NodeParse(                                              "",                 "abc1",             0, 12))
        eChild1B : ParseNode = NodeParse(                                       typeStr="line",                         lineNum=0, charNum=17)
        eChild1B.append(NodeParse(                                              "",                 "abc2",             0, 17))
        eChild1C : ParseNode = NodeParse(                                       typeStr="line",                         lineNum=0, charNum=22)
        eChild1C.append(NodeParse(                                              "",                 "abc3",             0, 22))
        eChild1C.append(NodeParse(                                              "",                 " ",                0, 26))
        eChild1C.append(NodeParse(                                              "",                 "abc4",             0, 27))
        eChild1.append(eChild1A)
        eChild1.append(eChild1B)
        eChild1.append(eChild1C)
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=True)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration05(self):
        """tests ruleSplitTokens on a string 'test1 test2[abc1,abc2,abc3 abc4]' where splittoken is ',' and recurse is False
        
        'test1 test2[abc1,abc2,abc3 abc4]'
        ->
        splitToken = ','
        recurse = False
        Node
            'test1'
            ' '
            'test2'
                'abc1'
                ','
                'abc2'
                ','
                'abc3'
                ' '
                'abc4'
        ->
        Node
            'test1'
            ' '
            'test2'
                'abc1'
                ','
                'abc2'
                ','
                'abc3'
                ' '
                'abc4'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        rChild1 : ParseNode = NodeParse(                                        "",                 "test2",            0, 6)
        rChild1.append(NodeParse(                                               "",                 "abc1",             0, 11))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 13))
        rChild1.append(NodeParse(                                               "",                 "abc2",             0, 15))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 17))
        rChild1.append(NodeParse(                                               "",                 "abc3",             0, 19))
        rChild1.append(NodeParse(                                               "",                 " ",                0, 23))
        rChild1.append(NodeParse(                                               "",                 "abc4",             0, 24))
        root.append(rChild1)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test1",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        eChild1 : ParseNode = NodeParse(                                        "",                 "test2",            0, 6)
        eChild1.append(NodeParse(                                               "",                 "abc1",             0, 11))
        eChild1.append(NodeParse(                                               "",                 ",",                0, 13))
        eChild1.append(NodeParse(                                               "",                 "abc2",             0, 15))
        eChild1.append(NodeParse(                                               "",                 ",",                0, 17))
        eChild1.append(NodeParse(                                               "",                 "abc3",             0, 19))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 23))
        eChild1.append(NodeParse(                                               "",                 "abc4",             0, 24))
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration06(self):
        """tests ruleSplitTokens on a string 'test1[abc1,abc2],test2' where splittoken is ',' and recurse is True
        
        'test1[abc1,abc2],test2'
        ->
        splitToken = ','
        recurse = True
        Node
            'test1'
                'abc1'
                ','                     |
                'abc2'
            ','                         |
            'test2'
        ->
        Node
            Node
                'test1'
                    Node
                        'abc1'          _V_
                    Node                 A
                        'abc2'          _V_
            Node                         A
                'test2'
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode = NodeParse(                                        "",                 "test1",            0, 0)
        rChild1.append(NodeParse(                                               "",                 "abc1",             0, 6))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 10))
        rChild1.append(NodeParse(                                               "",                 "abc2",             0, 11))
        root.append(rChild1)
        root.append(NodeParse(                                                  "",                 ",",                0, 16))
        root.append(NodeParse(                                                  "",                 "test2",            0, 17))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1A : ParseNode = NodeParse(                                       "",                 "test1",            0, 0)
        eChild1A1 : ParseNode = NodeParse(                                      typeStr="line",                         lineNum=0, charNum=6)
        eChild1A1.append(NodeParse(                                             "",                 "abc1",             0, 6))
        eChild1A.append(eChild1A1)
        eChild1A2 : ParseNode = NodeParse(                                      typeStr="line",                         lineNum=0, charNum=11)
        eChild1A2.append(NodeParse(                                             "",                 "abc2",             0, 11))
        eChild1A.append(eChild1A2)
        eChild1.append(eChild1A)
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=17)
        eChild2.append(NodeParse(                                               "",                 "test2",            0, 17))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=True)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration07(self):
        """tests ruleSplitTokens on a string 'test1[abc1,abc2],test2' where splittoken is ',' and recurse is False
        
        'test1[abc1,abc2],test2'
        ->
        splitToken = ','
        recurse = False
        Node
            'test1'
                'abc1'
                ','
                'abc2'
            ','                         |
            'test2'
        ->
        Node
            Node
                'test1'
                    'abc1'
                    ','
                    'abc2'              _V_
            Node                         A
                'test2'
        """

        root : ParseNode = NodeParse()
        rChild1 : ParseNode = NodeParse(                                        "",                 "test1",            0, 0)
        rChild1.append(NodeParse(                                               "",                 "abc1",             0, 6))
        rChild1.append(NodeParse(                                               "",                 ",",                0, 10))
        rChild1.append(NodeParse(                                               "",                 "abc2",             0, 11))
        root.append(rChild1)
        root.append(NodeParse(                                                  "",                 ",",                0, 16))
        root.append(NodeParse(                                                  "",                 "test2",            0, 17))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1A : ParseNode = NodeParse(                                       "",                 "test1",            0, 0)
        eChild1A.append(NodeParse(                                              "",                 "abc1",             0, 6))
        eChild1A.append(NodeParse(                                              "",                 ",",                0, 10))
        eChild1A.append(NodeParse(                                              "",                 "abc2",             0, 11))
        eChild1.append(eChild1A)
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=17)
        eChild2.append(NodeParse(                                               "",                 "test2",            0, 17))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Integration08(self):
        """tests ruleSplitTokens on a string 'test1 test2 test3' where splittoken is ',' is not found
        
        'test1 test2 test3'
        ->
        splitToken = ','
        Node
            'test1'
            ' '
            'test2'
            ' '
            'test3'
        ->
        Node
            'test1'
            ' '
            'test2'
            ' '
            'test3'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "test2",            0, 6))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        root.append(NodeParse(                                                  "",                 "test3",            0, 12))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test1",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "test2",            0, 6))
        expected.append(NodeParse(                                              "",                 " ",                0, 11))
        expected.append(NodeParse(                                              "",                 "test3",            0, 12))

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_Empty(self):
        """tests ruleSplitTokens on an empty string
        
        ''
        ->
        Node
        ->
        Node
        """

        root : ParseNode = NodeParse(typeStr="root")

        expected : ParseNode = NodeParse(typeStr="root")

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleSplitTokens_FlatTokenFound(self):
        """tests ruleSplitTokens on a string 'test1,test2,test3' where splittoken is ','
        
        'test1,test2,test3'
        ->
        splittoken = ','
        Node
            'test1'
            ','                         |
            'test2'
            ','                         |
            'test3'
        ->
        Node
            Node
                'test1'                 _V_
            Node                         A
                'test2'                 _V_
            Node                         A
                'test3'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test1",            0, 0))
        root.append(NodeParse(                                                  "",                 ",",                0, 5))
        root.append(NodeParse(                                                  "",                 "test2",            0, 6))
        root.append(NodeParse(                                                  "",                 ",",                0, 11))
        root.append(NodeParse(                                                  "",                 "test3",            0, 12))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=0)
        eChild1A : ParseNode = NodeParse(                                       "",                 "test1",            0, 0)
        eChild1.append(eChild1A)
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=6)
        eChild2.append(NodeParse(                                               "",                 "test2",            0, 6))
        expected.append(eChild2)
        eChild3 : ParseNode = NodeParse(                                        typeStr="line",                         lineNum=0, charNum=12)
        eChild3.append(NodeParse(                                               "",                 "test3",            0, 12))
        expected.append(eChild3)

        result : ParseNode = self.parser.ruleSplitTokens(root, splitToken=",", recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_ExceptionTreeNotNodeParse(self):
        """tests ruleLowerCase raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleLowerCase, tree)

    def test_ruleLowerCase_ExceptionRecurseNotBool(self):
        """tests ruleLowerCase raises an exception when recurse is not a bool"""

        recurses : list[Any] = [None, 0, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        recurse : Any
        for recurse in recurses:
            with self.subTest(recurse=recurse):
                root : ParseNode = NodeParse()

                self.assertRaises(AssertionError, self.parser.ruleLowerCase, root, recurse)

    def test_ruleLowerCase_Integration01(self):
        """tests ruleLowerCase on a string 'TEST1 TEST2 TEST3'
        
        'TEST1 TEST2 TEST3'
        ->
        recurse = False
        Node
            'TEST1'                     |
            ' '
            'TEST2'                     |
            ' '
            'TEST3'                     |
        ->
        Node
            'test1'                     |
            ' '
            'test2'                     |
            ' '
            'test3'                     |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "TEST1",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "TEST2",            0, 6))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        root.append(NodeParse(                                                  "",                 "TEST3",            0, 12))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test1",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "test2",            0, 6))
        expected.append(NodeParse(                                              "",                 " ",                0, 11))
        expected.append(NodeParse(                                              "",                 "test3",            0, 12))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_Integration02(self):
        """tests ruleLowerCase on a string 'Hello World'
        
        'Hello World'
        ->
        recurse = False
        Node
            'Hello'                     |
            ' '
            'World'                     |
        ->
        Node
            'hello'                     |
            ' '
            'world'                     |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "world",            0, 6))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_Integration03(self):
        """tests ruleLowerCase on a string 'Hello World[ABC 123] with recurse = False'
        
        'Hello World[ABC 123]'
        ->
        recurse = False
        Node
            'Hello'                     |
            ' '
            'World'                     |
                'ABC'
                ' '
                '123'
        ->
        Node
            'hello'                     |
            ' '
            'world'                     |
                'ABC'
                ' '
                '123'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        rChild : ParseNode = NodeParse(                                         "",                 "World",            0, 6)
        rChild.append(NodeParse(                                                "",                 "ABC",              0, 11))
        rChild.append(NodeParse(                                                "",                 " ",                0, 14))
        rChild.append(NodeParse(                                                "",                 "123",              0, 15))
        root.append(rChild)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        eChild : ParseNode = NodeParse(                                         "",                 "world",            0, 6)
        eChild.append(NodeParse(                                                "",                 "ABC",              0, 11))
        eChild.append(NodeParse(                                                "",                 " ",                0, 14))
        eChild.append(NodeParse(                                                "",                 "123",              0, 15))
        expected.append(eChild)

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")
        
    def test_ruleLowerCase_Integration04(self):
        """tests ruleLowerCase on a string 'Hello World[ABC 123] with recruse = True'
        
        'Hello World[ABC 123]'
        ->
        recurse = True
        Node
            'Hello'                     |
            ' '
            'World'                     |
                'ABC'                   |
                ' '
                '123'
        ->
        Node
            'hello'                     |
            ' '
            'world'                     |
                'abc'                   |
                ' '
                '123'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        rChild : ParseNode = NodeParse(                                         "",                 "World",            0, 6)
        rChild.append(NodeParse(                                                "",                 "ABC",              0, 11))
        rChild.append(NodeParse(                                                "",                 " ",                0, 14))
        rChild.append(NodeParse(                                                "",                 "123",              0, 15))
        root.append(rChild)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        eChild : ParseNode = NodeParse(                                         "",                 "world",            0, 6)
        eChild.append(NodeParse(                                                "",                 "abc",              0, 11))
        eChild.append(NodeParse(                                                "",                 " ",                0, 14))
        eChild.append(NodeParse(                                                "",                 "123",              0, 15))
        expected.append(eChild)

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=True)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_EmptyString(self):
        """tests ruleLowerCase on an empty string

        ''
        ->
        Node
            ''
        ->
        Node
            ''
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "",                 0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "",                 0, 0))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_EmptyNode(self):
        """tests ruleLowerCase on a null string

        None
        ->
        Node
        ->
        Node
        """

        root : ParseNode = NodeParse()

        expected : ParseNode = NodeParse()

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_NullString(self):
        """tests ruleLowerCase on a null string
        
        None
        ->
        Node
            None
        ->
        Node
            None
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 None,               0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 None,               0, 0))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_SingleToken(self):
        """tests ruleLowerCase on a single token 'Hello'

        'Hello'
        ->
        recurse = False
        Node
            'Hello'                     |
        ->
        Node
            'hello'                     |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "hello",            0, 0))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_SingleToken_Recurse(self):
        """tests ruleLowerCase on a single token 'Hello'

        'Hello'
        ->
        recurse = True
        Node
            'Hello'                     |
        ->
        Node
            'hello'                     |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "hello",            0, 0))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=True)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_MultipleTokens01(self):
        """tests ruleLowerCase on a multiple tokens 'abc 123 DEF 456'

        'abc 123 DEF 456'
        ->
        recurse = False
        Node
            'abc'
            ' '
            '123'
            ' '
            'DEF'                       |
            ' '
            '456'
        ->
        Node
            'abc'
            ' '
            '123'
            ' '
            'def'                       |
            ' '
            '456'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "abc",              0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 "123",              0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "DEF",              0, 8))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        root.append(NodeParse(                                                  "",                 "456",              0, 12))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "abc",              0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 3))
        expected.append(NodeParse(                                              "",                 "123",              0, 4))
        expected.append(NodeParse(                                              "",                 " ",                0, 7))
        expected.append(NodeParse(                                              "",                 "def",              0, 8))
        expected.append(NodeParse(                                              "",                 " ",                0, 11))
        expected.append(NodeParse(                                              "",                 "456",              0, 12))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_MultipleTokens02(self):
        """tests ruleLowerCase on a multiple tokens 'abc 123 DEF 456'

        'abc 123 DEF 456'
        ->
        recurse = False
        Node
            'abc'
            ' '
            123
            ' '
            'DEF'                       |
            ' '
            456
        ->
        Node
            'abc'
            ' '
            123
            ' '
            'def'                       |
            ' '
            456
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "abc",              0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 123,                0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "DEF",              0, 8))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        root.append(NodeParse(                                                  "",                 456,                0, 12))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "abc",              0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 3))
        expected.append(NodeParse(                                              "",                 123,                0, 4))
        expected.append(NodeParse(                                              "",                 " ",                0, 7))
        expected.append(NodeParse(                                              "",                 "def",              0, 8))
        expected.append(NodeParse(                                              "",                 " ",                0, 11))
        expected.append(NodeParse(                                              "",                 456,                0, 12))

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)
        
        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_NonStringTokens(self):
        """tests ruleLowerCase on non-string tokens"""

        tokens : list[Any] = [None, 0, False, ['a'], ('a',), {0 : 'a'}, {'a',}]

        for token in tokens:
            with self.subTest(token=token):
                root : ParseNode = NodeParse()
                root.append(NodeParse(                                          "",                 token,              0, 0))

                expected : ParseNode = NodeParse()
                expected.append(NodeParse(                                      "",                 token,              0, 0))

                result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

                self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_NonStringTokensRecurse(self):
        """tests ruleLowerCase on non-string tokens"""

        tokens : list[Any] = [None, 0, False, ['a'], {0 : 'a'}, ('a',), {'a',}]

        for token in tokens:
            with self.subTest(token=token):
                root : ParseNode = NodeParse()
                rChild : ParseNode = NodeParse()
                rChild.append(NodeParse(                                        "",                 token,              0, 0))
                root.append(rChild)

                expected : ParseNode = NodeParse()
                eChild : ParseNode = NodeParse()
                eChild.append(NodeParse(                                        "",                 token,              0, 0))
                expected.append(eChild)

                result : ParseNode = self.parser.ruleLowerCase(root, recurse=True)

                self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_ChildrenString(self):
        """tests ruleLowerCase on a node with children string with recurse 'abc 123 DEF 456[GHI 789 JKL]'
        
        'abc 123 DEF 456[ABC 123 DEF 456]'
        ->
        recurse = False
        Node
            'abc'
            ' '
            '123'
            ' '
            'DEF'                       |
            ' '
            '456'
                'GHI'
                ' '
                '789'
                ' '
                'JKL'
        ->
        Node
            'abc'
            ' '
            '123'
            ' '
            'def'                       |
            ' '
            '456'
                'GHI'
                ' '
                '789'
                ' '
                'JKL'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "abc",              0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 "123",              0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "DEF",              0, 8))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        rChild : ParseNode = NodeParse(                                         "",                 "456",              0, 12)
        rChild.append(NodeParse(                                                "",                 "GHI",              0, 15))
        rChild.append(NodeParse(                                                "",                 " ",                0, 18))
        rChild.append(NodeParse(                                                "",                 "789",              0, 19))
        rChild.append(NodeParse(                                                "",                 " ",                0, 22))
        rChild.append(NodeParse(                                                "",                 "JKL",              0, 23))
        root.append(rChild)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "abc",              0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 3))
        expected.append(NodeParse(                                              "",                 "123",              0, 4))
        expected.append(NodeParse(                                              "",                 " ",                0, 7))
        expected.append(NodeParse(                                              "",                 "def",              0, 8))
        expected.append(NodeParse(                                              "",                 " ",                0, 11))
        eChild : ParseNode = NodeParse(                                         "",                 "456",              0, 12)
        eChild.append(NodeParse(                                                "",                 "GHI",              0, 15))
        eChild.append(NodeParse(                                                "",                 " ",                0, 18))
        eChild.append(NodeParse(                                                "",                 "789",              0, 19))
        eChild.append(NodeParse(                                                "",                 " ",                0, 22))
        eChild.append(NodeParse(                                                "",                 "JKL",              0, 23))
        expected.append(eChild)

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=False)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleLowerCase_ChildrenStringRecurse(self):
        """tests ruleLowerCase on a node with children string with recurse 'abc 123 DEF 456[GHI 789 JKL]'

        'abc 123 DEF 456[ABC 123 DEF 456]'
        ->
        recurse = True
        Node
            'abc'
            ' '
            '123'
            ' '
            'DEF'                       |
            ' '
            '456'
                'GHI'                   |
                ' '
                '789'
                ' '
                'JKL'                   |
        ->
        Node
            'abc'
            ' '
            '123'
            ' '
            'def'                       |
            ' '
            '456'
                'ghi'                   |
                ' '
                '789'
                ' '
                'jkl'                   |
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "abc",              0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 "123",              0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "DEF",              0, 8))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        rChild : ParseNode = NodeParse(                                         "",                 "456",              0, 12)
        rChild.append(NodeParse(                                                "",                 "GHI",              0, 15))
        rChild.append(NodeParse(                                                "",                 " ",                0, 18))
        rChild.append(NodeParse(                                                "",                 "789",              0, 19))
        rChild.append(NodeParse(                                                "",                 " ",                0, 22))
        rChild.append(NodeParse(                                                "",                 "JKL",              0, 23))
        root.append(rChild)

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "abc",              0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 3))
        expected.append(NodeParse(                                              "",                 "123",              0, 4))
        expected.append(NodeParse(                                              "",                 " ",                0, 7))
        expected.append(NodeParse(                                              "",                 "def",              0, 8))
        expected.append(NodeParse(                                              "",                 " ",                0, 11))
        eChild : ParseNode = NodeParse(                                         "",                 "456",              0, 12)
        eChild.append(NodeParse(                                                "",                 "ghi",              0, 15))
        eChild.append(NodeParse(                                                "",                 " ",                0, 18))
        eChild.append(NodeParse(                                                "",                 "789",              0, 19))
        eChild.append(NodeParse(                                                "",                 " ",                0, 22))
        eChild.append(NodeParse(                                                "",                 "jkl",              0, 23))
        expected.append(eChild)

        result : ParseNode = self.parser.ruleLowerCase(root, recurse=True)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_ExceptionTreeNotNodeParse(self):
        """tests ruleContainer raises an exception when tree is not a NodeParse object"""

        trees : list[Any] = [None, 0, False, 'a', ['a'], {0 : 'a'}, ('a',), {'a',}]

        tree : Any
        for tree in trees:
            with self.subTest(tree=tree):
                self.assertRaises(AssertionError, self.parser.ruleContainer, tree)

    def test_ruleContainer_ExceptionContainerNotDictionary(self):
        """tests ruleContainer raises an exception when container is not a dictionary"""

        containers : list[Any] = [None, 0, False, 'a', ['a'], ('a',), {'a',}]

        container : Any
        for container in containers:
            with self.subTest(container=container):
                self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString01(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        container : dict[Any, Any] = {0 : 'a', 1 : 'b', 2 : 'c'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString02(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        container : dict[Any, Any] = {'a' : 0, 'b' : 1, 'c' : 2}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString03(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        container : dict[Any, Any] = {'a' : '0', 'b' : '1', 'c' : 2}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString04(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        container : dict[Any, Any] = {'0' : 'a', '1' : 'b', 2 : 'c'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString05(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        container : dict[Any, Any] = {2 : 'c'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString06(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        container : dict[Any, Any] = {'c' : 2}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsNotString07(self):
        """tests ruleContainer raises an exception when container dictionary contains a key or value that is not a string"""

        keys : list[Any] = [None, 0, False, ('a',)] # Note: Keys or dictionaries need to be 'hashable', IE: not lists or sets
        values : list[Any] = [None, 0, False, ['a'], {'a'}, ('a',), {'a',}]

        key : Any
        for key in keys:
            with self.subTest(key=key):
                value : Any
                for value in values:
                    with self.subTest(value=value):
                        container : dict[Any, Any] = {key : value}

                        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsDuplicateKeyValuePair01(self):
        """tests ruleContainer raises an exception when container dictionary contains a duplicate key and value"""

        container : dict[Any, Any] = {'a' : 'a'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsDuplicateKeyValuePair02(self):
        """tests ruleContainer raises an exception when container dictionary contains a duplicate key and value"""

        container : dict[Any, Any] = {'a' : 'b', 'b' : 'a'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsDuplicateKeyValuePair03(self):
        """tests ruleContainer raises an exception when container dictionary contains a duplicate key and value"""

        container : dict[Any, Any] = {'a' : 'b', 'b' : '1'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionContainerDictionaryContainsDuplicateKeyValuePair04(self):
        """tests ruleContainer raises an exception when container dictionary contains a duplicate key and value"""

        container : dict[Any, Any] = {'a' : '1', 'b' : '2', 'c' : 'a'}

        self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), container)

    def test_ruleContainer_ExceptionNodeTypeNotString(self):
        """tests ruleContainer raises an exception when nodeType is not a string"""

        nodeTypes : list[Any] = [0, False, ['a'], {'a'}, ('a',), {'a',}]

        nodeType : Any
        for nodeType in nodeTypes:
            with self.subTest(nodeType=nodeType):
                self.assertRaises(AssertionError, self.parser.ruleContainer, NodeParse(), nodeType = nodeType)

    def test_ruleContainer_EmptyNode(self):
        """tests ruleContainer on a string ''
        
        ''
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
        ->
        Node
        
        """

        root : NodeParse = NodeParse()

        expected : NodeParse = NodeParse()

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_SingleToken(self):
        """tests ruleContainer on a string 'Hello'
        
        'Hello'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'Hello'
        ->
        Node
            'Hello'        
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))

        expected : NodeParse = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_SimpleContainer(self):
        """tests ruleContainer on a string '[Hello]'

        '[Hello]'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['                         A
            'Hello'                     |
            ']'                         V
        ->
        Node
            '['                         A   # The opening bracket is included
                'Hello'                 V   
                                            # The closing bracket is not included
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))
        root.append(NodeParse(                                                  "",                 "]",                0, 6))

        expected : NodeParse = NodeParse()
        eChild : NodeParse = NodeParse(                                         "container",        "[",                0, 0)
        eChild.append(NodeParse(                                                "",                 "Hello",            0, 1))
        expected.append(eChild)

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_SimpleEmptyContainer(self):
        """tests ruleContainer on a string '[]'

        '[]'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['                         A
            ']'                         V
        ->
        Node
            '['                         |
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "]",                0, 1))

        expected : NodeParse = NodeParse()
        expected.append(NodeParse(                                              "container",        "[",                0, 0))

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_SimpleContainerCustomContainer01(self):
        """tests ruleContainer on a string 'Hello World' with containers = {"Hello" : "World"}

        'Hello World'
        ->
        containers = {"Hello" : "World"}
        nodeType = 'container' = Default
        Node
            'Hello'                     A
            ' '                         |
            'World'                     V
        ->
        Node
            'Hello'                     A
                ' '                     V
        """

        containers : dict[Any, Any] = {'Hello' : 'World'}

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))

        expected : NodeParse = NodeParse()
        eChild : NodeParse = NodeParse(                                         "container",        "Hello",            0, 0)
        eChild.append(NodeParse(                                                "",                 " ",                0, 5))
        expected.append(eChild)

        result : NodeParse = self.parser.ruleContainer(root, containers = containers)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_SimpleContainerCustomContainer02(self):
        """ ruleContainer on a string 'a b c d 1 2 3 4' with containers = {"a" : "4", "c" : "2"}

        'a b c d 1 2 3 4'
        ->
        containers = {"a" : "4", "c" : "2"}
        nodeType = 'container' = Default
        Node
            'a'                         A
            ' '                         |
            'b'                         |
            ' '                         |
            'c'                         |   A
            ' '                         |   |
            'd'                         |   |
            ' '                         |   |
            '1'                         |   |
            ' '                         |   |
            '2'                         |   V
            ' '                         |
            '3'                         |
            ' '                         |
            '4'                         V
        ->
        Node
            'a'                         A
                ' '                     |
                'b'                     |
                ' '                     |
                'c'                     |   A
                    ' '                 |   |
                    'd'                 |   |
                    ' '                 |   |
                    '1'                 |   |
                    ' '                 |   V
                ' '                     |
                '3'                     |
                ' '                     V
        """

        containers : dict[Any, Any] = {'a' : '4', 'c' : '2'}

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "a",                0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 "b",                0, 2))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 "c",                0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "d",                0, 6))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "1",                0, 8))
        root.append(NodeParse(                                                  "",                 " ",                0, 9))
        root.append(NodeParse(                                                  "",                 "2",                0, 10))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        root.append(NodeParse(                                                  "",                 "3",                0, 12))
        root.append(NodeParse(                                                  "",                 " ",                0, 13))
        root.append(NodeParse(                                                  "",                 "4",                0, 14))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "container",        "a",                0, 0)
        eChild1.append(NodeParse(                                               "",                 " ",                0, 1))
        eChild1.append(NodeParse(                                               "",                 "b",                0, 2))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 3))
        eChild2 : NodeParse = NodeParse(                                        "container",        "c",                0, 4)
        eChild2.append(NodeParse(                                               "",                 " ",                0, 5))
        eChild2.append(NodeParse(                                               "",                 "d",                0, 6))
        eChild2.append(NodeParse(                                               "",                 " ",                0, 7))
        eChild2.append(NodeParse(                                               "",                 "1",                0, 8))
        eChild2.append(NodeParse(                                               "",                 " ",                0, 9))
        eChild1.append(eChild2)
        eChild1.append(NodeParse(                                               "",                 " ",                0, 11))
        eChild1.append(NodeParse(                                               "",                 "3",                0, 12))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 13))
        expected.append(eChild1)

        result : NodeParse = self.parser.ruleContainer(root, containers = containers)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_MultipleSimpleContainers(self):
        """tests ruleContainer on a string '[Hello] {World} ( )'

        '[Hello] {World} ( )'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['                         A
            'Hello'                     |
            ']'                         V
            ' '                         
            '{'                         A
            'World'                     |
            '}'                         V
            ' '                         
            '('                         A
            ' '                         |
            ')'                         V
        ->
        Node
            '['                         A
                'Hello'                 V
            ' '
            '{'                         A
                'World'                 V
            ' '
            '('                         A
                ' '                     V
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))
        root.append(NodeParse(                                                  "",                 "]",                0, 6))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "{",                0, 8))
        root.append(NodeParse(                                                  "",                 "World",            0, 9))
        root.append(NodeParse(                                                  "",                 "}",                0, 14))
        root.append(NodeParse(                                                  "",                 " ",                0, 15))
        root.append(NodeParse(                                                  "",                 "(",                0, 16))
        root.append(NodeParse(                                                  "",                 " ",                0, 17))
        root.append(NodeParse(                                                  "",                 ")",                0, 18))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "container",        "[",                0, 0)
        eChild1.append(NodeParse(                                               "",                 "Hello",            0, 1))
        expected.append(eChild1)
        expected.append(NodeParse(                                              "",                 " ",                0, 7))
        eChild2 : NodeParse = NodeParse(                                        "container",        "{",                0, 8)
        eChild2.append(NodeParse(                                               "",                 "World",            0, 9))
        expected.append(eChild2)
        expected.append(NodeParse(                                              "",                 " ",                0, 15))
        eChild3 : NodeParse = NodeParse(                                        "container",        "(",                0, 16)
        eChild3.append(NodeParse(                                               "",                 " ",                0, 17))
        expected.append(eChild3)

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_NestedContainers(self):
        """tests ruleContainer on a string '[Hello {World}]'

        '[Hello {World}]'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['                         A
            'Hello'                     |
            ' '                         |
            '{'                         |   A
            'World'                     |   |
            '}'                         |   V
            ']'                         V
        ->
        Node
            '['                         A
                'Hello'                 |
                ' '                     |
                '{'                     |   A
                    'World'             V   V
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "{",                0, 7))
        root.append(NodeParse(                                                  "",                 "World",            0, 8))
        root.append(NodeParse(                                                  "",                 "}",                0, 13))
        root.append(NodeParse(                                                  "",                 "]",                0, 14))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "container",        "[",                0, 0)
        eChild1.append(NodeParse(                                               "",                 "Hello",            0, 1))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 6))
        eChild2 : NodeParse = NodeParse(                                        "container",        "{",                0, 7)
        eChild2.append(NodeParse(                                               "",                 "World",            0, 8))
        eChild1.append(eChild2)
        expected.append(eChild1)

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_MultipleNestedContainers01(self):
        """tests ruleContainer on a string '[Hello {World} (123 456)]{abc def}'

        '[Hello {World} (123 456)]{abc def}'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['                         A
            'Hello'                     |
            ' '                         |
            '{'                         |   A
            'World'                     |   |
            '}'                         |   V
            ' '                         |
            '('                         |   A
            '123'                       |   |
            ' '                         |   |
            '456'                       |   |
            ')'                         |   V
            ']'                         V
            '{'                         A
            'abc'                       |
            ' '                         |
            'def'                       |
            '}'                         V
        ->
        Node
            '['                         A
                'Hello'                 |
                ' '                     |
                '{'                     |   A
                    'World'             |   V
                ' '                     |
                '('                     |   A
                    '123'               |   |
                    ' '                 |   |
                    '456'               V   V
            '('                         A
                'abc'                   |
                ' '                     |
                'def'                   V
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "{",                0, 7))
        root.append(NodeParse(                                                  "",                 "World",            0, 8))
        root.append(NodeParse(                                                  "",                 "}",                0, 13))
        root.append(NodeParse(                                                  "",                 " ",                0, 14))
        root.append(NodeParse(                                                  "",                 "(",                0, 15))
        root.append(NodeParse(                                                  "",                 "123",              0, 16))
        root.append(NodeParse(                                                  "",                 " ",                0, 19))
        root.append(NodeParse(                                                  "",                 "456",              0, 20))
        root.append(NodeParse(                                                  "",                 ")",                0, 23))
        root.append(NodeParse(                                                  "",                 "]",                0, 24))
        root.append(NodeParse(                                                  "",                 "{",                0, 25))
        root.append(NodeParse(                                                  "",                 "abc",              0, 26))
        root.append(NodeParse(                                                  "",                 " ",                0, 29))
        root.append(NodeParse(                                                  "",                 "def",              0, 30))
        root.append(NodeParse(                                                  "",                 "}",                0, 33))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "container",        "[",                0, 0)
        eChild1.append(NodeParse(                                               "",                 "Hello",            0, 1))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 6))
        eChild1A : NodeParse = NodeParse(                                       "container",        "{",                0, 7)
        eChild1A.append(NodeParse(                                              "",                 "World",            0, 8))
        eChild1.append(eChild1A)
        eChild1.append(NodeParse(                                               "",                 " ",                0, 14))
        eChild1B : NodeParse = NodeParse(                                       "container",        "(",                0, 15)
        eChild1B.append(NodeParse(                                              "",                 "123",              0, 16))
        eChild1B.append(NodeParse(                                              "",                 " ",                0, 19))
        eChild1B.append(NodeParse(                                              "",                 "456",              0, 20))
        eChild1.append(eChild1B)
        expected.append(eChild1)
        eChild2 : NodeParse = NodeParse(                                        "container",        "{",                0, 25)
        eChild2.append(NodeParse(                                               "",                 "abc",              0, 26))
        eChild2.append(NodeParse(                                               "",                 " ",                0, 29))
        eChild2.append(NodeParse(                                               "",                 "def",              0, 30))
        expected.append(eChild2)

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_MultipleNestedContainers02(self):
        """tests ruleContainer on a string '([{a}b]c)d'

        '([{a}b]c)d'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '('                         A
            '['                         |   A
            '{'                         |   |   A
            'a'                         |   |   |
            '}'                         |   |   V
            'b'                         |   |
            ']'                         |   V
            'c'                         |
            ')'                         V
            'd'                         

        Node
            '('                         A
                '['                     |   A
                    '{'                 |   |   A
                        'a'             |   |   V
                    'b'                 |   V
                'c'                     V
            'd'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "(",                0, 0))
        root.append(NodeParse(                                                  "",                 "[",                0, 1))
        root.append(NodeParse(                                                  "",                 "{",                0, 2))
        root.append(NodeParse(                                                  "",                 "a",                0, 3))
        root.append(NodeParse(                                                  "",                 "}",                0, 4))
        root.append(NodeParse(                                                  "",                 "b",                0, 5))
        root.append(NodeParse(                                                  "",                 "]",                0, 6))
        root.append(NodeParse(                                                  "",                 "c",                0, 7))
        root.append(NodeParse(                                                  "",                 ")",                0, 8))
        root.append(NodeParse(                                                  "",                 "d",                0, 9))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "container",        "(",                0, 0)
        eChild1A : NodeParse = NodeParse(                                       "container",        "[",                0, 1)
        eChild1A1 : NodeParse = NodeParse(                                      "container",        "{",                0, 2)
        eChild1A1.append(NodeParse(                                             "",                 "a",                0, 3))
        eChild1A.append(eChild1A1)
        eChild1A.append(NodeParse(                                              "",                 "b",                0, 5))
        eChild1.append(eChild1A)
        eChild1.append(NodeParse(                                               "",                 "c",                0, 7))
        expected.append(eChild1)
        expected.append(NodeParse(                                              "",                 "d",                0, 9))

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_customLabel01(self):
        """tests ruleContainer on a string '([{a}b]c)d'

        '([{a}b]c)d'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '('                         A           # bracket
            '['                         |   A       # bracket
            '{'                         |   |   A   # bracket
            'a'                         |   |   |   # letter
            '}'                         |   |   V   # bracket
            'b'                         |   |       # letter
            ']'                         |   V       # bracket
            'c'                         |           # letter
            ')'                         V           # bracket
            'd'                                     # letter

        Node
            '('                         A           # container
                '['                     |   A       # container
                    '{'                 |   |   A   # container
                        'a'             |   |   V   # letter
                    'b'                 |   V       # letter
                'c'                     V           # letter
            'd'                                     # letter
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "bracket",          "(",                0, 0))
        root.append(NodeParse(                                                  "bracket",          "[",                0, 1))
        root.append(NodeParse(                                                  "bracket",          "{",                0, 2))
        root.append(NodeParse(                                                  "letter",           "a",                0, 3))
        root.append(NodeParse(                                                  "bracket",          "}",                0, 4))
        root.append(NodeParse(                                                  "letter",           "b",                0, 5))
        root.append(NodeParse(                                                  "bracket",          "]",                0, 6))
        root.append(NodeParse(                                                  "letter",           "c",                0, 7))
        root.append(NodeParse(                                                  "bracket",          ")",                0, 8))
        root.append(NodeParse(                                                  "letter",           "d",                0, 9))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "container",        "(",                0, 0)
        eChild1A : NodeParse = NodeParse(                                       "container",        "[",                0, 1)
        eChild1A1 : NodeParse = NodeParse(                                      "container",        "{",                0, 2)
        eChild1A1.append(NodeParse(                                             "letter",           "a",                0, 3))
        eChild1A.append(eChild1A1)
        eChild1A.append(NodeParse(                                              "letter",           "b",                0, 5))
        eChild1.append(eChild1A)
        eChild1.append(NodeParse(                                               "letter",           "c",                0, 7))
        expected.append(eChild1)
        expected.append(NodeParse(                                              "letter",           "d",                0, 9))

        result : NodeParse = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_customLabel02(self):
        """tests ruleContainer on a string '([{a}b]c)d'

        '([{a}b]c)d'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '('                         A           # bracket
            '['                         |   A       # bracket
            '{'                         |   |   A   # bracket
            'a'                         |   |   |   # letter
            '}'                         |   |   V   # bracket
            'b'                         |   |       # letter
            ']'                         |   V       # bracket
            'c'                         |           # letter
            ')'                         V           # bracket
            'd'                                     # letter

        Node
            '('                         A           # container
                '['                     |   A       # container
                    '{'                 |   |   A   # container
                        'a'             |   |   V   # letter
                    'b'                 |   V       # letter
                'c'                     V           # letter
            'd'                                     # letter
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "bracket",          "(",                0, 0))
        root.append(NodeParse(                                                  "bracket",          "[",                0, 1))
        root.append(NodeParse(                                                  "bracket",          "{",                0, 2))
        root.append(NodeParse(                                                  "letter",           "a",                0, 3))
        root.append(NodeParse(                                                  "bracket",          "}",                0, 4))
        root.append(NodeParse(                                                  "letter",           "b",                0, 5))
        root.append(NodeParse(                                                  "bracket",          "]",                0, 6))
        root.append(NodeParse(                                                  "letter",           "c",                0, 7))
        root.append(NodeParse(                                                  "bracket",          ")",                0, 8))
        root.append(NodeParse(                                                  "letter",           "d",                0, 9))

        expected : NodeParse = NodeParse()
        eChild1 : NodeParse = NodeParse(                                        "bracket",        "(",                0, 0)
        eChild1A : NodeParse = NodeParse(                                       "bracket",        "[",                0, 1)
        eChild1A1 : NodeParse = NodeParse(                                      "bracket",        "{",                0, 2)
        eChild1A1.append(NodeParse(                                             "letter",           "a",                0, 3))
        eChild1A.append(eChild1A1)
        eChild1A.append(NodeParse(                                              "letter",           "b",                0, 5))
        eChild1.append(eChild1A)
        eChild1.append(NodeParse(                                               "letter",           "c",                0, 7))
        expected.append(eChild1)
        expected.append(NodeParse(                                              "letter",           "d",                0, 9))

        result : NodeParse = self.parser.ruleContainer(root, nodeType = None)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_ExceptionContainerMismatch01(self):
        """tests ruleContainer raises an exception when the container does not match the opening and closing brackets, '[Hello'
        
        '[Hello'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['                         |
            'Hello'
        ->
        Raises Exception 'ParserException'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch02(self):
        """tests ruleContainer on a string ']Hello'
        
        ']Hello'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            ']'                         |
            'Hello'
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "]",                0, 0))
        root.append(NodeParse(                                                  "",                 "Hello",            0, 1))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch03(self):
        """tests ruleContainer on a string 'Hello]'

        'Hello]'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'Hello'
            ']'                         |
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 "]",                0, 5))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch04(self):
        """tests ruleContainer on a string 'Hello[[World]'

        'Hello[[World]'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'Hello'
            '['                         |
            '['
            'World'
            ']'
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 "[",                0, 5))
        root.append(NodeParse(                                                  "",                 "[",                0, 6))
        root.append(NodeParse(                                                  "",                 "World",            0, 7))
        root.append(NodeParse(                                                  "",                 "]",                0, 12))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch05(self):
        """tests ruleContainer on a string 'Hello[World]}'

        'Hello[World]}'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'Hello'
            '['
            'World'
            ']'
            '}'                         |
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 "[",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 "]",                0, 11))
        root.append(NodeParse(                                                  "",                 "}",                0, 12))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch06(self):
        """tests ruleContainer on a string 'Hello{World)'

        'Hello{World)'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'Hello'
            '{'
            'World'
            ')'                         |
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 "{",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))
        root.append(NodeParse(                                                  "",                 ")",                0, 11))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch07(self):
        """tests ruleContainer on a string 'Hello World' with a container {'Hello':'zzz'}

        'Hello World'
        ->
        containers = {'Hello':'zzz'}
        nodeType = 'container' = Default
        Node
            'Hello'                     |
            ' '
            'World'
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_ExceptionContainerMismatch08(self):
        """tests ruleContainer on a string '[1 2 3 (4 ] 5)'

        '[1 2 3 (4 ] 5)'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '['
            '1'
            ' '
            '2'
            ' '
            '3'
            ' '
            '('                         |
            '4'
            ' '
            ']'                         |
            ' '
            '5'
            ')'
        ->
        Raises Exception 'ParserError'
        """

        root : NodeParse = NodeParse()
        root.append(NodeParse(                                                  "",                 "[",                0, 0))
        root.append(NodeParse(                                                  "",                 "1",                0, 1))
        root.append(NodeParse(                                                  "",                 " ",                0, 2))
        root.append(NodeParse(                                                  "",                 "2",                0, 3))
        root.append(NodeParse(                                                  "",                 " ",                0, 4))
        root.append(NodeParse(                                                  "",                 "3",                0, 5))
        root.append(NodeParse(                                                  "",                 " ",                0, 6))
        root.append(NodeParse(                                                  "",                 "(",                0, 7))
        root.append(NodeParse(                                                  "",                 "4",                0, 8))
        root.append(NodeParse(                                                  "",                 " ",                0, 9))
        root.append(NodeParse(                                                  "",                 "]",                0, 10))
        root.append(NodeParse(                                                  "",                 " ",                0, 11))
        root.append(NodeParse(                                                  "",                 "5",                0, 12))
        root.append(NodeParse(                                                  "",                 ")",                0, 13))

        self.assertRaises(ParserError, self.parser.ruleContainer, root)

    def test_ruleContainer_integration01(self):
        """tests ruleContainer on a string 'Hello World'
        
        'Hello World'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'Hello'
            ' '
            'World'
        ->
        Node
            'Hello'
            ' '
            'World'
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "Hello",            0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "World",            0, 6))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "Hello",            0, 0))
        expected.append(NodeParse(                                              "",                 " ",                0, 5))
        expected.append(NodeParse(                                              "",                 "World",            0, 6))

        result : ParseNode = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_integration02(self):
        """tests ruleContainer on a string 'test[abc abc{123 123}{456 456}](def)'

        'test[abc abc{123 123}{456 456}](abc)'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            'test'
            '['                         A
            'abc'                       |
            ' '                         |
            'abc'                       |
            '{'                         |   A
            '123'                       |   |
            ' '                         |   |
            '123'                       |   |
            '}'                         |   V
            '{'                         |   A
            '456'                       |   |
            ' '                         |   |
            '456'                       |   |
            '}'                         |   V
            ']'                         V
            '('                         A
            'def'                       |
            ')'                         V
        ->
        Node
            'test'
            '['                         A
                'abc'                   |
                ' '                     |
                'abc'                   |
                '{'                     |   A
                    '123'               |   |
                    ' '                 |   |
                    '123'               |   V
                '{'                     |   A
                    '456'               |   |
                    ' '                 |   |
                    '456'               V   V
            '('                         A
                'def'                   V
        """
    
        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "test",             0, 0))
        root.append(NodeParse(                                                  "",                 "[",                0, 4))
        root.append(NodeParse(                                                  "",                 "abc",              0, 5))
        root.append(NodeParse(                                                  "",                 " ",                0, 8))
        root.append(NodeParse(                                                  "",                 "abc",              0, 9))
        root.append(NodeParse(                                                  "",                 "{",                0, 12))
        root.append(NodeParse(                                                  "",                 "123",              0, 13))
        root.append(NodeParse(                                                  "",                 " ",                0, 16))
        root.append(NodeParse(                                                  "",                 "123",              0, 17))
        root.append(NodeParse(                                                  "",                 "}",                0, 20))
        root.append(NodeParse(                                                  "",                 "{",                0, 21))
        root.append(NodeParse(                                                  "",                 "456",              0, 22))
        root.append(NodeParse(                                                  "",                 " ",                0, 25))
        root.append(NodeParse(                                                  "",                 "456",              0, 26))
        root.append(NodeParse(                                                  "",                 "}",                0, 29))
        root.append(NodeParse(                                                  "",                 "]",                0, 30))
        root.append(NodeParse(                                                  "",                 "(",                0, 31))
        root.append(NodeParse(                                                  "",                 "def",              0, 32))
        root.append(NodeParse(                                                  "",                 ")",                0, 35))

        expected : ParseNode = NodeParse()
        expected.append(NodeParse(                                              "",                 "test",             0, 0))
        eChild1 : ParseNode = NodeParse(                                        "container",        "[",                0, 4)
        eChild1.append(NodeParse(                                               "",                 "abc",              0, 5))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 8))
        eChild1.append(NodeParse(                                               "",                 "abc",              0, 9))
        eChild1A : ParseNode = NodeParse(                                       "container",        "{",                0, 12)
        eChild1A.append(NodeParse(                                              "",                 "123",              0, 13))
        eChild1A.append(NodeParse(                                              "",                 " ",                0, 16))
        eChild1A.append(NodeParse(                                              "",                 "123",              0, 17))
        eChild1.append(eChild1A)
        eChild1B : ParseNode = NodeParse(                                       "container",        "{",                0, 21)
        eChild1B.append(NodeParse(                                              "",                 "456",              0, 22))
        eChild1B.append(NodeParse(                                              "",                 " ",                0, 25))
        eChild1B.append(NodeParse(                                              "",                 "456",              0, 26))
        eChild1.append(eChild1B)
        expected.append(eChild1)
        eChild2 : ParseNode = NodeParse(                                        "container",        "(",                0, 31)
        eChild2.append(NodeParse(                                               "",                 "def",              0, 32))
        expected.append(eChild2)

        result : ParseNode = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_integration03(self):
        """tests ruleContainer on a string '([{}])'

        '([{}])'
        ->
        containers = {"(":")", "[":"]", "{":"}"} = Default
        nodeType = 'container' = Default
        Node
            '('                         A
            '['                         |   A
            '{'                         |   |   A
            '}'                         |   |   V
            ']'                         |   V
            ')'                         V
        ->
        Node
            '('                         A
                '['                     |   A
                    '{'                 V   V   -
        """

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "",                 "(",                0, 0))
        root.append(NodeParse(                                                  "",                 "[",                0, 1))
        root.append(NodeParse(                                                  "",                 "{",                0, 2))
        root.append(NodeParse(                                                  "",                 "}",                0, 3))
        root.append(NodeParse(                                                  "",                 "]",                0, 4))
        root.append(NodeParse(                                                  "",                 ")",                0, 5))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        "container",        "(",                0, 0)
        eChild1A : ParseNode = NodeParse(                                       "container",        "[",                0, 1)
        eChild1A1 : ParseNode = NodeParse(                                      "container",        "{",                0, 2)
        eChild1A.append(eChild1A1)
        eChild1.append(eChild1A)
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleContainer(root)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_integration04(self):
        """tests ruleContainer on a string '1 a b c 2' with containers = {'1' : '2'}, and '1' already labled

        '1 a b c 2'
        ->
        containers = {'1' : '2'} = Default
        nodeType = 'container' = Default
        Node
            '1'                         A   # labeled 'number'
            ' '                         |
            'a'                         |
            ' '                         |
            'b'                         |
            ' '                         |
            'c'                         |
            ' '                         |
            '2'                         V
        ->
        Node
            '1'                         A   # labeled 'container'
                ' '                     |
                'a'                     |
                ' '                     |
                'b'                     |
                ' '                     |
                'c'                     |
                ' '                     V
        """

        containers : dict[Any, Any] = {'1' : '2'}

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "number",           "1",                0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 "a",                0, 2))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 "b",                0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "c",                0, 6))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "2",                0, 8))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        "container",        "1",                0, 0)
        eChild1.append(NodeParse(                                               "",                 " ",                0, 1))
        eChild1.append(NodeParse(                                               "",                 "a",                0, 2))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 3))
        eChild1.append(NodeParse(                                               "",                 "b",                0, 4))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 5))
        eChild1.append(NodeParse(                                               "",                 "c",                0, 6))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 7))
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleContainer(root, containers = containers)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def test_ruleContainer_integration05(self):
        """tests ruleContainer on a string '1 a b c 2' with containers = {'1' : '2'}, and '1' already labled

        '1 a b c 2'
        ->
        containers = {'1' : '2'} = Default
        nodeType = None
        Node
            '1'                         A   # labeled 'number'
            ' '                         |
            'a'                         |
            ' '                         |
            'b'                         |
            ' '                         |
            'c'                         |
            ' '                         |
            '2'                         V
        ->
        Node
            '1'                         A   # labeled 'number'
                ' '                     |
                'a'                     |
                ' '                     |
                'b'                     |
                ' '                     |
                'c'                     |
                ' '                     V
        """

        containers : dict[Any, Any] = {'1' : '2'}

        root : ParseNode = NodeParse()
        root.append(NodeParse(                                                  "number",           "1",                0, 0))
        root.append(NodeParse(                                                  "",                 " ",                0, 1))
        root.append(NodeParse(                                                  "",                 "a",                0, 2))
        root.append(NodeParse(                                                  "",                 " ",                0, 3))
        root.append(NodeParse(                                                  "",                 "b",                0, 4))
        root.append(NodeParse(                                                  "",                 " ",                0, 5))
        root.append(NodeParse(                                                  "",                 "c",                0, 6))
        root.append(NodeParse(                                                  "",                 " ",                0, 7))
        root.append(NodeParse(                                                  "",                 "2",                0, 8))

        expected : ParseNode = NodeParse()
        eChild1 : ParseNode = NodeParse(                                        "number",        "1",                0, 0)
        eChild1.append(NodeParse(                                               "",                 " ",                0, 1))
        eChild1.append(NodeParse(                                               "",                 "a",                0, 2))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 3))
        eChild1.append(NodeParse(                                               "",                 "b",                0, 4))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 5))
        eChild1.append(NodeParse(                                               "",                 "c",                0, 6))
        eChild1.append(NodeParse(                                               "",                 " ",                0, 7))
        expected.append(eChild1)

        result : ParseNode = self.parser.ruleContainer(root, containers = containers, nodeType = None)

        self.assertEqual(True, result.dataEqual(expected), f"\nroot:\n{root}\nexpected:\n{expected}\nresult:\n{result}")

    def rule_ruleFilterContainerKeepChildren_ExceptionTreeNotNodeParse(self):
        """tests ruleContainer raises an exception when tree is not a NodeParse object"""
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_ExceptionContainerTokensNotList(self):
        """tests ruleContainer raises an exception when containerTokens is not a list"""
        raise NotImplementedError
    
    def test_ruleFilterContainerKeepChildren_ExceptionContainerTokensNotEmpty(self):
        """tests ruleContainer raises an exception when containerTokens is not empty"""
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_EmptyNode(self):
        """tests RuleFilterContainerKeepChildren on a string ''
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_SingleToken(self):
        """tests RuleFilterContainerKeepChildren on a string 'Hello' with filterTokens = ['[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_SimpleContainer(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello]' with filterTokens = ['[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_SimpleEmptyContainer(self):
        """tests RuleFilterContainerKeepChildren on a string '[]' with filterTokens = ['[']
        """
        raise NotImplementedError
        
    def test_ruleFilterContainerKeepChildren_MultipleSimpleContainers01(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello] {World} ( )' with filterTokens = ['[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleSimpleContainers01(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello] {World} ( )' with filterTokens = ['{']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleSimpleContainers02(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello] {World} ( )' with filterTokens = ['(']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleSimpleContainers03(self):
        """tests RuleFilterContainerKeepChildren on a string '(Hello World) (Hello World)' with filterTokens = ['(']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleSimpleContainers04(self):
        """tests RuleFilterContainerKeepChildren on a string '(Hello World) (Hello World) [Hello World]' with filterTokens = ['(']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_NestedContainers01(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello {World}]' with filterTokens = ['[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_NestedContainers02(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello [World]]' with filterTokens = ['[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_NestedContainers03(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello {World}]' with filterTokens = ['{']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_NestedContainers04(self):
        """tests RuleFilterContainerKeepChildren on a string '[abc abc [123 123] def] 456' with filterTokens = ['[']
        """
        raise NotImplementedError
    
    def test_ruleFilterContainerKeepChildren_NestedContainers05(self):
        """tests RuleFilterContainerKeepChildren on a string '[abc abc (123 123) def] 456' with filterTokens = ['(']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleNestedContainers01(self):
        """tests RuleFilterContainerKeepChildren on a string '(123)(456)(789[abc def])' with filterTokens = ['(']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleNestedContainers02(self):
        """tests RuleFilterContainerKeepChildren on a string '(123)(456)(789[abc def])' with filterTokens = ['[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleNestedContainers03(self):
        """tests RuleFilterContainerKeepChildren on a string '(123)(456)(789[abc def])' with filterTokens = ['(']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleFilterTokens01(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello]' with filterTokens = ['(', '{']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleFilterTokens02(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello]' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleFilterTokens03(self):
        """tests RuleFilterContainerKeepChildren on a string '(123)(456)(789[abc def])' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleFilterTokens04(self):
        """tests RuleFilterContainerKeepChildren on a string '(123)(456)(789[abc {def}])' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_MultipleFilterTokens05(self):
        """tests RuleFilterContainerKeepChildren on a string '({123}),([456]),([789],[abc,{def}])' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_integration01(self):
        """tests RuleFilterContainerKeepChildren on a string 'Hello World' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_integration02(self):
        """tests RuleFilterContainerKeepChildren on a string '[Hello World]' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_integration03(self):
        """tests RuleFilterContainerKeepChildren on a string '{[Hello] [World]}' with filterTokens = ['(', '{', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_integration04(self):
        """tests RuleFilterContainerKeepChildren on a string '{[Hello] [World]}' with filterTokens = ['(', '[']
        """
        raise NotImplementedError

    def test_ruleFilterContainerKeepChildren_integration05(self):
        """tests RuleFilterContainerKeepChildren on a string 'a(1 2 3),b[c{1 2 3},{4 5 6}]' with filterTokens = ['(', '[', '{']
        """
        raise NotImplementedError

    #TODO tests for ruleFindLabels()

    #TODO tests for ruleLabelNamespace()

    #TODO tests for ruleNestCotainersIntoInstructions()

    #TODO tests for ruleApplyAlias()

class Test_ParserDefault_parseCode(unittest.TestCase):
    """Tests the ParserDefault.parseCode method, under default conditions, for general integration testing of all the components working together
    """
    
    def setUp(self):
        self.parser = CPUsim_v4.ParserDefault()

    #TODO ALL THE TESTS

class Test_NodeParse(unittest.TestCase):
    """tests NodeParse"""

    def setUp(self):
        self.NodeParse = NodeParse

    def test_NodeParse_init_ExceptionTypeStrNotStringOrNone(self):
        """tests __init__ raises an exception when typeStr is not a string or None"""
        raise NotImplementedError

    def test_NodeParse_init_ExceptionLineNumNotNumber(self):
        """tests __init__ raises an exception when lineNum is not a number"""
        raise NotImplementedError

    def test_NodeParse_init_ExceptionColumnNumNotNumber(self):
        """tests __init__ raises an exception when columnNum is not a number"""
        raise NotImplementedError

    def test_NodeParse_init_ExceptionCharNumNotNumber(self):
        """tests __init__ raises an exception when charNum is not a number"""
        raise NotImplementedError

    def test_NodeParse_init_ExceptionLineNumNegative(self):
        """tests __init__ raises an exception when lineNum is negative a number"""
        raise NotImplementedError

    def test_NodeParse_init_ExceptionColumnNumNegative(self):
        """tests __init__ raises an exception when columnNum is negative a number"""
        raise NotImplementedError

    def test_NodeParse_init_ExceptionCharNumNegative(self):
        """tests __init__ raises an exception when charNum is negative a number"""
        raise NotImplementedError

    def test_NodeParse_init_TokenCanBeAnyType(self):
        """tests __init__ does not raise an exception when token is any type"""
        raise NotImplementedError

    def test_NodeParse_init_integration01(Self):
        """tests __init__ on 'Hello'"""
        raise NotImplementedError

    #TODO integration tests on init

    def test_NodeParse_append_ExceptionNodeNotParseNode(self):
        """tests append raises an exception when node is not a ParseNode"""
        raise NotImplementedError

    #TODO integration tests on append()

    def test_nodeParse_copyInfo_nodeEmpty(self):
        """tests copyInfo on ''"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeToken(self):
        """tests copyInfo on multiple token types"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeTypeStr(self):
        """tests copyInfo on typeStr"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeLineNum(self):
        """tests copyInfo on lineNum"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeColumnNum(self):
        """tests copyInfo on columnNum"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeCharNum(self):
        """tests copyInfo on charNum"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeChildren(self):
        """tests copyInfo on 'Hello' + child"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_nodeParent(self):
        """tests copyInfo on root.'Hello', copy root"""
        raise NotImplementedError

    def test_nodeParse_copyInfo_integration01(self):
        """tests copyInfo on 'Hello'"""
        raise NotImplementedError

    #TODO integration testing on copyinfo()

    #TODO testing on copydeep()

    def test_NodeParse_replace_ExceptionOldNodeNotParseNode(self):
        """tests replace raises an exception when oldNode is not a ParseNode"""
        raise NotImplementedError

    def test_NodeParse_replace_ExceptionNewNodeNotParseNode(self):
        """tests replace raises an exception when newNode is not a ParseNode"""
        raise NotImplementedError

    #TODO integration tests on replace()

    def test_NodeParse_remove_ExceptionNodeNotParseNode(self):
        """tests remove raises an exception when node is not a ParseNode"""
        raise NotImplementedError

    #TODO integration tests on remove()

    def test_NodeParse_dataEqual_ExceptionNodeNotParseNode(self):
        """tests dataEqual raises an exception when node is not a ParseNode"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_EmptyEqualWithSelf(self):
        """tests dataEqual with '' == self"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_typeStrEqualWithSelf(self):
        """tests dataEqual with typeStr == self"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_tokenEqualWithSelf(self):
        """tests dataEqual with token == self"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_lineNumEqualWithSelf(self):
        """tests dataEqual with lineNum == self"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_columnNumEqualWithSelf(self):
        """tests dataEqual with columnNum == self"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_charNumEqualWithSelf(self):
        """tests dataEqual with charNum == self"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_typeStrEqual(self):
        """tests dataEqual with typeStr == other.typeStr"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_tokenEqual(self):
        """tests dataEqual with token == other.token"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_lineNumEqual(self):
        """tests dataEqual with lineNum == other.lineNum"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_columnNumEqual(self):
        """tests dataEqual with columnNum == other.columnNum"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_charNumEqual(self):
        """tests dataEqual with charNum == other.charNum"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_typeStrNotEqual(self):
        """tests dataEqual with typeStr != other.typeStr"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_tokenNotEqual(self):
        """tests dataEqual with token != other.token"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_lineNumNotEqual(self):
        """tests dataEqual with lineNum != other.lineNum"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_columnNumNotEqual(self):
        """tests dataEqual with columnNum != other.columnNum"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_charNumNotEqual(self):
        """tests dataEqual with charNum != other.charNum"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withChild(self):
        """tests dataEqual with child"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withChildren(self):
        """tests dataEqual with children"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withParent(self):
        """tests dataEqual with parent"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withNodePrevious(self):
        """tests dataEqual with nodePrevious"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withNodeNext(self):
        """tests dataEqual with nodeNext"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withChildOnOneNode(self):
        """tests dataEqual with child on one node but not the other"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withChildrenOnOneNode(self):
        """tests dataEqual with children on one node but not the other"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withParentOnOneNode(self):
        """tests dataEqual with parent on one node but not the other"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withNodePreviousOnOneNode(self):
        """tests dataEqual with nodePrevious on one node but not the other"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_withNodeNextOnOneNode(self):
        """tests dataEqual with nodeNext on one node but not the other"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration01(self):
        """tests dataEqual with all attributes equal"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration02(self):
        """tests dataEqual with all attributes not equal"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration03(self):
        """test dataEqual on 'node('string', 'hello', 1, 2, 3)' == 'node('string', 'hello', 1, 2, 3)'"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration04(self):
        """test dataEqual on 'node('string', 'hello', 1, 2, 3)' != 'node('string', 'hello', 1, 2, 4)'"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration05(self):
        """test dataEqual on 'node('string', 'hello', 1, 2, 3)' == 'node('string', 'hello', 1, 2, 3)' + child"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration06(self):
        """test dataEqual on 'node('string', 'hello', 1, 2, 3)' + child == 'node('string', 'hello', 1, 2, 3)'"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration07(self):
        """test dataEqual on 'Hello World', the 'world' token copy"""
        raise NotImplementedError

    def test_NodeParse_dataEqual_integration08(self):
        """test dataEqual on 'Hello World', the 'root' token copy"""
        raise NotImplementedError

    #TODO testing on __eq__()

    #TODO testing on __ne__()

class Test_InstructionSetDefault_BuildingBlocks(unittest.TestCase):
    """Tests the InstructionSetDefault building blocks
    
    Note: when adding tests, use test_opAddCarryOverflow.... as a reference for adding further tests
    """

    class dummyMMMU:
        """A dummy Meta Memory Managment Unit framework that mimics the interaction with the MMMU from the perspective of the instruction.
        
        supports creating registers
        supports reading and writing to registers (reading and writing are done to parallel sets of registers)
        supports logging of all accesses
        supports raising MMMUAccessError when an access is made to an invalid register

        Edge case:
            #TODO supports writing to and creating '_imm' registers dynamically
        """

        def __init__(self):
            self.registersRead : dict[tuple[str | int, str | int], int] = {}
            self.registersWrite : dict[tuple[str | int, str | int], int] = {}
            self.registersGetConfig : dict[tuple[str | int, str | int], dict[str, Any]] = {}

            self.activityLog : list[    # list is ordered by access time
                tuple[
                    Literal[            # the access type (read, write, getConfig)
                        'read', 
                        'write', 
                        'getConfig',
                        'createIMM'], 
                    str | int,          # the register key
                    str | int,          # the register key
                    int]                # the register value exchanged
                ] = []

        def createRegister(self, 
            key : str | int, index: str | int,
            value: int, bitLength: int
            ):
            """Creates a register with the specified key, index, value, and bitLength"""

            assert type(key) is str or type(key) is int
            assert type(index) is str or type(index) is int
            assert type(value) is str or type(value) is int
            assert value >= 0
            assert type(bitLength) is str or type(bitLength) is int
            assert bitLength >= 0
            assert 0 <= value < 2**bitLength # asserts value can fit in register

            self.registersRead[(key, index)] = value
            self.registersWrite[(key, index)] = value
            self.registersGetConfig[(key, index)] = {'bitLength': bitLength}

        def dummyReadWrapper(self, register : tuple[str | int, str | int]) -> int:
            """Reads the specified register and returns the value (in the context of an instruction)
            
            Meant to be passed to the instruction as the interface to the MMMU
            """

            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert all([type(i) is str or type(i) is int for i in register])

            return self._read(register)

        def dummyWriteWrapper(self, register : tuple[str | int, str | int], value : int) -> None | tuple[str, int]:
            """Writes the specified register with the specified value (in the context of an instruction)

            Meant to be passed to the instruction as the interface to the MMMU

            This wrapper breaks the strict seperation between the 'read registers' and the 'write registers'
                By allowing writes to '_imm' to create an immediate register in the 'read register'
                By allowing value to be negative for the '_imm' register creation
                By having a return value iff the '_imm' register is created
            """

            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert all([type(i) is str or type(i) is int for i in register])
            assert type(value) is int

            if register[0] == '_imm':
                return self._createImmRegister(value)
            else:
                return self._write(register, value)

        def dummyGetConfigWrapper(self, register : tuple[str | int, str | int]) -> dict:
            """Returns the configuration of the specified register (in the context of an instruction)

            Meant to be passed to the instruction as the interface to the MMMU
            """

            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert all([type(i) is str or type(i) is int for i in register])

            return self._getConfig(register)

        def getActivity(self) -> list[tuple[Literal['read', 'write', 'getConfig'], str | int, str | int]]:
            """returns an ordered list of tuples representing the access history of registers
            
            list[                       # list is ordered by access time
                tuple[
                    str,                # the access type (read, write, getConfig)
                    str | int,          # the register key
                    str | int,          # the register key
                    int                 # the register value exchanged
                ]
            ]
            """
            
            return self.activityLog

        def readWrittenRegister(self, key, index):
            """returns the written value of the register with the specified key and index
            
            IE: if an instruction writes a value to a register, it will show up with this function
            vs the dummyReadWrapper() function, which will only show the initial value of a register
            """

            assert type(key) is str or type(key) is int
            assert type(index) is str or type(index) is int

            if (key, index) not in self.registersWrite.keys():
                raise MMMUAccessError(f'ERROR -> register: {(key, index)}')

            return self.registersWrite[(key, index)]

        def _read(self, register : tuple[str | int, str | int]) -> int:
            """Reads the specified register and returns the value (in the context of an instruction)"""
            
            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert all([type(i) is str or type(i) is int for i in register])

            key = register[0]
            index = register[1]

            if (key, index) not in self.registersRead.keys():
                raise MMMUAccessError(f'ERROR -> register: {register}')

            self.activityLog.append(('read', key, index, self.registersRead[(key, index)]))
            return self.registersRead[(key, index)]

        def _write(self, register : tuple[str | int, str | int], value : int) -> None:
            """Writes the specified register with the specified value (in the context of an instruction)"""

            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert all([type(i) is str or type(i) is int for i in register])
            assert type(value) is int
            assert value >= 0

            key = register[0]
            index = register[1]
            
            if (key, index) not in self.registersWrite.keys():
                raise MMMUAccessError(f'ERROR -> register: {register}')

            self.activityLog.append(('write', key, index, value))
            self.registersWrite[(key, index)] = value
        
        def _getConfig(self, register : tuple[str | int, str | int]) -> dict:
            """Returns the configuration of the specified register (in the context of an instruction)"""

            assert type(register) is tuple or type(register) is list
            assert len(register) == 2
            assert all([type(i) is str or type(i) is int for i in register])

            key = register[0]
            index = register[1]

            if (key, index) not in self.registersGetConfig.keys():
                raise MMMUAccessError(f'ERROR -> register: {register}')

            self.activityLog.append(('getConfig', key, index, self.registersGetConfig[(key, index)]['bitLength']))
            return self.registersGetConfig[(key, index)]

        def _createImmRegister(self, value : int) -> tuple[str | int, str | int]:
            """creates an '_imm' register with the specified value
            
            bitLength of created '_imm' will be minimum required to store the value
            for a negative value, absolute of value will be taken, and the leading 1 bit will be removed, the rest is stored
                this allows for the controlling of bitLength
                including the non-sensical case of a zero-bitLength _imm register =S
            """

            assert type(value) is int

            # find lowest available _imm index
            immPresent : list[tuple[str, int]] = [(i, j) for i, j in self.registersRead.keys() if i == '_imm']
            immTakenNumbers : list[int] = [i[1] for i in immPresent]
            immNumber = 0
            while immNumber in immTakenNumbers:
                immNumber += 1

            # find most significant bit
            msb : int = 0
            temp : int = value if value >= 0 else abs(value)
            while temp > 0:
                temp >>= 1
                msb += 1

            # determins correct bitLength, zero gets a bitLength of 1, negative gets a bitLength of msb - 1 to trim leading bit
            bitLength : int = msb
            bitLength = bitLength + 1 if bitLength == 0 else bitLength
            bitLength = bitLength - 1 if value < 0 else bitLength
            
            result : int = value if value >= 0 else abs(value) & (2**(bitLength) - 1) # negative numbers get leading bit trimmed

            # create, log, and return '_imm' register
            self.activityLog.append(('createImm', '_imm', immNumber, value))
            self.registersWrite[('_imm', immNumber)] = result
            self.registersGetConfig[('_imm', immNumber)] = {'bitLength': bitLength}
            return ('_imm', immNumber)

    def setUp(self):
        self.ISA = CPUsim_v4.InstructionSetDefault()

        keysValid : list[str | int] = [0, 1, '', 'r', 'r0', '\u28ff']
        keysInvalid : list[Any] = [None, False, [], {}, set(), lambda _ : 0]
        self.functionNull : Callable[[Any], Any] = lambda : 0
        self.functionInvalid : list[Any] = [None, 0, False, '', [], {}, set()]

        self.registerNull : list[str | int, str | int] = [0, 0]
        self.registerValid : list[str | int, str | int] = [] + \
            [(i, j) for i in keysValid     for j in keysValid]
        self.registerInvalid : list[Any] = [] + \
            keysValid + \
            keysInvalid + \
            [list(i) for i in (keysValid, keysInvalid)] + \
            [(i, j) for i in keysInvalid   for j in keysInvalid] + \
            [(i, j) for i in keysValid     for j in keysInvalid] + \
            [(i, j) for i in keysInvalid   for j in keysValid] + \
            [[i, j] for i in keysInvalid   for j in keysInvalid] + \
            [[i, j] for i in keysValid     for j in keysInvalid] + \
            [[i, j] for i in keysInvalid   for j in keysValid] + \
            [(i, j, k) for i in (keysValid + keysInvalid) for j in (keysValid + keysInvalid) for k in (keysValid + keysInvalid)] + \
            [[i, j, k] for i in (keysValid + keysInvalid) for j in (keysValid + keysInvalid) for k in (keysValid + keysInvalid)]
        # This might seem excessive, but user made building block functions may not be as strictly built, or may be more complex than default functions

        self.eEngine : dict[str, Any] = {
            'randomNumberGenerator' : self.functionNull,
            'MMMU' : self.functionNull,
            'callMicroJump' : self.functionNull,
            'callMicroFunction' : self.functionNull,
            'callKernelJump' : self.functionNull,
            'callKernelFunction' : self.functionNull,
            'callInterrupt' : self.functionNull
        }
        self.eStatus : dict[str, Any] = {
        }

        self.eEngineInvalid : list[Any] = [] + \
            [None, 0, False, '', [], set()] + \
            [{i : j for i in [None, False, 0] for j in (keysValid + keysInvalid)}]

    def test_isISARegisterVector_invalidRegisters(self):
        """tests isISARegisterVector returns False with invalid registers"""

        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertFalse(self.ISA.isISARegisterVector(register), f'register = {register}')

    def test_isISARegisterVector_validRegisters(self):
        """tests isISARegisterVector returns True with valid registers"""
        
        registers : list[Any] = self.registerValid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertTrue(self.ISA.isISARegisterVector(register), f'register = {register}')

    def test_isISARegisterVector_integration01(self):
        """tests isISARegisterVector on ['','']"""

        register : Any = ['', '']

        expected : bool = True

        result : bool = self.ISA.isISARegisterVector(register)

        self.assertEqual(result, expected, f'\nregister:\n\t{register}\nexpected:\n\t{expected}\nresult:\n\t{result}')

    def test_isISARegisterVector_integration02(self):
        """tests isISARegisterVector on ['',0]"""

        register : Any = ['', 0]

        expected : bool = True

        result : bool = self.ISA.isISARegisterVector(register)

        self.assertEqual(result, expected, f'\nregister:\n\t{register}\nexpected:\n\t{expected}\nresult:\n\t{result}')

    def test_isISARegisterVector_integration03(self):
        """tests isISARegisterVector on [0,'']"""

        register : Any = [0, '']

        expected : bool = True

        result : bool = self.ISA.isISARegisterVector(register)

        self.assertEqual(result, expected, f'\nregister:\n\t{register}\nexpected:\n\t{expected}\nresult:\n\t{result}')

    def test_isISARegisterVector_integration04(self):
        """tests isISARegisterVector on [0,0]"""
        
        register : Any = [0, 0]

        expected : bool = True

        result : bool = self.ISA.isISARegisterVector(register)

        self.assertEqual(result, expected, f'\nregister:\n\t{register}\nexpected:\n\t{expected}\nresult:\n\t{result}')

    def test_isISARegisterVector_integration05(self):
        """tests isISARegisterVector on ['',False]"""
        
        register : Any = ['', False]

        expected : bool = False

        result : bool = self.ISA.isISARegisterVector(register)

        self.assertEqual(result, expected, f'\nregister:\n\t{register}\nexpected:\n\t{expected}\nresult:\n\t{result}')

    def test_isISARegisterVector_integration06(self):
        """tests isISARegisterVector on ['',[]]"""
        
        register : Any = ['', []]

        expected : bool = False

        result : bool = self.ISA.isISARegisterVector(register)

        self.assertEqual(result, expected, f'\nregister:\n\t{register}\nexpected:\n\t{expected}\nresult:\n\t{result}')

    #TODO testing on assertEnvironment()

    def test_int2bits_Exception_NumberNotInt(self):
        """tests int2bits raises an exception when number is not int"""
        raise NotImplementedError

    def test_int2bits_Exception_BitLengthNotInt(self):
        """tests int2bits raises an exception when bitLength is not int"""
        raise NotImplementedError

    def test_int2bits_Exception_BitLengthNegative(self):
        """tests int2bits raises an exception when bitLength is negative"""
        raise NotImplementedError

    def test_int2bits_Exception_BitLengthZero(self):
        """tests int2bits raises an exception when bitLength is zero"""
        raise NotImplementedError

    def test_int2bits_Exception_NumberNegativeBitLengthIncompatible(self):
        """tests int2bits raises an exception when number is negative and is incompatible (too large and negative) with bitLength"""
        raise NotImplementedError

    def test_int2bits_Exception_NumberPositiveBitLengthIncompatible(self):
        """tests int2bits raises an exception when number is positive and is incompatible (too small and positive) with bitLength"""
        raise NotImplementedError

    def test_int2bits_bitLengths1to10(self):
        """tests int2bits with bitLengths 1 to 10, on ALL POSSIBLE VALUES for the corisponding bitlengths"""
        raise NotImplementedError

    def test_int2bits_BitLength1to1024Sweet1bit(self):
        """tests int2bits with bitLengths 1 to 1024, with a 1 bit sweep across pattern across the bitLengths"""
        raise NotImplementedError

    def test_int2bits_BitLength1to1024EvenOdd(self):
        """tests int2bits with bitLengths 1 to 1024, with an alternating pattern of zeros and ones across the bitLengths (IE: 101010101)"""
        raise NotImplementedError

    def test_int2bits_BitLength1to1024AllOnes(self):
        """tests int2bits with bitLengths 1 to 1024, with a pattern of all ones across the bitLengths (IE: 111111111)"""
        raise NotImplementedError

    def test_int2bits_BitLength1to1024AllZeros(self):
        """tests int2bits with bitLengths 1 to 1024, with a pattern of all zeros across the bitLengths (IE: 00000000)"""
        raise NotImplementedError

    def test_int2bits_integration01(self):
        """tests int2bits on 0x0 with bitlength = 1"""
        raise NotImplementedError

    def test_int2bits_integration02(self):
        """tests int2bits on 0x1 with bitlength = 1"""
        raise NotImplementedError

    def test_int2bits_integration03(self):
        """tests int2bits on 0xff with bitlength = 8"""
        raise NotImplementedError

    def test_int2bits_integration04(self):
        """tests int2bits on 0xffff with bitlength = 16"""
        raise NotImplementedError

    def test_int2bits_integration05(self):
        """tests int2bits on 0xffffffff with bitlength = 32"""
        raise NotImplementedError

    def test_int2bits_integration06(self):
        """tests int2bits on 0xabababab with bitlength = 32"""
        raise NotImplementedError

    def test_int2bits_integration07(self):
        """tests int2bits on -0xff with bitlength = 32"""
        raise NotImplementedError

    def test_int2bits_integration08(self):
        """tests int2bits on -0xabababab with bitlength = 64"""
        raise NotImplementedError

    def test_bits2int_Exception_bitArrayNotList(self):
        """tests bits2int raises an exception when bitArray is not a list"""
        raise NotImplementedError

    def test_bits2int_Exception_bitArrayNotEmpty(self):
        """tests bits2int raises an exception when bitArray is not empty"""
        raise NotImplementedError

    def test_bits2int_Exception_bitArrayNotBoolOrInt(self):
        """tests bits2int raises an exception when bitArray is not a list of bools or ints"""
        raise NotImplementedError

    def test_bits2int_Exception_bitArrayNotLargeInt(self):
        """tests bits2int raises an exception when bitArray is not a list of ints that are 0 or 1"""
        raise NotImplementedError

    def test_bits2int_bitLengths1to10(self):
        """tests bits2int with bitLengths 1 to 10, on ALL POSSIBLE VALUES for the corisponding bitlengths"""
        raise NotImplementedError

    def test_bits2int_BitLength1to1024Sweet1bit(self):
        """tests bits2int with bitLengths 1 to 1024, with a 1 bit sweep across pattern across the bitLengths"""
        raise NotImplementedError

    def test_bits2int_BitLength1to1024EvenOdd(self):
        """tests bits2int with bitLengths 1 to 1024, with an alternating pattern of zeros and ones across the bitLengths (IE: 101010101)"""
        raise NotImplementedError

    def test_bits2int_BitLength1to1024AllOnes(self):
        """tests bits2int with bitLengths 1 to 1024, with a pattern of all ones across the bitLengths (IE: 111111111)"""
        raise NotImplementedError

    def test_bits2int_BitLength1to1024AllZeros(self):
        """tests bits2int with bitLengths 1 to 1024, with a pattern of all zeros across the bitLengths (IE: 00000000)"""
        raise NotImplementedError

    def test_bits2int_integration01(self):
        """tests bits2int on 0x0 with bitlength = 1"""
        raise NotImplementedError

    def test_bits2int_integration02(self):
        """tests bits2int on 0x1 with bitlength = 1"""
        raise NotImplementedError

    def test_bits2int_integration03(self):
        """tests bits2int on 0xff with bitlength = 8"""
        raise NotImplementedError

    def test_bits2int_integration04(self):
        """tests bits2int on 0xffff with bitlength = 16"""
        raise NotImplementedError

    def test_bits2int_integration05(self):
        """tests bits2int on 0xffffffff with bitlength = 32"""
        raise NotImplementedError

    def test_bits2int_integration06(self):
        """tests bits2int on 0xabababab with bitlength = 32"""
        raise NotImplementedError

    def test_bits2int_integration07(self):
        """tests bits2int on -0xff with bitlength = 32"""
        raise NotImplementedError

    def test_bits2int_integration08(self):
        """tests bits2int on -0xabababab with bitlength = 64"""
        raise NotImplementedError

    def test_bits2int_integration09(self):
        """tests bits2int on [True, True, True, True] with bitlength = 4"""
        raise NotImplementedError

    def test_microEnforceAccess_Exception_registerNotRegister(self):
        """tests microEnforceAccess raises an exception when register is not a register"""
        raise NotImplementedError

    def test_microEnforceAccess_Exception_keyNotValidKey(self):
        """tests microEnforceAccess raises an exception when key is not a valid key"""
        raise NotImplementedError

    #TODO testing on microEnforceAccess

    #TODO testing on microSyscall

    def test_microInjectImmediateValue_Exception_funcReadNotFunction(self):
        """tests microInjectImmediateValue raises an exception when funcRead is not a function"""

        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.microInjectImmediateValue,
                    funcRead                                                    = function,
                    funcWrite                                                   = self.functionNull,
                    value                                                       = 0
                )

    def test_microInjectImmediateValue_Exception_funcWriteNotFunction(self):
        """tests microInjectImmediateValue raises an exception when funcWrite is not a function"""

        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.microInjectImmediateValue,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function,
                    value                                                       = 0
                )

    def test_microInjectImmediateValue_Exception_valueNotInt(self):
        """tests microInjectImmediateValue raises an exception when value is not an int"""

        values : list[Any] = [False, '', (), {}, (0,), []]

        value : Any
        for value in values:
            with self.subTest(value=value):
                self.assertRaises(AssertionError, self.ISA.microInjectImmediateValue,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    value                                                       = value
                )

    def test_microInjectImmediateValue_valueZero(self):
        """tests microInjectImmediateValue on value = [0] -> [['_imm', 0] = (value = 0b0, bitLength = 1)]
        
        value = [0] -> [['_imm', 0] = (value = 0b0, bitLength = 1)]
        ->
        value = 0b0
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = self.functionNull
            value                       = 0b0
        )
        -> # input
        value = 0b0
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b0
        }
        -> # written
        ['_imm', 0];                    value = 0;          bitLength = 1
        -> # returned
        ['_imm', 0]
        """

        value : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              0)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 0),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 1

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')
        
    def test_microInjectImmediateValue_valueOne(self):
        """tests microInjectImmediateValue on value = [1] -> [['_imm', 0] = (value = 0b1, bitLength = 1)]
        
        value = [1] -> [['_imm', 0] = (value = 0b1, bitLength = 1)]
        ->
        value = 0b1
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b1
        )
        -> # input
        value = 0b01
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b01
        }
        -> # written
        ['_imm', 0];                    value = 1;          bitLength = 1
        -> # returned
        ['_imm', 0]
        """

        value : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )
        
        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              1)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 1),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 1

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_valueNegativeOne(self):
        """tests microInjectImmediateValue on value = [-1] -> [['_imm', 0] = (value = 0, bitLength = 0)]
        
        value = [-1] -> [['_imm', 0] = (value = 0, bitLength = 0)]
        ->
        value = -0b1
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = -0b1
        )
        -> # input
        value = -0b1
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0
        }
        -> # written
        ['_imm', 0];                    value = 0;         bitLength = 0
        -> # returned
        ['_imm', 0]
        """

        value : int = -1

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              -1)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 0),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 0

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_MMMUWithExistingImm01(self):
        """tests microInjectImmediateValue on MMMU with ExistingImm = [['_imm', 0] = 0], value = [0] -> [['_imm', 1] = (value = 0b0, bitLength = 1)]
        
        MMMU with ExistingImm = [['_imm', 0] = 0], value = [0] -> [['_imm', 1] = (value = 0b0, bitLength = 1)]
        ->
        value = 0b0
        registerRead = {
            ('_imm', 0)                 : 0b0
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b0
        )
        -> # input
        value = 0b0
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b0
            ('_imm', 1)                 : 0b0
        }
        -> # written
        ['_imm', 1];                    value = 0;         bitLength = 1
        -> # returned
        ['_imm', 1]
        """

        value : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            '_imm', 0,                              value = 0, bitLength = 1)

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 1)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 1,                              0)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 1,                 0),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 1

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 1))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_MMMUWithExistingImm02(self):
        """tests microInjectImmediateValue on MMMU with ExistingImm = [['_imm', 0] = 0], value = [1] -> [['_imm', 1] = (value = 0b1, bitLength = 1)]
        
        ExistingImm = [['_imm', 0] = 0], value = [1] -> [['_imm', 1] = (value = 0b01, bitLength = 1)]
        ->
        value = 0b1
        registerRead = {
            ('_imm', 0)                 : 0b0
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b1
        )
        -> # input
        value = 0b01
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b0
            ('_imm', 1)                 : 0b1
        }
        -> # written
        ['_imm', 1];                    value = 1;         bitLength = 2
        -> # returned
        ['_imm', 1]
        """

        value : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            '_imm', 0,                              value = 0, bitLength = 1)

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 1)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 1,                              1)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 1,                 1),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 1

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 1))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_MMMUWithExistingImm03(self):
        """tests microInjectImmediateValue on MMMU with ExistingImm = [['_imm', 0] = 0], value = [-1] -> [['_imm', 1] = (value = 0b0, bitLength = 0)]
        
        MMMU with ExistingImm = [['_imm', 0] = 0], value = [-1] -> [['_imm', 1] = (value = 0b1, bitLength = 1)]
        ->
        value = 0b1
        registerRead = {
            ('_imm', 0)                 : 0b0
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b1
        )
        -> # input
        value = 0b1
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b0
            ('_imm', 1)                 : 0b0
        }
        -> # written
        ['_imm', 1];                    value = 0b0;        bitLength = 0
        -> # returned
        ['_imm', 1]        
        """

        value : int = -1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            '_imm', 0,                              value = 0, bitLength = 1)

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 1)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 1,                              -1)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 1,                 0),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 0

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 1))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_MMMUWithExistingImm04(self):
        """tests microInjectImmediateValue on MMMU with ExistingImm = [['_imm', 0] = 1, ['_imm', 1] = 1], value = [1] -> [['_imm', 2] = (value = 0b10, bitLength = 2)]
        
        MMMU with ExistingImm = [['_imm', 0] = 1, ['_imm', 1] = 1], value = [1] -> [['_imm', 2] = (value = 0b10, bitLength = 2)]
        ->
        value = 0b10
        registerRead = {
            ('_imm', 0)                 : 0b1
            ('_imm', 1)                 : 0b1
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b10
        )
        -> # input
        value = 0b10
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b1
            ('_imm', 1)                 : 0b1
            ('_imm', 2)                 : 0b10
        }
        -> # written
        ['_imm', 2];                    value = 0b10;       bitLength = 2
        -> # returned
        ['_imm', 2]
        """

        value : int = 0b10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            '_imm', 0,                              value = 1, bitLength = 1)
        MMMU.createRegister(            '_imm', 1,                              value = 1, bitLength = 1)

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 2)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 2,                              0b10)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 2,                 2),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 2

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 2))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_MMMUWithExistingImm05(self):
        """tests microInjectImmediateValue on MMMU with ExistingImm = [['_imm', 0] = 1, ['_imm', 2] = 1], value = [1] -> [['_imm', 1] = (value = 0b10, bitLength = 2)]
        
        MMMU with ExistingImm = [['_imm', 0] = 1, ['_imm', 2] = 1], value = [1] -> [['_imm', 1] = (value = 0b10, bitLength = 2)]
        ->
        value = 0b10
        registerRead = {
            ('_imm', 0)                 : 0b1
            ('_imm', 2)                 : 0b1
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b10
        )
        -> # input
        value = 0b10
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b1
            ('_imm', 1)                 : 0b10
            ('_imm', 2)                 : 0b1
        }
        -> # written
        ['_imm', 1];                    value = 0b10;       bitLength = 2
        -> # returned
        ['_imm', 1]
        """

        value : int = 0b10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            '_imm', 0,                              value = 1, bitLength = 1)
        MMMU.createRegister(            '_imm', 2,                              value = 1, bitLength = 1)

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 1)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 1,                              0b10)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 1,                 2),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 2

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 1))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_MMMUWithExistingImm06(self):
        """tests microInjectImmediateValue on MMMU with ExistingImm = [['_imm', 1] = 1, ['_imm', 2] = 1], value = [1] -> [['_imm', 0] = (value = 0b10, bitLength = 2)]
        
        MMMU with ExistingImm = [['_imm', 1] = 1, ['_imm', 2] = 1], value = [1] -> [['_imm', 0] = (value = 0b10, bitLength = 2)]
        ->
        value = 0b10
        registerRead = {
            ('_imm', 1)                 : 0b1
            ('_imm', 2)                 : 0b1
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0b1
        )
        -> # input
        value = 0b01
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0b10
            ('_imm', 1)                 : 0b1
            ('_imm', 2)                 : 0b1
        }
        -> # written
        ['_imm', 0];                    value = 0b10;       bitLength = 2
        -> # returned
        ['_imm', 0]
        """

        value : int = 0b10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            '_imm', 1,                              value = 1, bitLength = 1)
        MMMU.createRegister(            '_imm', 2,                              value = 1, bitLength = 1)

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              0b10)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 2),                                     # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 2

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_largeValue01(self):
        """tests microInjectImmediateValue on value = [0xffffffff] -> [['_imm', 0] = (value = 0xffffffff, bitLength = 32)]
        
        value = [0xffffffff] -> [['_imm', 0] = (value = 0xffffffff, bitLength = 32)]
        ->
        value = 0xffffffff
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 0xffffffff
        )
        -> # input
        value = 0x0ffffffff
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0xffffffff
        }
        -> # written
        ['_imm', 0];                    value = 0xffffffff;    bitLength = 32
        -> # returned
        ['_imm', 0]
        """
        
        value : int = 0xffffffff

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              0xffffffff)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 0xffffffff),                            # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 32

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_largeValue02(self):
        """tests microInjectImmediateValue on value = [-0x1ffffffff] -> [['_imm', 0] = (value = 0xffffffff, bitLength = 32)]
        
        value = [-0x1ffffffff] -> [['_imm', 0] = (value = 0xffffffff, bitLength = 32)]
        ->
        value = -0x1ffffffff = 0xffffffff
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = -0x1ffffffff
        )
        -> # input
        value = -0x1ffffffff
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0xffffffff
        }
        -> # written
        ['_imm', 0];                    value = 0xffffffff;    bitLength = 32
        -> # returned
        ['_imm', 0]
        """
        
        value : int = -0x1ffffffff

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              value)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 0xffffffff),                            # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 32

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_largeValue03(self):
        """tests microInjectImmediateValue on value = [-0x100000000] -> [['_imm', 0] = (value = 0x00000000, bitLength = 32)]

        value = [-0x100000000] -> [['_imm', 0] = (value = 0x00000000, bitLength = 32)]
        ->
        value = -0x100000000 = 0x00000000
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = -0x100000000
        )
        -> # input
        value = -0x100000000
        -> # output
        registerRead = {
            ('_imm', 0)                 : 0x00000000
        }
        -> # written
        ['_imm', 0];                    value = 0x00000000;    bitLength = 32
        -> # returned
        ['_imm', 0]
        """

        value : int = -0x100000000

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('createImm',               '_imm', 0,                              value)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 0x00000000),                            # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 32

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
        self.assertEqual(expectedBitLength, resultBitLength,
            f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')

    def test_microInjectImmediateValue_largeValue04(self):
        """tests microInjectImmediateValue on value = [2**(2**20 - 1)] -> [['_imm', 0] = (value = 2**(2**20 - 1), bitLength = 2**20)]
        
        value = [2**(2**20 - 1)] -> [['_imm', 0] = (value = 2**(2**20 - 1), bitLength = 2**20)]
        ->
        value = 2**(2**20 - 1)
        registerRead = {
        }
        ->
        microInjectImmadiateValue(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            value                       = 2**(2**20 - 1)
        )
        -> # input
        value = 2**(2**20 - 1)
        -> # output
        registerRead = {
            ('_imm', 0)                 : 2**(2**20 - 1)
        }
        -> # written
        ['_imm', 0];                    value = 2**(2**20 - 1);    bitLength = 2**20
        -> # returned
        ['_imm', 0]
        """
        
        value : int = 2**(2**20 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()

        returnValue : tuple[str, int] = self.ISA.microInjectImmediateValue(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            value                                                               = value
        )

        expectedReturnValue : tuple[str, int] = ('_imm', 0)

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
            ('createImm',               '_imm', 0,                              value)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = copy.deepcopy(MMMU.getActivity())

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            ('_imm', 0,                 2**(2**20 - 1)),                        # input, no change
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        expectedBitLength : int = 2**20

        resultBitLength : int = MMMU.dummyGetConfigWrapper(('_imm', 0))['bitLength']

        self.assertEqual(returnValue, expectedReturnValue,
            f'\nAssert function return value:\nExpected {expectedReturnValue}\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertEqual(expectedBitLength, resultBitLength,
            # f'\nAssert correct bitLength:\nExpected bitLength:\n\t{expectedBitLength}\nResult bitLength:\n\t{resultBitLength}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    #TODO testing on microSelectBits

    #TODO testing on opNop
    
    def test_opAdd_Exception_funcReadNotFunction(self):
        """tests opAdd raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAdd, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerB                                                   = self.registerNull
                )

    def test_opAdd_Exception_funcWriteNotFunction(self):
        """tests opAdd raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAdd,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opAdd_Exception_funcGetConfigNotFunction(self):
        """tests opAdd raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAdd,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opAdd_Exception_registerDestinationNotRegister(self):
        """tests opAdd raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAdd,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opAdd_Exception_registerANotRegister(self):
        """tests opAdd raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAdd,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerB                                                   = self.registerNull
                )

    def test_opAdd_Exception_registerBNotRegister(self):
        """tests opAdd raises an exception when registerB is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAdd,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = register # test with invalid register
                )

    def test_opAdd_Exception_registerDestinationNotInMMMU(self):
        """tests opAdd passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAdd,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull
        )

    def test_opAdd_Exception_registerANotInMMMU(self):
        """tests opAdd passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAdd,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerB                                                           = self.registerNull
        )

    def test_opAdd_Exception_registerBNotInMMMU(self):
        """tests opAdd passes through a raised MMMUAccessError exception when registerB is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAdd,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = register # test with invalid register
        )

    def test_opAdd_singleRegister01(self):
        """tests opAdd on 'r0 + r0 = r0' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        
        'r0 + r0 = r0' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 0 
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_singleRegister02(self):
        """tests opAdd on 'r0 + r0 = r0' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        
        'r0 + r0 = r0' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        """

        r0 : int = 1
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_multiRegister01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        r1 = [0, 1];                    value = 0; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_multiRegister02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        r1 = [0, 1];                    value = 1; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_multiRegister03(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        r1 = [0, 1];                    value = 0; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_multiRegister04(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        r1 = [0, 1];                    value = 1; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_zeroBitLength01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '0, 0, 0' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '0, 0, 0' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_zeroBitLength02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 2'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 2; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_zeroBitLength03A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '0, 8, 8' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '0, 8, 8' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
    
    def test_opAdd_zeroBitLength03B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 0, 8' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '8, 0, 8' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_zeroBitLength03C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 0' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '8, 8, 0' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength01A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 1, 1' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '8, 1, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8                |
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength01B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 8, 1' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 8, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8                |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength01C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 8' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1, 8' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength02A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 1, 1' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '8, 1, 1' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8                |
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 1
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength02B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 8, 1' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 8, 1' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8                |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength02C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 8' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 8' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),       
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength03A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 1, 1' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '8, 1, 1' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8                |
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength03B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 8, 1' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 8, 1' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8                |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength03C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 8' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 8' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength04A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 1, 1' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '8, 1, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8                |
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength04B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 8, 1' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 8, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8                |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_variableBitLength04C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 8' -> '1 + 1 = 2'
        
        'r0 + r1 = r2' with bitLength '1, 1, 8' -> '1 + 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 2'
        -> # output 
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterIndex01(self):
        """tests opAdd on 'r1024 + r1 = r2' with bitLength '8, 8, 8' -> '0x08 + 0x0a = 0x12
        
        'r1024 + r1 = r2' with bitLength '8, 8, 8' -> '0x08 + 0x0a = 0x12'
        -> # create registers
        r1024 = [0, 1024];              value = 0x08; bitLength = 8             |
        r1 = [0, 1];                    value = 0x0a; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]                             |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x08
        registerB                       = 0x0a
        ->
        '0x08 + 0x0a = 0x12'
        -> # output
        registerDestination             = 0x12
        -> # written
        r2 = [0, 2];                    value = 0x12; bitLength = 8
        '"""

        r0 : int = 0x08
        r1 : int = 0x0a
        r2_out : int = 0x12
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterIndex02(self):
        """tests opAdd on 'r0 + r1024 = r2' with bitLength '8, 8, 8' -> '0x08 + 0x0a = 0x12'
        
        'r0 + r1024 = r2' with bitLength '8, 8, 8' -> '0x08 + 0x0a = 0x12'
        -> # create registers
        r0 = [0, 0];                    value = 0x08; bitLength = 8
        r1024 = [0, 1024];              value = 0x0a; bitLength = 8             |
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1024]                             |
        )
        -> # input
        registerA                       = 0x08
        registerB                       = 0x0a
        ->
        '0x08 + 0x0a = 0x12'
        -> # output
        registerDestination             = 0x12
        -> # written
        r2 = [0, 2];                    value = 0x12; bitLength = 8
        """
        
        r0 : int = 0x08
        r1 : int = 0x0a
        r2_out : int = 0x12

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1024,                   r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterIndex03(self):
        """tests opAdd on 'r0 + r1 = r1024' with bitLength '8, 8, 8' -> '0x08 + 0x0a = 0x12'
        
        'r0 + r1 = r1024' with bitLength '8, 8, 8' -> '0x08 + 0x0a = 0x12'
        -> # create registers
        r0 = [0, 0];                    value = 0x08; bitLength = 8
        r1 = [0, 1];                    value = 0x0a; bitLength = 8
        r1024 = [0, 1024];              value = 0x00; bitLength = 8             |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]                             |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x08
        registerB                       = 0x0a
        ->
        '0x08 + 0x0a = 0x12'
        -> # output
        registerDestination             = 0x12
        -> # written
        r1024 = [0, 1024];              value = 0x12; bitLength = 8
        """

        r0 : int = 0x08
        r1 : int = 0x0a
        r2_out : int = 0x12
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 1024,                   r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize01A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x00; bitLength = 1024          |
        r1 = [0, 1];                    value = 0x00; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x00
        registerB                       = 0x00
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        """

        r0 : int = 0x00
        r1 : int = 0x00
        r2_out : int = 0x00
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize01B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x00; bitLength = 1
        r1 = [0, 1];                    value = 0x00; bitLength = 1024          |
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0x00
        registerB                       = 0x00
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        """

        r0 : int = 0x00
        r1 : int = 0x00
        r2_out : int = 0x00
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize01C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x00; bitLength = 1
        r1 = [0, 1];                    value = 0x00; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1024          |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x00
        registerB                       = 0x00
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 1024          |
        """

        r0 : int = 0x00
        r1 : int = 0x00
        r2_out : int = 0x00
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize02A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x00; bitLength = 1024          |
        r1 = [0, 1];                    value = 0x01; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x00
        registerB                       = 0x01
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 1
        """

        r0 : int = 0x00
        r1 : int = 0x01
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize02B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x00; bitLength = 1
        r1 = [0, 1];                    value = 0x01; bitLength = 1024          |
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0x00
        registerB                       = 0x01
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 1
        """

        r0 : int = 0x00
        r1 : int = 0x01
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize02C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x00; bitLength = 1
        r1 = [0, 1];                    value = 0x01; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1024          |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x00
        registerB                       = 0x01
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 1024          |
        """

        r0 : int = 0x00
        r1 : int = 0x01
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize03A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 1024          |
        r1 = [0, 1];                    value = 0x00; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 0x00
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 1
        """

        r0 : int = 0x01
        r1 : int = 0x00
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize03B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 1
        r1 = [0, 1];                    value = 0x00; bitLength = 1024          |
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 0x00
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 1
        """

        r0 : int = 0x01
        r1 : int = 0x00
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize03C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 1
        r1 = [0, 1];                    value = 0x00; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1024          |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 0x00
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 1
        """

        r0 : int = 0x01
        r1 : int = 0x00
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize04A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '1024, 1, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 1024          |
        r1 = [0, 1];                    value = 0x01; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 0x01
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        """
        
        r0 : int = 0x01
        r1 : int = 0x01
        r2_out : int = 0x00

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize04B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1024, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 1
        r1 = [0, 1];                    value = 0x01; bitLength = 1024          |
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 0x01
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 1
        """

        r0 : int = 0x01
        r1 : int = 0x01
        r2_out : int = 0x00
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize04C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '1 + 1 = 2'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1024' -> '1 + 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 1
        r1 = [0, 1];                    value = 0x01; bitLength = 1
        r2 = [0, 2];                    value = 0x00; bitLength = 1024          |
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 0x01
        ->
        '1 + 1 = 2'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x02; bitLength = 1024
        """

        r0 : int = 0x01
        r1 : int = 0x01
        r2_out : int = 0x02
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize05A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '1024, 8, 8' -> '0x0f + 0x0f = 0x1e'
        
        'r0 + r1 = r2' with bitLength '1024, 8, 8' -> '0x0f + 0x0f = 0x1e'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 1024
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0x0f
        ->
        '0x0f + 0x0f = 0x1e'
        -> # output
        registerDestination             = 0x1e
        -> # written
        r2 = [0, 2];                    value = 0x1e; bitLength = 8
        """

        r0 : int = 0x0f
        r1 : int = 0x0f
        r2_out : int = 0x1e
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize05B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 1024, 8' -> '0x0f + 0x0f = 0x1e'
        
        'r0 + r1 = r2' with bitLength '8, 1024, 8' -> '0x0f + 0x0f = 0x1e'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 1024
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0x0f
        ->
        '0x0f + 0x0f = 0x1e'
        -> # output
        registerDestination             = 0x1e
        -> # written
        r2 = [0, 2];                    value = 0x1e; bitLength = 8
        """

        r0 : int = 0x0f
        r1 : int = 0x0f
        r2_out : int = 0x1e
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize05C(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 1024' -> '0x0f + 0x0f = 0x1e'
        
        'r0 + r1 = r2' with bitLength '8, 8, 1024' -> '0x0f + 0x0f = 0x1e'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 1024
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0x0f
        ->
        '0x0f + 0x0f = 0x1e'
        -> # output
        registerDestination             = 0x1e
        -> # written
        r2 = [0, 2];                    value = 0x1e; bitLength = 1024
        """
        
        r0 : int = 0x0f
        r1 : int = 0x0f
        r2_out : int = 0x1e

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize06A(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '1 + 2**(2**19) = 2**(2**19) + 1'
        
        'r0 + r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '1 + 2**(2**19) = 2**(2**19) + 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**19); bitLength = 2**20
        r2 = [0, 2];                    value = 0x00; bitLength = 2**20
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x01
        registerB                       = 2**(2**19)
        ->
        '1 + 2**(2**19) = 2**(2**19) + 1'
        -> # output
        registerDestination             = 2**(2**19) + 1
        -> # written
        r2 = [0, 2];                    value = 2**(2**19) + 1; bitLength = 2**20
        """

        r0 : int = 0x01
        r1 : int = 2**(2**19)
        r2_out : int = 2**(2**19) + 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_largeRegisterSize06B(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**19) + 2**(2**19) = 2**(2**19 + 1)'
        
        'r0 + r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**19) + 2**(2**19) = 2**(2**19 + 1)'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**19); bitLength = 2**20
        r2 = [0, 2];                    value = 0x00; bitLength = 2**20
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 2**(2**19)
        registerB                       = 2**(2**19)
        ->
        '2**(2**19) + 2**(2**19) = 2**(2**19 + 1)'
        -> # output
        registerDestination             = 2**(2**19 + 1)
        -> # written
        r2 = [0, 2];                    value = 2**(2**19 + 1); bitLength = 2**20
        """

        r0 : int = 2**(2**19)
        r1 : int = 2**(2**19)
        r2_out : int = 2**(2**19 + 1)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opAdd_zfighting01(self):
        """tests opAdd on 'r0 + r0 = r0' with bitLength '8, 8, 8' -> '0xff + 0xff = 0xfe'
        
        'r0 + r0 = r0' with bitLength '8, 8, 8' -> '0xff + 0xff = 0xfe'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff + 0xff = 0xfe'
        -> # output
        registerDestination             = 0xfe
        -> # written
        r2 = [0, 2];                    value = 0xfe; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0xfe
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPattern1BitSweep01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) + (1 << y) = ?' for x in range(8) for y in range(8)]
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) + (1 << y) = ?' for x in range(8) for y in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = (1 << y); bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) + (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = (r0 + r1) & (2**8 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opAdd(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPattern1BitSweep02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) + (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 + r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) + (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 512
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) + (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 512
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = (r0 + r1) & (2**512 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opAdd(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPattern1BitSweep03(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) + (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 + r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) + (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) + (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = (r0 + r1) & (2**2048 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opAdd(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPatternCheckerboardConstructive01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... + 0b1010... = 0b0101...'
        
        'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... + 0b1010... = 0b0101...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0x00; bitLength = 2048
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... + 0b1010... = 0b0101...'
        -> # output
        registerDestination             = 0b0101...
        -> # written
        r2 = [0, 2];                    value = 0b0101...; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = (r0 + r1) & (2**2048 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPatternCheckerboardConstructive02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... + 0b0101... = 0b1010...'
        
        'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... + 0b0101... = 0b1010...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0x00; bitLength = 2048
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b0101...
        ->
        '0b0101... + 0b0101... = 0b1010...'
        -> # output
        registerDestination             = 0b1010...
        -> # written
        r2 = [0, 2];                    value = 0b1010...; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = (r0 + r1) & (2**2048 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPatternCheckerboardDestructive01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... + 0b0101... = 0b1111...'
        
        'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... + 0b0101... = 0b1111...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0x00; bitLength = 2048
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... + 0b0101... = 0b1111...'
        -> # output
        registerDestination             = 0b1111...
        -> # written
        r2 = [0, 2];                    value = 0b1111...; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 2**2048 - 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_inputBitPatternCheckerboardDestructive02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... + 0b1010... = 0b1111...'
        
        'r0 + r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... + 0b1010... = 0b1111...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0x00; bitLength = 2048
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... + 0b1010... = 0b1111...'
        -> # output
        registerDestination             = 0b1111...
        -> # written
        r2 = [0, 2];                    value = 0b1111...; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 2**2048 - 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_bitpattern8bit4Overlap(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0xfc + 0x3f = 0x3b'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0xfc + 0x3f = 0x3b'
        -> # create registers
        r0 = [0, 0];                    value = 0xfc; bitLength = 8
        r1 = [0, 1];                    value = 0x3f; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc + 0x3f = 0x3b'
        -> # output
        registerDestination             = 0x3b
        -> # written
        r2 = [0, 2];                    value = 0x3b; bitLength = 8
        """
        
        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0x3b

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_8bitFullCombination01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['x + y = ?' for x in range(256) for y in range(256)]
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['x + y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x + y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x + y) & (2**8 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opAdd(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_8bitFullCombination02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 16' -> ['x + y = ?' for x in range(256) for y in range(256)]
        
        'r0 + r1 = r2' with bitLength '8, 8, 16' -> ['x + y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0x0000; bitLength = 16
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x + y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 16
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x + y) & (2**16 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 16)

                returnValue : None = self.ISA.opAdd(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   16),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_integration01(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_integration02(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 2'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_integration03(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0x0f + 0xf0 = 0xff'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0x0f + 0xf0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0xf0; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0xf0
        ->
        '0x0f + 0xf0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """
        
        r0 : int = 0x0f
        r1 : int = 0xf0
        r2_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_integration04(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0x03 + 0x02 = 0x05'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0x03 + 0x02 = 0x05'
        -> # create registers
        r0 = [0, 0];                    value = 0x03; bitLength = 8
        r1 = [0, 1];                    value = 0x02; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x03
        registerB                       = 0x02
        ->
        '0x03 + 0x02 = 0x05'
        -> # output
        registerDestination             = 0x05
        -> # written
        r2 = [0, 2];                    value = 0x05; bitLength = 8
        """
        
        r0 : int = 0x03
        r1 : int = 0x02
        r2_out : int = 0x05

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAdd_integration05(self):
        """tests opAdd on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0xff + 0x01 = 0x00'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0xff + 0x01 = 0x00'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x01; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opAdd(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x01
        ->
        '0xff + 0x01 = 0x00'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0x01
        r2_out : int = 0x00

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAdd(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_Exception_funcReadNotFunction(self):
        """tests opAddCarryOverflow raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerB                                                   = self.registerNull, 
                    registerCarry                                               = self.registerNull, 
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_funcWriteNotFunction(self):
        """tests opAddCarryOverflow raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull,
                    registerCarry                                               = self.registerNull,
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_funcGetConfigNotFunction(self):
        """tests opAddCarryOverflow raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull,
                    registerCarry                                               = self.registerNull,
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_registerDestinationNotRegister(self):
        """tests opAddCarryOverflow raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull,
                    registerCarry                                               = self.registerNull,
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_registerANotRegister(self):
        """tests opAddCarryOverflow raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerB                                                   = self.registerNull,
                    registerCarry                                               = self.registerNull,
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_registerBNotRegister(self):
        """tests opAddCarryOverflow raises an exception when registerB is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = register, # test with invalid register
                    registerCarry                                               = self.registerNull,
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_registerCarryNotRegister(self):
        """tests opAddCarryOverflow raises an exception when registerCarry is not a register"""
        
        registers : list[Any] = [i for i in self.registerInvalid if i != None] # registerCarry can accept None

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull,
                    registerCarry                                               = register, # test with invalid register
                    registerOverflow                                            = self.registerNull
                )

    def test_opAddCarryOverflow_Exception_registerOverflowNotRegister(self):
        """tests opAddCarryOverflow raises an exception when registerOverflow is not a register"""
        
        registers : list[Any] = [i for i in self.registerInvalid if i != None] # registerCarry can accept None

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAddCarryOverflow,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull,
                    registerCarry                                               = self.registerNull,
                    registerOverflow                                            = register # test with invalid register
                )

    def test_opAddCarryOverflow_Exception_registerDestinationNotInMMMU(self):
        """tests opAddCarryOverflow passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAddCarryOverflow,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull,
            registerCarry                                                       = self.registerNull,
            registerOverflow                                                    = self.registerNull
        )

    def test_opAddCarryOverflow_Exception_registerANotInMMMU(self):
        """tests opAddCarryOverflow passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAddCarryOverflow,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerB                                                           = self.registerNull,
            registerCarry                                                       = self.registerNull,
            registerOverflow                                                    = self.registerNull
        )

    def test_opAddCarryOverflow_Exception_registerBNotInMMMU(self):
        """tests opAddCarryOverflow passes through a raised MMMUAccessError exception when registerB is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAddCarryOverflow,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = register, # test with invalid register
            registerCarry                                                       = self.registerNull,
            registerOverflow                                                    = self.registerNull
        )

    def test_opAddCarryOverflow_Exception_registerCarryNotInMMMU(self):
        """tests opAddCarryOverflow passes through a raised MMMUAccessError exception when registerCarry is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAddCarryOverflow,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull,
            registerCarry                                                       = register, # test with invalid register
            registerOverflow                                                    = self.registerNull
        )

    def test_opAddCarryOverflow_Exception_registerOverflowNotInMMMU(self):
        """tests opAddCarryOverflow passes through a raised MMMUAccessError exception when registerOverflow is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAddCarryOverflow,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull,
            registerCarry                                                       = self.registerNull,
            registerOverflow                                                    = register # test with invalid register
        )

    def test_opAddCarryOverflow_singleRegister01(self):
        """tests opAddCarryOverflow on 'r0 + r0 = r0' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        
        'r0 + r0 = r0' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_singleRegister01(self):
        """tests opAddCarryOverflow on 'r0 + r0 = r0' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        
        'r0 + r0 = r0' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        """
        
        r0 : int = 1
        r0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_multiRegister01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        r1 = [0, 1];                    value = 0; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_multiRegister02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 1 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '0 + 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        r1 = [0, 1];                    value = 1; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 + 1 = 1'
        -> # output
        registerDestination             = 1
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_multiRegister03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 0 = 1'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        r1 = [0, 1];                    value = 0; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 + 0 = 1'
        -> # output
        registerDestination             = 1
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_multiRegister04(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        
        'r0 + r1 = r2' with bitLength '1, 1, 1' -> '1 + 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        r1 = [0, 1];                    value = 1; bitLength = 1                |
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carry01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '0 + 0 = 0, c = 0'
        
        'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '0 + 0 = 0, c = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 0                                     |
        ->
        '0 + 0 = 0, c = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0                                     |
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carry02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '0 + 1 = 1, c = 0'
        
        'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '0 + 1 = 1, c = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 1                                     |
        ->
        '0 + 1 = 1, c = 0'
        -> # output
        registerDestination             = 1
        registerCarry                   = 0                                     |
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        c0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        
        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carry03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '1 + 0 = 1, c = 0'
        
        'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '1 + 0 = 1, c = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = None
        )
        -> # input
        registerA                       = 1                                     |
        registerB                       = 0                                     |
        ->
        '1 + 0 = 1, c = 0'
        -> # output
        registerDestination             = 1
        registerCarry                   = 0                                     |
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        c0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carry04(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '1 + 1 = 0, c = 1'
        
        'r0 + r1 = r2, c = c0' with bitLength '1, 1, 1, 1' -> '1 + 1 = 0, c = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = None
        )
        -> # input
        registerA                       = 1                                     |
        registerB                       = 1                                     |
        ->
        '1 + 1 = 0, c = 1'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1                                     |
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 1; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        c0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_overflow01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '0 + 0 = 0, o = 0'
        
        'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '0 + 0 = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 0                                     |
        ->
        '0 + 0 = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_overflow02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '0 + 1 = 1, o = 0'
        
        'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '0 + 1 = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 1                                     |
        ->
        '0 + 1 = 1, o = 1'
        -> # output
        registerDestination             = 1
        registerCarry                   = None
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_overflow03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '1 + 0 = 1, o = 0'
        
        'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '1 + 0 = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1                                     |
        registerB                       = 0                                     |
        ->
        '1 + 0 = 1, o = 1'
        -> # output
        registerDestination             = 1
        registerCarry                   = None
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_overflow04(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '1 + 1 = 0, o = 1'
        
        'r0 + r1 = r2, o = o0' with bitLength '1, 1, 1, 1' -> '1 + 1 = 0, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1                                     |
        registerB                       = 1                                     |
        ->
        '1 + 1 = 0, o = 1'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = 1                                     |
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 1; bitLength = 1                |
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        o0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carryOverflow01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 0                                     |
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0                                     |
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1                |
        o0 = ['o', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carryOverflow02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '0 + 1 = 1, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '0 + 1 = 1, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 1                                     |
        ->
        '0 + 1 = 1, c = 0, o = 0'
        -> # output
        registerDestination             = 1
        registerCarry                   = 0                                     |
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1                |
        o0 = ['o', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carryOverflow03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '1 + 0 = 1, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '1 + 0 = 1, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1                                     |
        registerB                       = 0                                     |
        ->
        '1 + 0 = 1, c = 0, o = 0'
        -> # output
        registerDestination             = 1
        registerCarry                   = 0                                     |
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1                |
        o0 = ['o', 0];                  value = 0; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_simpleAdd_carryOverflow04(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '1 + 1 = 0, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 1' -> '1 + 1 = 0, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1                                     |
        registerB                       = 1                                     |
        ->
        '1 + 1 = 0, c = 1, o = 1'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1                                     |
        registerOverflow                = 1                                     |
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 1; bitLength = 1                |
        o0 = ['o', 0];                  value = 1; bitLength = 1                |
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zeroBitLength01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '0, 0, 0, 0, 0' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '0, 0, 0, 0, 0' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        c0 = ['c', 0];                  value = 0; bitLength = 0                |
        o0 = ['o', 0];                  value = 0; bitLength = 0                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]                              |
            registerOverflow            = ['o', 0]                              |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        c0 = ['c', 0];                  value = 0; bitLength = 0                |
        o0 = ['o', 0];                  value = 0; bitLength = 0                |
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 0)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 0)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 0),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 0),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zeroBitLength02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 8, 8' -> '0x81 + 0x81 = 0x102 = 0x02, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 8, 8' -> '0x81 + 0x81 = 0x102 = 0x02, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x81; bitLength = 8
        r1 = [0, 1];                    value = 0x81; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0x81
        registerB                       = 0x81
        ->
        '0x81 + 0x81 = 0x102 = 0x02, c = 1, o = 1'
        -> # output
        registerDestination             = 0x02
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0x02; bitLength = 8
        c0 = ['c', 0];                  value = 1; bitLength = 8
        o0 = ['o', 0];                  value = 1; bitLength = 8
        """
        
        r0 : int = 0x81
        r1 : int = 0x81
        r2_out : int = 0x02
        c0_out : int = 1
        o0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zeroBitLength03A(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '0, 8, 8, 8, 8' -> '0 + 0x81 = 0x81, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '0, 8, 8, 8, 8' -> '0 + 0x81 = 0x81, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 0x81; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0x81
        ->
        '0 + 0x81 = 0x81, c = 0, o = 0'
        -> # output
        registerDestination             = 0x81
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0x81; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 0x81
        r2_out : int = 0x81
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
    
    def test_opAddCarryOverflow_zeroBitLength03B(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 0, 8, 8, 8' -> '0x81 + 0 = 0x81, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 0, 8, 8, 8' -> '0x81 + 0 = 0x81, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x81; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0x81
        registerB                       = 0
        ->
        '0x81 + 0 = 0x81, c = 0, o = 0'
        -> # output
        registerDestination             = 0x81
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0x81; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        """
        
        r0 : int = 0x81
        r1 : int = 0
        r2_out : int = 0x81
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zeroBitLength03C(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 0, 8, 8' -> '0x81 + 0x81 = 0, c = 1, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 0, 8, 8' -> '0x81 + 0x81 = 0, c = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x81; bitLength = 8
        r1 = [0, 1];                    value = 0x81; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        c0 = ['c', 0];                  value = 1; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0x81
        registerB                       = 0x81
        ->
        '0x81 + 0x81 = 0, c = 1, o = 0'
        -> # output
        registerDestination             = 0                                     |
        registerCarry                   = 1
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        c0 = ['c', 0];                  value = 1; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        """
        
        r0 : int = 0x81
        r1 : int = 0x81
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)
        MMMU.createRegister(            'c', 0,                                 value = 1, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zeroBitLength03D(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 0, 8' -> '0x81 + 0x81 = 0x102 = 0x02, c = 0, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 0, 8' -> '0x81 + 0x81 = 0x102 = 0x02, c = 0, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0x81; bitLength = 8
        r1 = [0, 1];                    value = 0x81; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 0                |
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]                              |
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0x81
        registerB                       = 0x81
        ->
        '0x81 + 0x81 = 0, c = 0, o = 1'
        -> # output
        registerDestination             = 0x02
        registerCarry                   = 0                                     |
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0x02; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 0                |
        o0 = ['o', 0];                  value = 1; bitLength = 8
        """
        
        r0 : int = 0x81
        r1 : int = 0x81
        r2_out : int = 0x02
        c0_out : int = 0
        o0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 0)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 0),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zeroBitLength03E(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 8, 0' -> '0x81 + 0x81 = 0x102 = 0x02, c = 1, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 8, 0' -> '0x81 + 0x81 = 0x102 = 0x02, c = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x81; bitLength = 8
        r1 = [0, 1];                    value = 0x81; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 0                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]                              |
        )
        -> # input
        registerA                       = 0x81
        registerB                       = 0x81
        ->
        '0x81 + 0x81 = 0, c = 1, o = 0'
        -> # output
        registerDestination             = 0x02
        registerCarry                   = 1
        registerOverflow                = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 0x02; bitLength = 8
        c0 = ['c', 0];                  value = 1; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 0                |
        """
        
        r0 : int = 0x81
        r1 : int = 0x81
        r2_out : int = 0x02
        c0_out : int = 1
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 0)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 0),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength01A(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 1, 1, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 1, 1, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8                |
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0                                     |
        registerB                       = 0
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength01B(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 8, 1, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 8, 1, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8                |
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0                                     |
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength01C(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 8, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 8, 1, 1' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength01D(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 8, 1' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 8, 1' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 8                |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]                              |
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 8                |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength01E(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 8' -> '0 + 0 = 0, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 8' -> '0 + 0 = 0, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 8                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]                              |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 8                |
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength02A(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 1, 1, 1, 1' -> '255 + 1 = 0, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 1, 1, 1, 1' -> '255 + 1 = 0, c = 1, o = 1'
        -> # create registers
        r0 = [255, 255];                value = 255; bitLength = 8              |
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 255                                   |
        registerB                       = 1
        ->
        '255 + 1 = 0, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 1; bitLength = 1
        o0 = ['o', 0];                  value = 1; bitLength = 1
        """

        r0 : int = 255
        r1 : int = 1
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength02B(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 8, 1, 1, 1' -> '1 + 255 = 0, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 8, 1, 1, 1' -> '1 + 255 = 0, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 255; bitLength = 8              |
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 255                                   |
        ->
        '1 + 255 = 0, c = 1, o = 1'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 1; bitLength = 1
        o0 = ['o', 0];                  value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 255
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength02C(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 8, 1, 1' -> '1 + 1 = 2, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 8, 1, 1' -> '1 + 1 = 2, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8                |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 2, c = 0, o = 0'
        -> # output
        registerDestination             = 2
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8                |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        c0_out : int = 0
        o0_out : int = 0
                
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength02D(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 8, 1' -> '1 + 1 = 0, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 8, 1' -> '1 + 1 = 0, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 8                |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]                              |
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 2, c = 0, o = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 1; bitLength = 8                |
        o0 = ['o', 0];                  value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_variableBitLength02E(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 8' -> '1 + 1 = 0, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1, 1, 1, 1, 8' -> '1 + 1 = 0, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 8                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]                              |
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 0, c = 1, o = 1'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        c0 = ['c', 0];                  value = 1; bitLength = 1
        o0 = ['o', 0];                  value = 1; bitLength = 8                |
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
    
    def test_opAddCarryOverflow_largeRegisterIndex01(self):
        """tests opAddCarryOverflow on 'r1024 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r1024 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r1024 = [0, 1024];              value = 0; bitLength = 8                |
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]                             |
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r1024 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterIndex02(self):
        """tests opAddCarryOverflow on 'r0 + r1024 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1024 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1024 = [0, 1024];              value = 4; bitLength = 8                |
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1024]                             |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1024 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1024],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1024,                   r1024),                                 # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterIndex03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r1024, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r1024, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8                |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]                             |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r1024 = [0, 1024];              value = 16; bitLength = 8               |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1 : int = 4
        r1024_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 1024,                   r1024_out),                             # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterIndex04(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c1024, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c1024, o = o0' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c1024 = ['c', 1024];            value = 0; bitLength = 1                |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 1024]                           |
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c1024 = ['c', 1024];            value = 0; bitLength = 1                |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c1024_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 1024,                              value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 1024],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 1024,                              1),
            ('write',                   'c', 1024,                              c1024_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 1024,                 c1024_out),                             # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterIndex05(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o1024' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o1024' with bitLength '8, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o1024 = ['o', 1024];            value = 0; bitLength = 1                |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 1024]                           |
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o1024 = ['o', 1024];            value = 0; bitLength = 1                |
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o1024_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 1024,                              value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 1024,                              1),
            ('write',                   'o', 1024,                              o1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 1024,                 o1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize01A(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1024, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1024, 8, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 1024            |
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]
        
        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize01B(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 1024, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 1024, 8, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 1024             |
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize01C(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 1024, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 1024, 1, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 1024            |
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize01D(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1024, 1' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1024, 1' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1024             |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]                              |
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1024             |
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1024)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1024),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize01E(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1024' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1024' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 8
        r1 = [0, 1];                    value = 4; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1024             |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]                              |
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1024             |
        """

        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1024),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1024, 1024, 1024, 1024, 1024' -> '12 + 4 = 16, c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1024, 1024, 1024, 1024, 1024' -> '12 + 4 = 16, c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 12; bitLength = 1024            |
        r1 = [0, 1];                    value = 4; bitLength = 1024             |
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        c0 = ['c', 0];                  value = 0; bitLength = 1024             |
        o0 = ['o', 0];                  value = 0; bitLength = 1024             |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]                              |
            registerOverflow            = ['o', 0]                              |
        )
        -> # input
        registerA                       = 12
        registerB                       = 4
        ->
        '12 + 4 = 16, c = 0, o = 0'
        -> # output
        registerDestination             = 16
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 16; bitLength = 1024            |
        c0 = ['c', 0];                  value = 0; bitLength = 1024             |
        o0 = ['o', 0];                  value = 0; bitLength = 1024             |
        """
        
        r0 : int = 12
        r1 : int = 4
        r2_out : int = 16
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1024)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1024),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1024),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '1024, 1024, 1024, 1024, 1024' -> '0x1111... + 0x2222... = 0x3333..., c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '1024, 1024, 1024, 1024, 1024' -> '0x1111... + 0x2222... = 0x3333..., c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x1111...; bitLength = 1024     |
        r1 = [0, 1];                    value = 0x2222...; bitLength = 1024     |
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        c0 = ['c', 0];                  value = 0; bitLength = 1024
        o0 = ['o', 0];                  value = 0; bitLength = 1024
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0x1111... = sum([1 << (i*4) for i in range(256)])     |
        registerB                       = 0x2222... = sum([2 << (i*4) for i in range(256)])     |
        ->
        '0x1111... + 0x2222... = 0x3333..., c = 0, o = 0'
        -> # output
        registerDestination             = 0x3333... = sum([3 << (i*4) for i in range(256)])     |
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0x3333...; bitLength = 1024     |
        c0 = ['c', 0];                  value = 0; bitLength = 1024
        o0 = ['o', 0];                  value = 0; bitLength = 1024
        """

        r0 : int = sum([1 << (i*4) for i in range(256)])
        r1 : int = sum([2 << (i*4) for i in range(256)])
        r2_out : int = sum([3 << (i*4) for i in range(256)])
        c0_out : int = 0
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1024)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1024),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1024),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_largeRegisterSize04A(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2**20, 2**20, 2**20, 2**20, 2**20' -> '2**(2**20 - 1) + 2**(2**20 - 1) = 0, c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2**20, 2**20, 2**20, 2**20, 2**20' -> '2**(2**20 - 1) + 2**(2**20 - 1) = 0, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20 - 1); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**20 - 1); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        c0 = ['c', 0];                  value = 0; bitLength = 2**20
        o0 = ['o', 0];                  value = 0; bitLength = 2**20
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 2**(2**20 - 1)
        registerB                       = 2**(2**20 - 1)
        ->
        '2**(2**20 - 1) + 2**(2**20 - 1) = 0, c = 1, o = 1'
        -> # output
        registerDestination             = 0
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        c0 = ['c', 0];                  value = 1; bitLength = 2**20
        o0 = ['o', 0];                  value = 1; bitLength = 2**20
        """

        r0 : int = 2**(2**20 - 1)
        r1 : int = 2**(2**20 - 1)
        r2_out : int = 0
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 2**20)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 2**20),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 2**20),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opAddCarryOverflow_largeRegisterSize04B(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2**20, 2**20, 2**20, 2**20, 2**20' -> '2**(2**20 - 2) + 2**(2**20 - 2) = 2**(2**20 - 1), c = 0, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2**20, 2**20, 2**20, 2**20, 2**20' -> '2**(2**20 - 2) + 2**(2**20 - 2) = 2**(2**20 - 1), c = 0, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20 - 2); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**20 - 2); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        c0 = ['c', 0];                  value = 0; bitLength = 2**20
        o0 = ['o', 0];                  value = 0; bitLength = 2**20
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 2**(2**20 - 2)
        registerB                       = 2**(2**20 - 2)
        ->
        '2**(2**20 - 2) + 2**(2**20 - 2) = 2**(2**20 - 1), c = 0, o = 1'
        -> # output
        registerDestination             = 2**(2**20 - 1)
        registerCarry                   = 0
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 2**(2**20 - 1); bitLength = 2**20
        c0 = ['c', 0];                  value = 0; bitLength = 2**20
        o0 = ['o', 0];                  value = 1; bitLength = 2**20
        """

        r0 : int = 2**(2**20 - 2)
        r1 : int = 2**(2**20 - 2)
        r2_out : int = 2**(2**20 - 1)
        c0_out : int = 0
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 2**20)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 2**20),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 2**20),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opAddCarryOverflow_zfighting01(self):
        """tests opAddCarryOverflow on 'r0 + r0 = r0, c = r0, o = r0' with bitLength '8, 8, 8, 8, 8' -> '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
        
        'r0 + r0 = r0, c = r0, o = r0' with bitLength '8, 8, 8, 8, 8' -> '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8             |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
            registerCarry               = [0, 0]                                |
            registerOverflow            = [0, 0]                                |
        )
        -> # input
        registerA                       = 0xff                                  |
        registerB                       = 0xff                                  |
        ->
        '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
        -> # output
        registerDestination             = 0xfe                                  |
        registerCarry                   = 1                                     |
        registerOverflow                = 0                                     |
        -> # written
        r0 = [0, 0];                    value = 0xfe; bitLength = 8             | # register will be in an undetermined value, due to write conflics
        r0 = [0, 0];                    value = 1                               |
        r0 = [0, 0];                    value = 0                               |
        """

        r0 : int = 0xff
        r0_out : int = 0xfe
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0],
            registerCarry                                                       = [0, 0],
            registerOverflow                                                    = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   r0_out),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   1),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   0)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      0x0),                                   # result is undetermined, due to conflicting writes
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        # self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
        #     f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zfighting02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = r2, o = r2' with bitLength '8, 8, 8, 8, 8' -> '0xf1 + 0x0f = 0x100 = 0x00, c = 1, o = 0'
        
        'r0 + r1 = r2, c = r2, o = r2' with bitLength '8, 8, 8, 8, 8' -> '0xf1 + 0x0f = 0x100 = 0x00, c = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xf1; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8             |
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = [0, 2]
            registerOverflow            = [0, 2]
        )
        -> # input
        registerA                       = 0xf1
        registerB                       = 0x0f
        ->
        '0xf1 + 0x0f = 0x100 = 0x00, c = 1, o = 0'
        -> # output
        registerDestination             = 0x00
        registerCarry                   = 1
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 8             | # register will be in an undetermined value, due to write conflics
        r2 = [0, 2];                    value = 1;   bitLength = 8              |
        r2 = [0, 2];                    value = 0;   bitLength = 8              |
        """

        r0 : int = 0xf1
        r1 : int = 0x0f
        r0_out : int = 0x00
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = [0, 2],
            registerOverflow                                                    = [0, 2]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r0_out),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   0)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 2,                      0x00),                                  # result is undetermined, due to conflicting writes
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        # self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
        #     f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_zfighting03(self):
        """tests opAddCarryOverflow on 'r0 + r0 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 8, 8' -> '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
        
        'r0 + r0 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 8, 8' -> '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8             |
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff + 0xff = 0x1fe = 0xfe, c = 1, o = 0'
        -> # output
        registerDestination             = 0xfe
        registerCarry                   = 1
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0xfe; bitLength = 8
        c0 = ['c', 0];                  value = 1; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        """

        r0 : int = 0xff
        r2_out : int = 0xfe
        c0_out : int = 1
        o0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 8)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 8),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 8),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPattern1BitSweep01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> ['(1 << x) + (1 << y) = ?, c = ?, o = ?' for x in range(8) for y in range(8)]
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> ['(1 << x) + (1 << y) = ?, c = ?, o = ?' for x in range(8) for y in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = (1 << y); bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        'x + y = ?, c = ?, o = ?'
        -> # output
        registerDestination             = ?
        registerCarry                   = ?
        registerOverflow                = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        c0 = ['c', 0];                  value = ?; bitLength = 8
        o0 = ['o', 0];                  value = ?; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = (r0 + r1) & (2**8 - 1)
                c0_out : int = 1 if r0 + r1 >= 2**8 else 0
                o0_out : int = 1 if ((r0 & 2**(8 - 1) == r1 & 2**(8 - 1)) and (r0 & 2**(8 - 1) != r2_out & 2**(8 - 1))) else 0

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)
                MMMU.createRegister(    'c', 0,                                 value = 0, bitLength = 1)
                MMMU.createRegister(    'o', 0,                                 value = 0, bitLength = 1)

                returnValue : None = self.ISA.opAddCarryOverflow(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1],
                    registerCarry                                               = ['c', 0],
                    registerOverflow                                            = ['o', 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out),
                    ('getConfig',       'c', 0,                                 1),
                    ('write',           'c', 0,                                 c0_out),
                    ('getConfig',       'o', 0,                                 1),
                    ('write',           'o', 0,                                 o0_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out),                                # output
                    ('c', 0,            c0_out),                                # output
                    ('o', 0,            o0_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPattern1BitSweep02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '512, 512, 512, 1, 1' -> ['(1 << x) + (1 << y) = ?, c = ?, o = ?' for x in range(512) for y in range(512)]
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '512, 512, 512, 1, 1' -> ['(1 << x) + (1 << y) = ?, c = ?, o = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 512
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        'x + y = ?, c = ?, o = ?'
        -> # output
        registerDestination             = ?
        registerCarry                   = ?
        registerOverflow                = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 512
        c0 = ['c', 0];                  value = ?; bitLength = 8
        o0 = ['o', 0];                  value = ?; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = (r0 + r1) & (2**512 - 1)
                c0_out : int = 1 if r0 + r1 >= 2**512 else 0
                o0_out : int = 1 if ((r0 & 2**(512 - 1) == r1 & 2**(512 - 1)) and (r0 & 2**(512 - 1) != r2_out & 2**(512 - 1))) else 0

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 512)
                MMMU.createRegister(    'c', 0,                                 value = 0, bitLength = 1)
                MMMU.createRegister(    'o', 0,                                 value = 0, bitLength = 1)

                returnValue : None = self.ISA.opAddCarryOverflow(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1],
                    registerCarry                                               = ['c', 0],
                    registerOverflow                                            = ['o', 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out),
                    ('getConfig',       'c', 0,                                 1),
                    ('write',           'c', 0,                                 c0_out),
                    ('getConfig',       'o', 0,                                 1),
                    ('write',           'o', 0,                                 o0_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out),                                # output
                    ('c', 0,            c0_out),                                # output
                    ('o', 0,            o0_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPattern1BitSweep03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '512, 512, 2048, 1, 1' -> ['(1 << x) + (1 << y) = ?, c = 0, o = 0' for x in range(512) for y in range(512)]
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '512, 512, 2048, 1, 1' -> ['(1 << x) + (1 << y) = ?, c = 0, o = 0' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 2048
        c0 = ['c', 0];                  value = 0; bitLength = 8
        o0 = ['o', 0];                  value = 0; bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        'x + y = ?, c = ?, o = ?'
        -> # output
        registerDestination             = ?
        registerCarry                   = ?
        registerOverflow                = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        c0 = ['c', 0];                  value = ?; bitLength = 1
        o0 = ['o', 0];                  value = ?; bitLength = 1
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = (r0 + r1) & (2**2048 - 1)
                c0_out : int = 0
                o0_out : int = 0

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 2048)
                MMMU.createRegister(    'c', 0,                                 value = 0, bitLength = 1)
                MMMU.createRegister(    'o', 0,                                 value = 0, bitLength = 1)

                returnValue : None = self.ISA.opAddCarryOverflow(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1],
                    registerCarry                                               = ['c', 0],
                    registerOverflow                                            = ['o', 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out),
                    ('getConfig',       'c', 0,                                 1),
                    ('write',           'c', 0,                                 c0_out),
                    ('getConfig',       'o', 0,                                 1),
                    ('write',           'o', 0,                                 o0_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out),                                # output
                    ('c', 0,            c0_out),                                # output
                    ('o', 0,            o0_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPatternCheckerboardConstructive01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b1010... + 0b1010... = 0b0101..., c = 1, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b1010.... + 0b1010... = 0b0101..., c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...;  bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...;  bitLength = 2048
        r2 = [0, 2];                    value = 0b0101...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 0;          bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... + 0b1010... = 0b0101..., c = 1, o = 1'
        -> # output
        registerDestination             = 0b0101...
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0b0101...;  bitLength = 2048
        c0 = ['c', 0];                  value = 1;          bitLength = 1
        o0 = ['o', 0];                  value = 1;          bitLength = 1
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = (r0 + r1) & (2**2048 - 1)
        c0_out : int = 1
        o0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPatternCheckerboardConstructive02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b0101.... + 0b0101... = 0b1010..., c = 0, o = 1'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b0101.... + 0b0101... = 0b1010..., c = 0, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...;  bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...;  bitLength = 2048
        r2 = [0, 2];                    value = 0b1010...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 0;          bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... + 0b1010... = 0b0101..., c = 0, o = 1'
        -> # output
        registerDestination             = 0b0101...
        registerCarry                   = 0
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 0b0101...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 1;          bitLength = 1
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = (r0 + r1) & (2**2048 - 1)
        c0_out : int = 0
        o0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPatternCheckerboardDestructive01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b1010.... + 0b0101... = 0b1111..., c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b1010.... + 0b0101... = 0b1111..., c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...;  bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...;  bitLength = 2048
        r2 = [0, 2];                    value = 0b1111...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 0;          bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... + 0b0101... = 0b1111..., c = 0, o = 0'
        -> # output
        registerDestination             = 0b1111...
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0b1111...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 0;          bitLength = 1
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = (r0 + r1) & (2**2048 - 1)
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPatternCheckerboardDestructive02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b0101.... + 0b1010... = 0b1111..., c = 0, o = 0'
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2048, 2048, 2048, 1, 1' -> '0b0101.... + 0b1010... = 0b1111..., c = 0, o = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...;  bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...;  bitLength = 2048
        r2 = [0, 2];                    value = 0b1111...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 0;          bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... + 0b1010... = 0b1111..., c = 0, o = 0'
        -> # output
        registerDestination             = 0b1111...
        registerCarry                   = 0
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0b1111...;  bitLength = 2048
        c0 = ['c', 0];                  value = 0;          bitLength = 1
        o0 = ['o', 0];                  value = 0;          bitLength = 1
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = (r0 + r1) & (2**2048 - 1)
        c0_out : int = 0
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_inputBitPattern8bit4Overlap(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> '0xfc + 0x3f = 0x13b = 0x3b, c = 1, o = 0'
        
        -> # create registers
        r0 = [0, 0];                    value = 0xfc;  bitLength = 8
        r1 = [0, 1];                    value = 0x3f;  bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        c0 = ['c', 0];                  value = 0; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc + 0x3f = 0x13b = 0x3b, c = 1, o = 0'
        -> # output
        registerDestination             = 0x3b
        registerCarry                   = 1
        registerOverflow                = 0
        -> # written
        r2 = [0, 2];                    value = 0x3b;  bitLength = 8
        c0 = ['c', 0];                  value = 1; bitLength = 1
        o0 = ['o', 0];                  value = 0; bitLength = 1
        """
        
        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0x3b
        c0_out : int = 1
        o0_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_8bitFullCombination(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> ['x + y = ?, c = ?, o = ?' for x in range(256) for y in range(256)]
        
        'r0 + r1 = r2, c = c0, o = o0' with bitLength '8, 8, 8, 1, 1' -> ['x + y = ?, c = ?, o = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x;             bitLength = 8
        r1 = [0, 1];                    value = y;             bitLength = 8
        r2 = [0, 2];                    value = 0;             bitLength = 8
        c0 = ['c', 0];                  value = 0;             bitLength = 1
        o0 = ['o', 0];                  value = 0;             bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x + y = ?, c = ?, o = ?'
        -> # output
        registerDestination             = ?
        registerCarry                   = ?
        registerOverflow                = ?
        -> # written
        r2 = [0, 2];                    value = ?;             bitLength = 8
        c0 = ['c', 0];                  value = ?;             bitLength = 1
        o0 = ['o', 0];                  value = ?;             bitLength = 1
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x + y) & (2**8 - 1)
                c0_out : int = 1 if (x + y) > (2**8 - 1) else 0
                o0_out : int = 1 if ((x & 2**(8 - 1) == y & 2**(8 - 1)) and (x & 2**(8 - 1) != r2_out & 2**(8 - 1))) else 0

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)
                MMMU.createRegister(    'c', 0,                                 value = 0, bitLength = 1)
                MMMU.createRegister(    'o', 0,                                 value = 0, bitLength = 1)

                returnValue : None = self.ISA.opAddCarryOverflow(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1],
                    registerCarry                                               = ['c', 0],
                    registerOverflow                                            = ['o', 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out),
                    ('getConfig',       'c', 0,                                 1),
                    ('write',           'c', 0,                                 c0_out),
                    ('getConfig',       'o', 0,                                 1),
                    ('write',           'o', 0,                                 o0_out),
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out),                                # output
                    ('c', 0,            c0_out),                                # output
                    ('o', 0,            o0_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_integration01(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0 + 0 = 0'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0 + 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0;          bitLength = 8
        r1 = [0, 1];                    value = 0;          bitLength = 8
        r2 = [0, 2];                    value = 0;          bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 + 0 = 0'
        -> # output
        registerDestination             = 0
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 0;          bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_integration02(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 2'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '1 + 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1;          bitLength = 8
        r1 = [0, 1];                    value = 1;          bitLength = 8
        r2 = [0, 2];                    value = 0;          bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 + 1 = 2'
        -> # output
        registerDestination             = 2
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 2;          bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_integration03(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0x0f + 0xf0 = 0xff'
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> '0x0f + 0xf0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f;          bitLength = 8
        r1 = [0, 1];                    value = 0xf0;          bitLength = 8
        r2 = [0, 2];                    value = 0x00;          bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0xf0
        ->
        '0x0f + 0xf0 = 0xff'
        -> # output
        registerDestination             = 0xff
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = 0xff;          bitLength = 8
        """

        r0 : int = 0x0f
        r1 : int = 0xf0
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0x00, bitLength = 8)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = None,
            registerOverflow                                                    = None
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out),
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_integration04(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['x + y = ?' for x in range(256) for y in range(256)]
        
        'r0 + r1 = r2' with bitLength '8, 8, 8' -> ['x + y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x;             bitLength = 8
        r1 = [0, 1];                    value = y;             bitLength = 8
        r2 = [0, 2];                    value = 0x00;          bitLength = 8
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = None
            registerOverflow            = None
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x + y = ?'
        -> # output
        registerDestination             = ?
        registerCarry                   = None
        registerOverflow                = None
        -> # written
        r2 = [0, 2];                    value = ?;             bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x + y) & (2**8 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opAddCarryOverflow(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1],
                    registerCarry                                               = None,
                    registerOverflow                                            = None
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out),
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAddCarryOverflow_integration05(self):
        """tests opAddCarryOverflow on 'r0 + r1 = r2, c = c0, o = o0' with bitLength '2, 2, 2, 1, 1' -> '3 + 2 = 1, c = 1, o = 1'

        'r0 + r1 = r2, c = c0, o = o0' with bitLength '2, 2, 2, 1, 1' -> '3 + 2 = 1, c = 1, o = 1'
        -> # create registers
        r0 = [0, 0];                    value = 3;             bitLength = 2
        r1 = [0, 1];                    value = 2;             bitLength = 2
        r2 = [0, 2];                    value = 0;             bitLength = 2
        c0 = ['c', 0];                  value = 0;             bitLength = 1
        o0 = ['o', 0];                  value = 0;             bitLength = 1
        ->
        opAddCarryOverflow(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
            registerCarry               = ['c', 0]
            registerOverflow            = ['o', 0]
        )
        -> # input
        registerA                       = 3
        registerB                       = 2
        ->
        '3 + 2 = 1, c = 1, o = 1'
        -> # output
        registerDestination             = 1
        registerCarry                   = 1
        registerOverflow                = 1
        -> # written
        r2 = [0, 2];                    value = 1;             bitLength = 2
        c0 = ['c', 0];                  value = 1;             bitLength = 1
        o0 = ['o', 0];                  value = 1;             bitLength = 1
        """

        r0 : int = 3
        r1 : int = 2
        r2_out : int = 1
        c0_out : int = 1
        o0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2)
        MMMU.createRegister(            'c', 0,                                 value = 0, bitLength = 1)
        MMMU.createRegister(            'o', 0,                                 value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAddCarryOverflow(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1],
            registerCarry                                                       = ['c', 0],
            registerOverflow                                                    = ['o', 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2),
            ('write',                   0, 2,                                   r2_out),
            ('getConfig',               'c', 0,                                 1),
            ('write',                   'c', 0,                                 c0_out),
            ('getConfig',               'o', 0,                                 1),
            ('write',                   'o', 0,                                 o0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out),                                # output
            ('c', 0,                    c0_out),                                # output
            ('o', 0,                    o0_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_Exception_funcReadNotFunction(self):
        """tests opMultiply raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opMultiply, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerB                                                   = self.registerNull
                )

    def test_opMultiply_Exception_funcWriteNotFunction(self):
        """tests opMultiply raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opMultiply,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opMultiply_Exception_funcGetConfigNotFunction(self):
        """tests opMultiply raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opMultiply,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opMultiply_Exception_registerDestinationNotRegister(self):
        """tests opMultiply raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opMultiply,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opMultiply_Exception_registerANotRegister(self):
        """tests opMultiply raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opMultiply,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerB                                                   = self.registerNull
                )

    def test_opMultiply_Exception_registerBNotRegister(self):
        """tests opMultiply raises an exception when registerB is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opMultiply,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = register # test with invalid register
                )

    def test_opMultiply_Exception_registerDestinationNotInMMMU(self):
        """tests opMultiply passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opMultiply,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull
        )

    def test_opMultiply_Exception_registerANotInMMMU(self):
        """tests opMultiply passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opMultiply,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerB                                                           = self.registerNull
        )

    def test_opMultiply_Exception_registerBNotInMMMU(self):
        """tests opMultiply passes through a raised MMMUAccessError exception when registerB is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opMultiply,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = register # test with invalid register
        )

    def test_opMultiply_singleRegister01(self):
        """tests opMultiply on 'r0 * r0 = r0' with bitLength '1, 1, 1' -> '0 * 0 = 0'
        
        'r0 * r0 = r0' with bitLength '1, 1, 1' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 0 
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        """
        
        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_singleRegister02(self):
        """tests opMultiply on 'r0 * r0 = r0' with bitLength '1, 1, 1' -> '1 * 1 = 1'
        
        'r0 * r0 = r0' with bitLength '1, 1, 1' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r0 = [0, 0];                    value = 1; bitLength = 1                |
        """
        
        r0 : int = 1
        r0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_multiRegister01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_multiRegister02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_multiRegister03(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_multiRegister04(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_zeroBitLength01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '0, 0, 0' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '0, 0, 0' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_zeroBitLength02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 8' -> '8 * 8 = 64'
        
        'r0 * r1 = r2' with bitLength '8, 8, 8' -> '8 * 8 = 64'
        -> # create registers
        r0 = [0, 0];                    value = 8; bitLength = 8
        r1 = [0, 1];                    value = 8; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 8
        registerB                       = 8
        ->
        '8 * 8 = 64'
        -> # output
        registerDestination             = 64
        -> # written
        r2 = [0, 2];                    value = 64; bitLength = 8
        """
        
        r0 : int = 8
        r1 : int = 8
        r2_out : int = 64

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_zeroBitLength03A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '0, 8, 8' -> '0 * 8 = 0'
        
        'r0 * r1 = r2' with bitLength '0, 8, 8' -> '0 * 8 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 8; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 8
        ->
        '0 * 8 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 8
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_zeroBitLength03B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 0, 8' -> '8 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '8, 0, 8' -> '8 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 8; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 8
        registerB                       = 0
        ->
        '8 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 8
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_zeroBitLength03C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 0' -> '8 * 8 = 0'
        
        'r0 * r1 = r2' with bitLength '8, 8, 0' -> '8 * 8 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 8; bitLength = 8
        r1 = [0, 1];                    value = 8; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 8
        registerB                       = 8
        ->
        '8 * 8 = 0'
        -> # output
        registerDestination             = 0                                     |
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0                |
        """
        
        r0 : int = 8
        r1 : int = 8
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength01A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 1, 1' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '8, 1, 1' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength01B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 8, 1' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 8, 1' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength01C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 8' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 8' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength02A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 1, 1' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '8, 1, 1' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength02B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 8, 1' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 8, 1' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength02C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 8' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 8' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength03A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 1, 1' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '8, 1, 1' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength03B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 8, 1' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 8, 1' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength03C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 8' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 8' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength04A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 1, 1' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '8, 1, 1' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 1; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength04B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 8, 1' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '1, 8, 1' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 1; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_variableBitLength04C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 8' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '1, 1, 8' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 1; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterIndex01(self):
        """tests opMultiply on 'r1024 * r1 = r2' with bitLength '8, 8, 8' -> '0x04 * 0x04 = 0x10'
        
        'r1024 * r1 = r2' with bitLength '8, 8, 8' -> '0x04 * 0x04 = 0x10'
        -> # create registers
        r1024 = [0, 1024];              value = 0x04; bitLength = 8             |
        r1    = [0, 1];                 value = 0x04; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]                             |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x04
        registerB                       = 0x04
        ->
        '0x04 * 0x04 = 0x10'
        -> # output
        registerDestination             = 0x10
        -> # written
        r2 = [0, 2];                    value = 0x10; bitLength = 8
        """
        
        r1024 : int = 0x04
        r1 : int = 0x04
        r2_out : int = 0x10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterIndex02(self):
        """tests opMultiply on 'r0 * r1024 = r2' with bitLength '8, 8, 8' -> '0x04 * 0x04 = 0x10'
        
        'r0 * r1024 = r2' with bitLength '8, 8, 8' -> '0x04 * 0x04 = 0x10'
        -> # create registers
        r0    = [0, 0];                 value = 0x04; bitLength = 8
        r1024 = [0, 1024];              value = 0x04; bitLength = 8             |
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1024]                             |
        )
        -> # input
        registerA                       = 0x04
        registerB                       = 0x04
        ->
        '0x04 * 0x04 = 0x10'
        -> # output
        registerDestination             = 0x10
        -> # written
        r2 = [0, 2];                    value = 0x10; bitLength = 8
        """
        
        r0 : int = 0x04
        r1024 : int = 0x04
        r2_out : int = 0x10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1024,                   r1024),                                 # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterIndex03(self):
        """tests opMultiply on 'r0 * r1 = r1024' with bitLength '8, 8, 8' -> '0x04 * 0x04 = 0x10'
        
        'r0 * r1 = r1024' with bitLength '8, 8, 8' -> '0x04 * 0x04 = 0x10'
        -> # create registers
        r0    = [0, 0];                 value = 0x04; bitLength = 8
        r1    = [0, 1];                 value = 0x04; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8                |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]                             |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x04
        registerB                       = 0x04
        ->
        '0x04 * 0x04 = 0x10'
        -> # output
        registerDestination             = 0x10
        -> # written
        r1024 = [0, 1024];              value = 0x10; bitLength = 8             |
        """
        
        r0 : int = 0x04
        r1 : int = 0x04
        r1024_out : int = 0x10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()
        
        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize01A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '0 * 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1024             |
        r1    = [0, 1];                 value = 0; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize01B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '0 * 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1
        r1    = [0, 1];                 value = 0; bitLength = 1024             |
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize01C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '0 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '0 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize02A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024             |
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize02B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024             |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize02C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '0 * 1 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '0 * 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 * 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize03A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024             |
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize03B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024             |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize03C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '1 * 0 = 0'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '1 * 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 * 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize04A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '1024, 1, 1' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024             |
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize04B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '1, 1024, 1' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024             |
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]                                |
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize04C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '1 * 1 = 1'
        
        'r0 * r1 = r2' with bitLength '1, 1, 1024' -> '1 * 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024             |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 * 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024             |
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize05A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1024, 8, 8' -> '0x80 * 0x80 = 0x00'
        
        'r0 * r1 = r2' with bitLength '1024, 8, 8' -> '0x80 * 0x80 = 0x00'
        -> # create registers
        r0 = [0, 0];                    value = 0x80; bitLength = 1024          |
        r1 = [0, 1];                    value = 0x80; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]                                |
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x80
        registerB                       = 0x80
        ->
        '0x80 * 0x80 = 0x00'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        """
        
        r0 : int = 0x80
        r1 : int = 0x80
        r2_out : int = 0x00

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize05B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 1024, 8' -> '0x80 * 0x80 = 0x00'
        
        'r0 * r1 = r2' with bitLength '8, 1024, 8' -> '0x80 * 0x80 = 0x00'
        -> # create registers
        r0 = [0, 0];                    value = 0x80; bitLength = 8
        r1 = [0, 1];                    value = 0x80; bitLength = 1024          |
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x80
        registerB                       = 0x80
        ->
        '0x80 * 0x80 = 0x00'
        -> # output
        registerDestination             = 0x00
        -> # written
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        """
        
        r0 : int = 0x80
        r1 : int = 0x80
        r2_out : int = 0x00

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize05C(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 1024' -> '0x80 * 0x80 = 0x4000'
        
        'r0 * r1 = r2' with bitLength '8, 8, 1024' -> '0x80 * 0x80 = 0x4000'
        -> # create registers
        r0 = [0, 0];                    value = 0x80; bitLength = 8
        r1 = [0, 1];                    value = 0x80; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 1024          |
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]                                |
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x80
        registerB                       = 0x80
        ->
        '0x80 * 0x80 = 0x4000'
        -> # output
        registerDestination             = 0x4000                                |
        -> # written
        r2 = [0, 2];                    value = 0x4000; bitLength = 1024        |
        """
        
        r0 : int = 0x80
        r1 : int = 0x80
        r2_out : int = 0x4000

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize06A(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '1024, 8, 8' -> '0xffff... * 0xff = 0x01'
        
        'r0 * r1 = r2' with bitLength '1024, 8, 8' -> '0xffff... * 0xff = 0x01'
        -> # create registers
        r0 = [0, 0];                    value = 0xffff...; bitLength = 1024
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xffff...
        registerB                       = 0xff
        ->
        '0xffff... * 0xff = 0x01'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 8
        """
        
        r0 : int = 2**1024 - 1
        r1 : int = 0xff
        r2_out : int = 0x01

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_largeRegisterSize06B(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**18) * 2**(2**18) = (2**(2**19))'
        
        'r0 * r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**18) * 2**(2**18) = (2**(2**19))'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**18); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**18); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 2**(2**18)
        registerB                       = 2**(2**18)
        ->
        '2**(2**18) * 2**(2**18) = (2**(2**19))'
        -> # output
        registerDestination             = 2**(2**19)
        -> # written
        r2 = [0, 2];                    value = 2**(2**19); bitLength = 2**20
        """
        
        r0 : int = 2**(2**18)
        r1 : int = 2**(2**18)
        r2_out : int = 2**(2**19)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opMultiply_zfighting01(self):
        """tests opMultiply on 'r0 * r0 = r0' with bitLength '8, 8, 8' -> '0x08 * 0x08 = 0x40'
        
        'r0 * r0 = r0' with bitLength '8, 8, 8' -> '0x08 * 0x08 = 0x40'
        -> # create registers
        r0 = [0, 0];                    value = 0x08; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 0x08
        registerB                       = 0x08
        ->
        '0x08 * 0x08 = 0x40'
        -> # output
        registerDestination             = 0x40
        -> # written
        r0 = [0, 0];                    value = 0x40; bitLength = 8
        """
        
        r0 : int = 0x08
        r0_out : int = 0x40

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out),                                # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPattern1BitSweep01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) * (1 << y) = 2**(x + y) & (2**8 - 1)' for x in range(8) for y in range(8)]
        
        'r0 * r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) * (1 << y) = 2**(x + y) & (2**8 - 1)' for x in range(8) for y in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = (1 << y); bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) * (1 << y) = 2**(x + y) & (2**8 - 1)'
        -> # output
        registerDestination             = 2**(x + y) & (2**8 - 1)
        -> # written
        r2 = [0, 2];                    value = 2**(x + y) & (2**8 - 1); bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = 2**(x + y) & (2**8 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opMultiply(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out),                                # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPattern1BitSweep02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) * (1 << y) = 2**(x + y) & (2**512 - 1)' for x in range(512) for y in range(512)]
        
        'r0 * r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) * (1 << y) = 2**(x + y) & (2**512 - 1)' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 512
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) * (1 << y) = 2**(x + y) & (2**512 - 1)'
        -> # output
        registerDestination             = 2**(x + y) & (2**512 - 1)
        -> # written
        r2 = [0, 2];                    value = 2**(x + y) & (2**512 - 1); bitLength = 512
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = 2**(x + y) & (2**512 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opMultiply(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out),                                # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPattern1BitSweep03(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) * (1 << y) = 2**(x + y)' for x in range(512) for y in range(512)]
        
        'r0 * r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) * (1 << y) = 2**(x + y)' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) * (1 << y) = 2**(x + y)'
        -> # output
        registerDestination             = 2**(x + y)
        -> # written
        r2 = [0, 2];                    value = 2**(x + y); bitLength = 2048
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = 2**(x + y)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opMultiply(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out),                                # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPatternCheckerboardConstructive01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... * 0b1010... = ?'
        
        'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... * 0b1010... = ?'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... * 0b1010... = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = (r0 * r1) & (2**2048 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPatternCheckerboardConstructive02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... * 0b0101... = ?'
        
        'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... * 0b0101... = ?'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b0101...
        ->
        '0b0101... * 0b0101... = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = (r0 * r1) & (2**2048 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPatternCheckerboardDestructive01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... * 0b0101... = ?'
        
        'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... * 0b0101... = ?'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... * 0b0101... = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = (r0 * r1) & (2**2048 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_inputBitPatternCheckerboardDestructive02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... * 0b1010... = ?'
        
        'r0 * r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... * 0b1010... = ?'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... * 0b1010... = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = (r0 * r1) & (2**2048 - 1)

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_bitpattern8bit4Overlap(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 16' -> '0xfc * 0x3f = 0x3e04'
        
        'r0 * r1 = r2' with bitLength '8, 8, 16' -> '0xfc * 0x3f = 0x3e04'
        -> # create registers
        r0 = [0, 0];                    value = 0xfc; bitLength = 8
        r1 = [0, 1];                    value = 0x3f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 16
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc * 0x3f = 0x3e04'
        -> # output
        registerDestination             = 0x3e04
        -> # written
        r2 = [0, 2];                    value = 0x3e04; bitLength = 16
        """
        
        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0x3e04

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 16)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   16),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_8bitFullCombination01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 8' -> ['x * y = ?' for x in range(256) for y in range(256)]
        
        'r0 * r1 = r2' with bitLength '8, 8, 8' -> ['x * y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x * y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x * y) & (2**8 - 1)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opMultiply(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out),                                # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
    
    def test_opMultiply_8bitFullCombination02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 16' -> ['x * y = x * y' for x in range(256) for y in range(256)]
        
        'r0 * r1 = r2' with bitLength '8, 8, 16' -> ['x * y = x * y' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 16
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x * y = x * y'
        -> # output
        registerDestination             = x * y
        -> # written
        r2 = [0, 2];                    value = x * y; bitLength = 16
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x * y)

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 16)

                returnValue : None = self.ISA.opMultiply(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   16),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out),                                # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_integration01(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 8' -> '0x08 * 0x08 = 0x40'
        
        'r0 * r1 = r2' with bitLength '8, 8, 8' -> '0x08 * 0x08 = 0x40'
        -> # create registers
        r0 = [0, 0];                    value = 0x08; bitLength = 8
        r1 = [0, 1];                    value = 0x08; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x08
        registerB                       = 0x08
        ->
        '0x08 * 0x08 = 0x40'
        -> # output
        registerDestination             = 0x40
        -> # written
        r2 = [0, 2];                    value = 0x40; bitLength = 8
        """
        
        r0 : int = 0x08
        r1 : int = 0x08
        r2_out : int = 0x40

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_integration02(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 16' -> '0x80 * 0x80 = 2**7 * 2**7 = 2**14'
        
        'r0 * r1 = r2' with bitLength '8, 8, 16' -> '0x80 * 0x80 = 2**7 * 2**7 = 2**14'
        -> # create registers
        r0 = [0, 0];                    value = 0x80; bitLength = 8
        r1 = [0, 1];                    value = 0x80; bitLength = 8
        r2 = [0, 2];                    value = 0x00; bitLength = 16
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x80
        registerB                       = 0x80
        ->
        '0x80 * 0x80 = 2**7 * 2**7 = 2**14'
        -> # output
        registerDestination             = 2**14
        -> # written
        r2 = [0, 2];                    value = 2**14; bitLength = 16
        """
        
        r0 : int = 0x80
        r1 : int = 0x80
        r2_out : int = 2**14

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 16)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   16),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_integration03(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '16, 16, 8' -> '0x80 * 0x80 = 2**7 * 2**7 = 0'
        
        'r0 * r1 = r2' with bitLength '16, 16, 8' -> '0x80 * 0x80 = 2**7 * 2**7 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x80; bitLength = 16
        r1 = [0, 1];                    value = 0x80; bitLength = 16
        r2 = [0, 2];                    value = 0x00; bitLength = 8
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x80
        registerB                       = 0x80
        ->
        '0x80 * 0x80 = 2**7 * 2**7 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0x80
        r1 : int = 0x80
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 16)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 16)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()
        
        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opMultiply_integration04(self):
        """tests opMultiply on 'r0 * r1 = r2' with bitLength '8, 8, 16' -> '0xff * 0xff = 0xfe01'
        
        'r0 * r1 = r2' with bitLength '8, 8, 16' -> '0xff * 0xff = 0xfe01'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0xfe01; bitLength = 16
        ->
        opMultiply(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff * 0xff = 0xfe01'
        -> # output
        registerDestination             = 0xfe01
        -> # written
        r2 = [0, 2];                    value = 0xfe01; bitLength = 16
        """
        
        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0xfe01

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 16)

        returnValue : None = self.ISA.opMultiply(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   16),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out),                                # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    #TODO testing on opMultiplySignedMultiElement

    def test_opTwosCompliment_Exception_funcReadNotFunction(self):
        """tests opTwosCompliment raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opTwosCompliment, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull
                )

    def test_opTwosCompliment_Exception_funcWriteNotFunction(self):
        """tests opTwosCompliment raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opTwosCompliment,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull
                )

    def test_opTwosCompliment_Exception_funcGetConfigNotFunction(self):
        """tests opTwosCompliment raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opTwosCompliment,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull
                )

    def test_opTwosCompliment_Exception_registerDestinationNotRegister(self):
        """tests opTwosCompliment raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opTwosCompliment,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull
                )

    def test_opTwosCompliment_Exception_registerANotRegister(self):
        """tests opTwosCompliment raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opTwosCompliment,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register # test with invalid register
                )

    def test_opTwosCompliment_Exception_registerDestinationNotInMMMU(self):
        """tests opTwosCompliment passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opTwosCompliment,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull
        )

    def test_opTwosCompliment_Exception_registerANotInMMMU(self):
        """tests opTwosCompliment passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opTwosCompliment,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register # test with invalid register
        )

    def test_opTwosCompliment_singleRegister01(self):
        """tests opTwosCompliment on 'Twos r0 = r0' with bitLength '1, 1' -> 'Twos 0 = 0'
        
        'Twos r0 = r0' with bitLength '1, 1' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]                                |
            registerA                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 0 
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1                |
        """
        
        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_singleRegister02(self):
        """tests opTwosCompliment on 'Twos r0 = r0' with bitLength '1, 1' -> 'Twos 1 = 1'
        
        'Twos r0 = r0' with bitLength '1, 1' -> 'Twos 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r0 = [0, 0];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_multiRegister01(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 1' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '1, 1' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_multiRegister02(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 1' -> 'Twos 1 = 1'
        
        'Twos r0 = r1' with bitLength '1, 1' -> 'Twos 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_zeroBitLength01(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '0, 0' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '0, 0' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]                                |
            registerA                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   0),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_zeroBitLength02(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 1 = 0xff'
        
        'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 1 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 1 = 0xff'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """
        
        r0 : int = 1
        r1_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_zeroBitLength03A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '0, 8' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '0, 8' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0                |
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_zeroBitLength03B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 0' -> 'Twos 1 = 0'
        
        'Twos r0 = r1' with bitLength '8, 0' -> 'Twos 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]                                |
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 0                |
        """
        
        r0 : int = 1
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   0),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_variableBitLength01A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 1' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '8, 1' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_variableBitLength01B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 8' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '1, 8' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_variableBitLength02A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 1' -> 'Twos 0xff = 1'
        
        'Twos r0 = r1' with bitLength '8, 1' -> 'Twos 0xff = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xff
        ->
        'Twos 0xff = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """
        
        r0 : int = 0xff
        r1_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_variableBitLength02B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 8' -> 'Twos 1 = 0xff'
        
        'Twos r0 = r1' with bitLength '1, 8' -> 'Twos 1 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """
        
        r0 : int = 1
        r1_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_variableBitLength03A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 16' -> 'Twos 0xf0 = 0xff10'
        
        'Twos r0 = r1' with bitLength '8, 16' -> 'Twos 0xf0 = 0xff10'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 16
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xf0
        ->
        'Twos 0xf0 = 0xff10'
        -> # output
        registerDestination             = 0xff10
        -> # written
        r1 = [0, 1];                    value = 0xff10; bitLength = 16
        """
        
        r0 : int = 0xf0
        r1_out : int = 0xff10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 16)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   16),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_variableBitLength03B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '16, 8' -> 'Twos 0xf0f0 = 0x10'
        
        'Twos r0 = r1' with bitLength '16, 8' -> 'Twos 0xf0f0 = 0x10'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0f0; bitLength = 16
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xf0f0
        ->
        'Twos 0xf0f0 = 0x10'
        -> # output
        registerDestination             = 0x10
        -> # written
        r1 = [0, 1];                    value = 0x10; bitLength = 8
        """
        
        r0 : int = 0xf0f0
        r1_out : int = 0x10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 16)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterIndex01(self):
        """tests opTwosCompliment on 'Twos r1024 = r1' with bitLength '8, 8' -> 'Twos 0x0f = 0xf1'
        
        'Twos r1024 = r1' with bitLength '8, 8' -> 'Twos 0x0f = 0xf0'
        -> # create registers
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 1024]
        )
        -> # input
        registerA                       = 0x0f
        ->
        'Twos 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf1
        -> # written
        r1 = [0, 1];                    value = 0xf1; bitLength = 8
        """
        
        r1024 : int = 0x0f
        r1_out : int = 0xf1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterIndex02(self):
        """tests opTwosCompliment on 'Twos r0 = r1024' with bitLength '8, 8' -> 'Twos 0x0f = 0xf1'
        
        'Twos r0 = r1024' with bitLength '8, 8' -> 'Twos 0x0f = 0xf1'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8                |
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]                             |
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x0f
        ->
        'Twos 0x0f = 0xf1'
        -> # output
        registerDestination             = 0xf1
        -> # written
        r1 = [0, 1024];                 value = 0xf1; bitLength = 8
        """
        
        r0 : int = 0x0f
        r1024_out : int = 0xf1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterSize01A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1024, 1' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '1024, 1' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024             |
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterSize01B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 1024' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '1, 1024' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024             |
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]                                |
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1024             |
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1024),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterSize02A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1024, 1' -> 'Twos 1 = 1'
        
        'Twos r0 = r1' with bitLength '1024, 1' -> 'Twos 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024             |
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]                                |
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterSize02B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 1024' -> 'Twos 1 = 0xffff...ff'
        
        'Twos r0 = r1' with bitLength '1, 1024' -> 'Twos 1 = 0xffff...ff'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024             |
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]                                |
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 0xffff...ff'
        -> # output
        registerDestination             = 2**1024 - 1
        -> # written
        r1 = [0, 1];                    value = 2**1024 - 1; bitLength = 1024
        """
        
        r0 : int = 1
        r1_out : int = 2**1024 - 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1024),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_largeRegisterSize03A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '2**20, 1' -> 'Twos 0xffff... = 1'
        
        'Twos r0 = r1' with bitLength '2**20, 1' -> 'Twos 0xffff... = 1'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20) - 1; bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 2**(2**20) - 1
        ->
        'Twos 0xffff... = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """
        
        r0 : int = 2**2**20 - 1
        r1_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opTwosCompliment_largeRegisterSize03B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '1, 2**20' -> 'Twos 1 = 0xffff...'
        
        'Twos r0 = r1' with bitLength '1, 2**20' -> 'Twos 1 = 0xffff...'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 0xffff...'
        -> # output
        registerDestination             = 2**2**20 - 1
        -> # written
        r1 = [0, 1];                    value = 2**2**20 - 1; bitLength = 2**20
        """
        
        r0 : int = 1
        r1_out : int = 2**2**20 - 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opTwosCompliment_largeRegisterSize04A(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '2**20, 2**20' -> 'Twos 0xffff... = 1'
        
        'Twos r0 = r1' with bitLength '2**20, 2**20' -> 'Twos 0xffff... = 1'
        -> # create registers
        r0 = [0, 0];                    value = 2**2**20 - 1; bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 2**2**20 - 1
        ->
        'Twos 0xffff... = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 2**20
        """
        
        r0 : int = 2**2**20 - 1
        r1_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opTwosCompliment_largeRegisterSize04B(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '2**20, 2**20' -> 'Twos 1 = 0xffff...'
        
        'Twos r0 = r1' with bitLength '2**20, 2**20' -> 'Twos 1 = 0xffff...'
        -> # create registers
        r0 = [0, 0];                    value = 2**2**20 - 1; bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 0xffff...'
        -> # output
        registerDestination             = 2**2**20 - 1
        -> # written
        r1 = [0, 1];                    value = 2**2**20 - 1; bitLength = 2**20
        """
        
        r0 : int = 1
        r1_out : int = 2**2**20 - 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opTwosCompliment_inputBitPattern1BitSweep01(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> ['Twos (1 << x) = ?' for x in range(8)]
        
        'Twos r0 = r1' with bitLength '8, 8' -> ['Twos (1 << x) = ?' for x in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = (1 << x)
        ->
        'Twos (1 << x) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 8
        """
        
        for x in range(8):
            with self.subTest(x=x):
                r0 : int = 1 << x
                
                bitArray : list[int] = [r0 >> i & 1 for i in range(8)] # Converts to bit array, index 0 is least significant bit
                bitArray : list[int] = [not i for i in bitArray] # performs the bitwise NOT operation
                number : int = sum([bit << i for i, bit in enumerate(bitArray)]) # converts back to integer
                r1_out : int = (number + 1) & (2**8 - 1) # add one to be twos compliment, and trunk

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opTwosCompliment(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   8),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')


    def test_opTwosCompliment_inputBitPattern1BitSweep02(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '512, 512' -> ['Twos (1 << x) = ?' for x in range(512)]
        
        'Twos r0 = r1' with bitLength '512, 512' -> ['Twos (1 << x) = ?' for x in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = 0; bitLength = 512
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = (1 << x)
        ->
        'Twos (1 << x) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 512
        """
        
        for x in range(512):
            with self.subTest(x=x):
                r0 : int = 1 << x

                bitArray : list[int] = [r0 >> i & 1 for i in range(512)] # Converts to bit array, index 0 is least significant bit
                bitArray : list[int] = [not i for i in bitArray] # performs the bitwise NOT operation
                number : int = sum([bit << i for i, bit in enumerate(bitArray)]) # converts back to integer
                r1_out : int = (number + 1) & (2**512 - 1) # add one to be twos compliment, and trunk

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opTwosCompliment(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   512),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_inputBitPattern1BitSweep03(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '512, 2048' -> ['Twos (1 << x) = ?' for x in range(512)]
        
        'Twos r0 = r1' with bitLength '512, 2048' -> ['Twos (1 << x) = ?' for x in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = 0; bitLength = 2048
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = (1 << x)
        ->
        'Twos (1 << x) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 2048
        """
        
        for x in range(512):
            with self.subTest(x=x):
                r0 : int = 1 << x

                bitArray : list[int] = [r0 >> i & 1 for i in range(2048)] # Converts to bit array, index 0 is least significant bit
                bitArray : list[int] = [not i for i in bitArray] # performs the bitwise NOT operation
                number : int = sum([bit << i for i, bit in enumerate(bitArray)]) # converts back to integer
                r1_out : int = (number + 1) & (2**2048 - 1) # add one to be twos compliment, and trunk

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opTwosCompliment(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   2048),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_inputBitPatternCheckerboard01(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '2048, 2048' -> 'Twos 0b1010... = 0b0101... + 1'
        
        'Twos r0 = r1' with bitLength '2048, 2048' -> 'Twos 0b1010... = 0b0101... + 1'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0; bitLength = 2048
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0b1010...
        ->
        'Twos 0b1010... = 0b0101... + 1'
        -> # output
        registerDestination             = 0b0101... + 1
        -> # written
        r1 = [0, 1];                    value = 0b0101... + 1; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1_out : int = sum([2**i for i in range(2048) if i % 2 == 0]) + 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2048),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_inputBitPatternCheckerboard02(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '2048, 2048' -> 'Twos 0b0101... = 0b1010... + 1'
        
        'Twos r0 = r1' with bitLength '2048, 2048' -> 'Twos 0b0101... = 0b1010... + 1'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0; bitLength = 2048
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0b0101...
        ->
        'Twos 0b0101... = 0b1010... + 1'
        -> # output
        registerDestination             = 0b1010... + 1
        -> # written
        r1 = [0, 1];                    value = 0b1010... + 1; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1_out : int = sum([2**i for i in range(2048) if i % 2 == 1]) + 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2048),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_8bitFullCombination(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> ['Twos x = ?' for x in range(256)]
        
        'Twos r0 = r1' with bitLength '8, 8' -> ['Twos x = ?' for x in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = x
        ->
        'Twos x = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 8
        """
        
        for x in range(256):
            with self.subTest(x=x):
                r0 : int = x

                bitArray : list[int] = [r0 >> i & 1 for i in range(8)] # Converts to bit array, index 0 is least significant bit
                bitArray : list[int] = [not i for i in bitArray] # performs the bitwise NOT operation
                number : int = sum([bit << i for i, bit in enumerate(bitArray)]) # converts back to integer
                r1_out : int = (number + 1) & (2**8 - 1) # add one to be twos compliment, and trunk

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opTwosCompliment(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   8),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration01(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 0 = 0'
        
        'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        'Twos 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration02(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 1 = 0xff'
        
        'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 1 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        'Twos 1 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """
        
        r0 : int = 1
        r1_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration03(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 0xf0 = 0x10'
        
        'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 0xf0 = 0x10'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xf0
        ->
        'Twos 0xf0 = 0x10'
        -> # output
        registerDestination             = 0x10
        -> # written
        r1 = [0, 1];                    value = 0x10; bitLength = 8
        """
        
        r0 : int = 0xf0
        r1_out : int = 0x10

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration04(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 0x02 = 0xfe'
        
        'Twos r0 = r1' with bitLength '8, 8' -> 'Twos 0x02 = 0xfe'
        -> # create registers
        r0 = [0, 0];                    value = 0x02; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x02
        ->
        'Twos 0x02 = 0xfe'
        -> # output
        registerDestination             = 0xfe
        -> # written
        r1 = [0, 1];                    value = 0xfe; bitLength = 8
        """
        
        r0 : int = 0x02
        r1_out : int = 0xfe

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration05(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '8, 4' -> 'Twos 0xfe = 0x2'
        
        'Twos r0 = r1' with bitLength '8, 4' -> 'Twos 0xfe = 0x2'
        -> # create registers
        r0 = [0, 0];                    value = 0xfe; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 4
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xfe
        ->
        'Twos 0xfe = 0x2'
        -> # output
        registerDestination             = 0x2
        -> # written
        r1 = [0, 1];                    value = 0x2; bitLength = 4
        """
        
        r0 : int = 0xfe
        r1_out : int = 0x2

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 4)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   4),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration06(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '4, 8' -> 'Twos 0x1 = 0xff'
        
        'Twos r0 = r1' with bitLength '4, 8' -> 'Twos 0x1 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0x1; bitLength = 4
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x1
        ->
        'Twos 0x1 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """
        
        r0 : int = 0x1
        r1_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 4)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opTwosCompliment_integration07(self):
        """tests opTwosCompliment on 'Twos r0 = r1' with bitLength '4, 8' -> 'Twos 0x4 = 0xfc'
        
        'Twos r0 = r1' with bitLength '4, 8' -> 'Twos 0x4 = 0xfc'
        -> # create registers
        r0 = [0, 0];                    value = 0x4; bitLength = 4
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opTwosCompliment(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x4
        ->
        'Twos 0x4 = 0xfc'
        -> # output
        registerDestination             = 0xfc
        -> # written
        r1 = [0, 1];                    value = 0xfc; bitLength = 8
        """
        
        r0 : int = 0x4
        r1_out : int = 0xfc

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 4)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opTwosCompliment(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_Exception_funcReadNotFunction(self):
        """tests opAND raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAND, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerB                                                   = self.registerNull
                )

    def test_opAND_Exception_funcWriteNotFunction(self):
        """tests opAND raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAND,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opAND_Exception_funcGetConfigNotFunction(self):
        """tests opAND raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opAND,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opAND_Exception_registerDestinationNotRegister(self):
        """tests opAND raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAND,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opAND_Exception_registerANotRegister(self):
        """tests opAND raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAND,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerB                                                   = self.registerNull
                )

    def test_opAND_Exception_registerBNotRegister(self):
        """tests opAND raises an exception when registerB is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opAND,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = register # test with invalid register
                )

    def test_opAND_Exception_registerDestinationNotInMMMU(self):
        """tests opAND passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAND,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull
        )

    def test_opAND_Exception_registerANotInMMMU(self):
        """tests opAND passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAND,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerB                                                           = self.registerNull
        )

    def test_opAND_Exception_registerBNotInMMMU(self):
        """tests opAND passes through a raised MMMUAccessError exception when registerB is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opAND,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = register # test with invalid register
        )

    def test_opAND_singleRegister01(self):
        """tests opAND on 'r0 & r0 = r0' with bitLength '1, 1, 1' -> '0 & 0 = 0'
        
        'r0 & r0 = r0' with bitLength '1, 1, 1' -> '0 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 0 
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_singleRegister02(self):
        """tests opAND on 'r0 & r0 = r0' with bitLength '1, 1, 1' -> '1 & 1 = 1'
        
        'r0 & r0 = r0' with bitLength '1, 1, 1' -> '1 & 1 = 1'
        -> # create registers
        r0 = [1, 1];                    value = 1; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r0 = [1, 1];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r0_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_multiRegister01(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1' -> '0 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_multiRegister02(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1' -> '0 & 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_multiRegister03(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1' -> '1 & 0 = 0'

        'r0 & r1 = r2' with bitLength '1, 1, 1' -> '1 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_multiRegister04(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1' -> '1 & 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_zeroBitLength01(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '0, 0, 0' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '0, 0, 0' -> '0 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_zeroBitLength02(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0xff & 0xff = 0xff'
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0xff & 0xff = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff & 0xff = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_zeroBitLength03A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '0, 8, 8' -> '0 & 0xff = 0'
        
        'r0 & r1 = r2' with bitLength '0, 8, 8' -> '0 & 0xff = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0xff
        ->
        '0 & 0xff = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 0xff
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_zeroBitLength03B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 0, 8' -> '0xff & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '8, 0, 8' -> '0xff & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0
        ->
        '0xff & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_zeroBitLength03C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 0' -> '0xff & 0xff = 0'
        
        'r0 & r1 = r2' with bitLength '8, 8, 0' -> '0xff & 0xff = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff & 0xff = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """
        
        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 0)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength01A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 1, 1' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '8, 1, 1' -> '0 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength01B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 8, 1' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 8, 1' -> '0 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength01C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 8' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 8' -> '0 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength02A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 1, 1' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '8, 1, 1' -> '0 & 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength02B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 8, 1' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 8, 1' -> '0 & 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength02C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 8' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 8' -> '0 & 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength03A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 1, 1' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '8, 1, 1' -> '1 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength03B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 8, 1' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 8, 1' -> '1 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength03C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 8' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 8' -> '1 & 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength04A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 1, 1' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '8, 1, 1' -> '1 & 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength04B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 8, 1' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '1, 8, 1' -> '1 & 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_variableBitLength04C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 8' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '1, 1, 8' -> '1 & 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterIndex01(self):
        """tests opAND on 'r1024 & r1 = r2' with bitLength '8, 8, 8' -> '0xff & 0x0f = 0x0f'
        
        'r1024 & r1 = r2' with bitLength '8, 8, 8' -> '0xff & 0x0f = 0x0f'
        -> # create registers
        r1024 = [0, 1024];              value = 0xff; bitLength = 8
        r1    = [0, 1];                 value = 0x0f; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff & 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r2 = [0, 2];                    value = 0x0f; bitLength = 8
        """
        
        r1024 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0x0f

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterIndex02(self):
        """tests opAND on 'r0 & r1024 = r2' with bitLength '8, 8, 8' -> '0xff & 0x0f = 0x0f'
        
        'r0 & r1024 = r2' with bitLength '8, 8, 8' -> '0xff & 0x0f = 0x0f'
        -> # create registers
        r0    = [0, 0];                 value = 0xff; bitLength = 8
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1024]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff & 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r2 = [0, 2];                    value = 0x0f; bitLength = 8
        """
        
        r0 : int = 0xff
        r1024 : int = 0x0f
        r2_out : int = 0x0f

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1024,                   r1024),                                 # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterIndex03(self):
        """tests opAND on 'r0 & r1 = r1024' with bitLength '8, 8, 8' -> '0xff & 0x0f = 0x0f'
        
        'r0 & r1 = r1024' with bitLength '8, 8, 8' -> '0xff & 0x0f = 0x0f'
        -> # create registers
        r0    = [0, 0];                 value = 0xff; bitLength = 8
        r1    = [0, 1];                 value = 0x0f; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff & 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0x0f
        r1024_out : int = 0x0f

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()
        
        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize01A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '0 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1024
        r1    = [0, 1];                 value = 0; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize01B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '0 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1
        r1    = [0, 1];                 value = 0; bitLength = 1024
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize01C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '0 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1
        r1    = [0, 1];                 value = 0; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1024
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1024)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize02A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '0 & 1 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1024
        r1    = [0, 1];                 value = 1; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize02B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '0 & 1 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1
        r1    = [0, 1];                 value = 1; bitLength = 1024
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize02C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '0 & 1 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1
        r1    = [0, 1];                 value = 1; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1024
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1024)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize03A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '1 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1024
        r1    = [0, 1];                 value = 0; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize02C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '0 & 1 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '0 & 1 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 1
        r1    = [0, 1];                 value = 1; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1024
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 & 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """
        
        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1024)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize03A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '1 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1024
        r1    = [0, 1];                 value = 0; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize03B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '1 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1
        r1    = [0, 1];                 value = 0; bitLength = 1024
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize03C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '1 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '1 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1
        r1    = [0, 1];                 value = 0; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1024
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """
        
        r0 : int = 1
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1024)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize04A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '1024, 1, 1' -> '1 & 1 = 1'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1024
        r1    = [0, 1];                 value = 1; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize04B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '1, 1024, 1' -> '1 & 1 = 1'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1
        r1    = [0, 1];                 value = 1; bitLength = 1024
        r2    = [0, 2];                 value = 0; bitLength = 1
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize04C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '1, 1, 1024' -> '1 & 1 = 1'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 1
        r1    = [0, 1];                 value = 1; bitLength = 1
        r2    = [0, 2];                 value = 0; bitLength = 1024
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1024)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize05A(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '1024, 8, 8' -> '0xff & 0x0f = 0x0f'
        
        'r0 & r1 = r2' with bitLength '1024, 8, 8' -> '0xff & 0x0f = 0x0f'
        -> # create registers
        r0    = [0, 0];                 value = 0xff; bitLength = 1024
        r1    = [0, 1];                 value = 0x0f; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff & 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r2 = [0, 2];                    value = 0x0f; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0x0f

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize05B(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 1024, 8' -> '0xff & 0x0f = 0x0f'
        
        'r0 & r1 = r2' with bitLength '8, 1024, 8' -> '0xff & 0x0f = 0x0f'
        -> # create registers
        r0    = [0, 0];                 value = 0xff; bitLength = 8
        r1    = [0, 1];                 value = 0x0f; bitLength = 1024
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff & 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r2 = [0, 2];                    value = 0x0f; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0x0f

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_largeRegisterSize05C(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 1024' -> '0xff & 0x0f = 0x0f'
        
        'r0 & r1 = r2' with bitLength '8, 8, 1024' -> '0xff & 0x0f = 0x0f'
        -> # create registers
        r0    = [0, 0];                 value = 0xff; bitLength = 8
        r1    = [0, 1];                 value = 0x0f; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 1024
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff & 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r2 = [0, 2];                    value = 0x0f; bitLength = 1024
        """
        
        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0x0f

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 1024)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround


    def test_opAND_inputBitPattern1BitSweep01(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) & (1 << y) = ?' for x in range(8) for y in range(8)]
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) & (1 << y) = ?' for x in range(8) for y in range(8)]
        -> # create registers
        r0    = [0, 0];                 value = (1 << x); bitLength = 8
        r1    = [0, 1];                 value = (1 << y); bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) & (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = r0 & r1

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = r2_out, bitLength = 8)

                returnValue : None = self.ISA.opAND(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_inputBitPattern1BitSweep02(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) & (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 & r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) & (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0    = [0, 0];                 value = (1 << x); bitLength = 512
        r1    = [0, 1];                 value = (1 << y); bitLength = 512
        r2    = [0, 2];                 value = 0; bitLength = 512
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) & (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 512
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = r0 & r1

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = r2_out, bitLength = 512)

                returnValue : None = self.ISA.opAND(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_inputBitPattern1BitSweep03(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) & (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 & r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) & (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0    = [0, 0];                 value = (1 << x); bitLength = 512
        r1    = [0, 1];                 value = (1 << y); bitLength = 512
        r2    = [0, 2];                 value = 0; bitLength = 2048
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) & (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """
        
        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = 1 << x
                r1 : int = 1 << y
                r2_out : int = r0 & r1

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = r2_out, bitLength = 2048)

                returnValue : None = self.ISA.opAND(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_inputBitPatternCheckerboardConstructive01(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... & 0b1010... = 0b1010...'
        
        'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... & 0b1010... = 0b1010...'
        -> # create registers
        r0    = [0, 0];                 value = 0b1010...; bitLength = 2048
        r1    = [0, 1];                 value = 0b1010...; bitLength = 2048
        r2    = [0, 2];                 value = 0; bitLength = 2048
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... & 0b1010... = 0b1010...'
        -> # output
        registerDestination             = 0b1010...
        -> # written
        r2 = [0, 2];                    value = 0b1010...; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = sum([2**i for i in range(2048) if i % 2 == 1])

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 2048)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_inputBitPatternCheckerboardConstructive02(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... & 0b0101... = 0b0101...'
        
        'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... & 0b0101... = 0b0101...'
        -> # create registers
        r0    = [0, 0];                 value = 0b0101...; bitLength = 2048
        r1    = [0, 1];                 value = 0b0101...; bitLength = 2048
        r2    = [0, 2];                 value = 0; bitLength = 2048
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b0101...
        ->
        '0b0101... & 0b0101... = 0b0101...'
        -> # output
        registerDestination             = 0b0101...
        -> # written
        r2 = [0, 2];                    value = 0b0101...; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = sum([2**i for i in range(2048) if i % 2 == 0])

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 2048)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_inputBitPatternCheckerboardDestructive01(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... & 0b0101... = 0b0000...'
        
        'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... & 0b0101... = 0b0000...'
        -> # create registers
        r0    = [0, 0];                 value = 0b1010...; bitLength = 2048
        r1    = [0, 1];                 value = 0b0101...; bitLength = 2048
        r2    = [0, 2];                 value = 0; bitLength = 2048
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... & 0b0101... = 0b0000...'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 2048)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_inputBitPatternCheckerboardDestructive02(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... & 0b1010... = 0b0000...'
        
        'r0 & r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... & 0b1010... = 0b0000...'
        -> # create registers
        r0    = [0, 0];                 value = 0b0101...; bitLength = 2048
        r1    = [0, 1];                 value = 0b1010...; bitLength = 2048
        r2    = [0, 2];                 value = 0; bitLength = 2048
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... & 0b1010... = 0b0000...'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """
        
        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 2048)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_bitpattern8bit4Overlap(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0xfc & 0x3f = 0x3c'
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0xfc & 0x3f = 0x3c'
        -> # create registers
        r0    = [0, 0];                 value = 0xfc; bitLength = 8
        r1    = [0, 1];                 value = 0x3f; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc & 0x3f = 0x3c'
        -> # output
        registerDestination             = 0x3c
        -> # written
        r2 = [0, 2];                    value = 0x3c; bitLength = 8
        """
        
        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0x3c

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_8bitFullCombination(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> ['x & y = x & y' for x in range(256) for y in range(256)]
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> ['x & y = x & y' for x in range(256) for y in range(256)]
        -> # create registers
        r0    = [0, 0];                 value = x; bitLength = 8
        r1    = [0, 1];                 value = y; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x & y = x & y'
        -> # output
        registerDestination             = x & y
        -> # written
        r2 = [0, 2];                    value = x & y; bitLength = 8
        """
        
        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = x & y

                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = r2_out, bitLength = 8)

                returnValue : None = self.ISA.opAND(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_integration01(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0 & 0 = 0'
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0 & 0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0; bitLength = 8
        r1    = [0, 1];                 value = 0; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 & 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_integration02(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> '1 & 1 = 1'
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> '1 & 1 = 1'
        -> # create registers
        r0    = [0, 0];                 value = 1; bitLength = 8
        r1    = [0, 1];                 value = 1; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 & 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """
        
        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_integration03(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0x0f & 0xf0 = 0'
        
        'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0x0f & 0xf0 = 0'
        -> # create registers
        r0    = [0, 0];                 value = 0x0f; bitLength = 8
        r1    = [0, 1];                 value = 0xf0; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0xf0
        ->
        '0x0f & 0xf0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """
        
        r0 : int = 0x0f
        r1 : int = 0xf0
        r2_out : int = 0

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opAND_integration04(self):
        """tests opAND on 'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0x03 & 0x02 = 0x02'

        'r0 & r1 = r2' with bitLength '8, 8, 8' -> '0x03 & 0x02 = 0x02'
        -> # create registers
        r0    = [0, 0];                 value = 0x03; bitLength = 8
        r1    = [0, 1];                 value = 0x02; bitLength = 8
        r2    = [0, 2];                 value = 0; bitLength = 8
        ->
        opAND(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x03
        registerB                       = 0x02
        ->
        '0x03 & 0x02 = 0x02'
        -> # output
        registerDestination             = 0x02
        -> # written
        r2 = [0, 2];                    value = 0x02; bitLength = 8
        """
        
        r0 : int = 0x03
        r1 : int = 0x02
        r2_out : int = 0x02

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = r2_out, bitLength = 8)

        returnValue : None = self.ISA.opAND(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_Exception_funcReadNotFunction(self):
        """tests opOR raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opOR, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerB                                                   = self.registerNull
                )

    def test_opOR_Exception_funcWriteNotFunction(self):
        """tests opOR raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opOR_Exception_funcGetConfigNotFunction(self):
        """tests opOR raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opOR_Exception_registerDestinationNotRegister(self):
        """tests opOR raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opOR_Exception_registerANotRegister(self):
        """tests opOR raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerB                                                   = self.registerNull
                )

    def test_opOR_Exception_registerBNotRegister(self):
        """tests opOR raises an exception when registerB is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = register # test with invalid register
                )

    def test_opOR_Exception_registerDestinationNotInMMMU(self):
        """tests opOR passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opOR,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull
        )

    def test_opOR_Exception_registerANotInMMMU(self):
        """tests opOR passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opOR,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerB                                                           = self.registerNull
        )

    def test_opOR_Exception_registerBNotInMMMU(self):
        """tests opOR passes through a raised MMMUAccessError exception when registerB is not in the MMMU"""
        
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opOR,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = register # test with invalid register
        )

    def test_opOR_singleRegister01(self):
        """tests opOR on 'r0 | r0 = r0' with bitLength '1, 1, 1' -> '0 | 0 = 0'
        
        'r0 | r0 = r0' with bitLength '1, 1, 1' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 0 
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_singleRegister02(self):
        """tests opOR on 'r0 | r0 = r0' with bitLength '1, 1, 1' -> '1 | 1 = 1'
        
        'r0 | r0 = r0' with bitLength '1, 1, 1' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r0 = [0, 0];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_multiRegister01(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_multiRegister02(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1' -> '0 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_multiRegister03(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1' -> '1 | 0 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_multiRegister04(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_zeroBitLength01(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '0, 0, 0' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '0, 0, 0' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_zeroBitLength02(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0xff | 0xff = 0xff'
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0xff | 0xff = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff | 0xff = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_zeroBitLength03A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '0, 8, 8' -> '0 | 0xff = 0xff'
        
        'r0 | r1 = r2' with bitLength '0, 8, 8' -> '0 | 0xff = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0xff
        ->
        '0 | 0xff = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0xff
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_zeroBitLength03B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 0, 8' -> '0xff | 0 = 0xff'
        
        'r0 | r1 = r2' with bitLength '8, 0, 8' -> '0xff | 0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0
        ->
        '0xff | 0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_zeroBitLength03C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 0' -> '0xff | 0xff = 0'
        
        'r0 | r1 = r2' with bitLength '8, 8, 0' -> '0xff | 0xff = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff | 0xff = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """

        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength01A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 1, 1' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '8, 1, 1' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength01B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 8, 1' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '1, 8, 1' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength01C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 8' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '1, 1, 8' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength02A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 1, 1' -> '0 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '8, 1, 1' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength02B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 8, 1' -> '0 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 8, 1' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength02C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 8' -> '0 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 8' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength03A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 1, 1' -> '1 | 0 = 1'

        'r0 | r1 = r2' with bitLength '8, 1, 1' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength03B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 8, 1' -> '1 | 0 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 8, 1' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength03C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 8' -> '1 | 0 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 8' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength04A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 1, 1' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '8, 1, 1' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength04B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 8, 1' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 8, 1' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_variableBitLength04C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 8' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 8' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterIndex01(self):
        """tests opOR on 'r1024 | r1 = r2' with bitLength '8, 8, 8' -> '0xff | 0x0f = 0xff'
        
        'r1024 | r1 = r2' with bitLength '8, 8, 8' -> '0xff | 0x0f = 0xff'
        -> # create registers
        r1024 = [0, 1024];              value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff | 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r1024 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterIndex02(self):
        """tests opOR on 'r0 | r1024 = r2' with bitLength '8, 8, 8' -> '0xff | 0x0f = 0xff'
        
        'r0 | r1024 = r2' with bitLength '8, 8, 8' -> '0xff | 0x0f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1024]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff | 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xff
        r1024 : int = 0x0f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1024,                   r1024),                                 # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterIndex03(self):
        """tests opOR on 'r0 | r1 = r1024' with bitLength '8, 8, 8' -> '0xff | 0x0f = 0xff'
        
        'r0 | r1 = r1024' with bitLength '8, 8, 8' -> '0xff | 0x0f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff | 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1024 = [0, 1024];              value = 0xff; bitLength = 8
        """
        
        r0 : int = 0xff
        r1 : int = 0x0f
        r1024_out : int = 0xff

        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize01A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize01B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize01C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize02A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '0 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize02B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '0 | 1 = 1'

        'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize02C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '0 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '0 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize03A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '1 | 0 = 1'
        
        'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize03B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '1 | 0 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize03C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '1 | 0 = 1'

        'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '1 | 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 | 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize04A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1024, 1, 1' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize04B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1024, 1' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize04C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '1, 1, 1024' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize05A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '1024, 8, 8' -> '0xff | 0x0f = 0xff'
        
        'r0 | r1 = r2' with bitLength '1024, 8, 8' -> '0xff | 0x0f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 1024
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff | 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize05B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 1024, 8' -> '0xff | 0x0f = 0xff'
        
        'r0 | r1 = r2' with bitLength '8, 1024, 8' -> '0xff | 0x0f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff | 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize05C(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 1024' -> '0xff | 0x0f = 0xff'
        
        'r0 | r1 = r2' with bitLength '8, 8, 1024' -> '0xff | 0x0f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff | 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 1024
        """

        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_largeRegisterSize06A(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) | 2**(2**20 - 1) = 2**(2**20 - 1)'
        
        'r0 | r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) | 2**(2**20 - 1) = 2**(2**20 - 1)'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20 - 1); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**20 - 1); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 2**(2**20 - 1)
        registerB                       = 2**(2**20 - 1)
        ->
        '2**(2**20 - 1) | 2**(2**20 - 1) = 2**(2**20 - 1)'
        -> # output
        registerDestination             = 2**(2**20 - 1)
        -> # written
        r2 = [0, 2];                    value = 2**(2**20 - 1); bitLength = 2**20
        """

        r0 : int = 2**(2**20 - 1)
        r1 : int = 2**(2**20 - 1)
        r2_out : int = 2**(2**20 - 1)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opOR_largeRegisterSize06B(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) | 2**(2**20 - 2) = 2**(2**20 - 1) + 2**(2**20 - 2)'
        
        'r0 | r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) | 2**(2**20 - 2) = 2**(2**20 - 1) + 2**(2**20 - 2)'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20 - 1); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**20 - 2); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 2**(2**20 - 1)
        registerB                       = 2**(2**20 - 2)
        ->
        '2**(2**20 - 1) | 2**(2**20 - 2) = 2**(2**20 - 1) + 2**(2**20 - 2)'
        -> # output
        registerDestination             = 2**(2**20 - 1) + 2**(2**20 - 2)
        -> # written
        r2 = [0, 2];                    value = 2**(2**20 - 1) + 2**(2**20 - 2); bitLength = 2**20
        """

        r0 : int = 2**(2**20 - 1)
        r1 : int = 2**(2**20 - 2)
        r2_out : int = 2**(2**20 - 1) + 2**(2**20 - 2)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opOR_inputBitPattern1BitSweep01(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) | (1 << y) = ?' for x in range(8) for y in range(8)]
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) | (1 << y) = ?' for x in range(8) for y in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = (1 << y); bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) | (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """

        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = r0 | r1
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_inputBitPattern1BitSweep02(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) | (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 | r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) | (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 512
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) | (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 512
        """

        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = r0 | r1
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_inputBitPattern1BitSweep03(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) | (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 | r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) | (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) | (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """

        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = r0 | r1
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_inputBitPatternCheckerboardConstructive01(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... | 0b1010... = 0b1010...'
        
        'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... | 0b1010... = 0b1010...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... | 0b1010... = 0b1010...'
        -> # output
        registerDestination             = 0b1010...
        -> # written
        r2 = [0, 2];                    value = 0b1010...; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = sum([2**i for i in range(2048) if i % 2 == 1])
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_inputBitPatternCheckerboardConstructive02(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... | 0b0101... = 0b0101...'
        
        'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... | 0b0101... = 0b0101...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b0101...
        ->
        '0b0101... | 0b0101... = 0b0101...'
        -> # output
        registerDestination             = 0b0101...
        -> # written
        r2 = [0, 2];                    value = 0b0101...; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = sum([2**i for i in range(2048) if i % 2 == 0])
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_inputBitPatternCheckerboardDestructive01(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... | 0b0101... = 0b1111...'
        
        'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... | 0b0101... = 0b1111...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... | 0b0101... = 0b1111...'
        -> # output
        registerDestination             = 0b1111...
        -> # written
        r2 = [0, 2];                    value = 0b1111...; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 2**2048 - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_inputBitPatternCheckerboardDestructive02(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... | 0b1010... = 0b1111...'
        
        'r0 | r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... | 0b1010... = 0b1111...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... | 0b1010... = 0b1111...'
        -> # output
        registerDestination             = 0b1111...
        -> # written
        r2 = [0, 2];                    value = 0b1111...; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 2**2048 - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_bitpattern8bit4Overlap(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0xfc | 0x3f = 0xff'
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0xfc | 0x3f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xfc; bitLength = 8
        r1 = [0, 1];                    value = 0x3f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc | 0x3f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_8bitFullCombination(self):
        """tests opAddCarryOverflow on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> ['x | y = ?' for x in range(256) for y in range(256)]
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> ['x | y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x | y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """

        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = x | y
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input
                    (0, 1,              r1),                                    # input
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_integration01(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0 | 0 = 0'
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0 | 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 | 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_integration02(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> '1 | 1 = 1'
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> '1 | 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 | 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_integration03(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0x0f | 0xf0 = 0xff'
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0x0f | 0xf0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0xf0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0xf0
        ->
        '0x0f | 0xf0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0x0f
        r1 : int = 0xf0
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opOR_integration04(self):
        """tests opOR on 'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0x03 | 0x02 = 0x03'
        
        'r0 | r1 = r2' with bitLength '8, 8, 8' -> '0x03 | 0x02 = 0x03'
        -> # create registers
        r0 = [0, 0];                    value = 0x03; bitLength = 8
        r1 = [0, 1];                    value = 0x02; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x03
        registerB                       = 0x02
        ->
        '0x03 | 0x02 = 0x03'
        -> # output
        registerDestination             = 0x03
        -> # written
        r2 = [0, 2];                    value = 0x03; bitLength = 8
        """

        r0 : int = 0x03
        r1 : int = 0x02
        r2_out : int = 0x03
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input
            (0, 1,                      r1),                                    # input
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_Exception_funcReadNotFunction(self):
        """tests opXOR raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opXOR, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerB                                                   = self.registerNull
                )

    def test_opXOR_Exception_funcWriteNotFunction(self):
        """tests opXOR raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opXOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opXOR_Exception_funcGetConfigNotFunction(self):
        """tests opXOR raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opXOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opXOR_Exception_registerDestinationNotRegister(self):
        """tests opXOR raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opXOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerB                                                   = self.registerNull
                )

    def test_opXOR_Exception_registerANotRegister(self):
        """tests opXOR raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opXOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerB                                                   = self.registerNull
                )

    def test_opXOR_Exception_registerBNotRegister(self):
        """tests opXOR raises an exception when registerB is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opXOR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerB                                                   = register # test with invalid register
                )

    def test_opXOR_Exception_registerDestinationNotInMMMU(self):
        """tests opXOR passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opXOR,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerB                                                           = self.registerNull
        )

    def test_opXOR_Exception_registerANotInMMMU(self):
        """tests opXOR passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opXOR,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerB                                                           = self.registerNull
        )

    def test_opXOR_Exception_registerBNotInMMMU(self):
        """tests opXOR passes through a raised MMMUAccessError exception when registerB is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opXOR,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerB                                                           = register # test with invalid register
        )

    def test_opXOR_singleRegister01(self):
        """tests opXOR on 'r0 ^ r0 = r0' with bitLength '1, 1, 1' -> '0 ^ 0 = 0'
        
        'r0 ^ r0 = r0' with bitLength '1, 1, 1' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 0 
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_singleRegister02(self):
        """tests opXOR on 'r0 ^ r0 = r0' with bitLength '1, 1, 1' -> '1 ^ 1 = 0'
        
        'r0 ^ r0 = r0' with bitLength '1, 1, 1' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerB                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_multiRegister01(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_multiRegister02(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_multiRegister03(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_multiRegister04(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_zeroBitLength01(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '0, 0, 0' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '0, 0, 0' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_zeroBitLength02(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0xf0 ^ 0x0f = 0xff'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0xf0 ^ 0x0f = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xf0
        registerB                       = 0x0f
        ->
        '0xf0 ^ 0x0f = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0xf0
        r1 : int = 0x0f
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_zeroBitLength03A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '0, 8, 8' -> '0 ^ 0x0f = 0x0f'
        
        'r0 ^ r1 = r2' with bitLength '0, 8, 8' -> '0 ^ 0x0f = 0x0f'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0x0f
        ->
        '0 ^ 0x0f = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r2 = [0, 2];                    value = 0x0f; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0x0f
        r2_out : int = 0x0f
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_zeroBitLength03B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 0, 8' -> '0xf0 ^ 0 = 0xf0'

        'r0 ^ r1 = r2' with bitLength '8, 0, 8' -> '0xf0 ^ 0 = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xf0
        registerB                       = 0
        ->
        '0xf0 ^ 0 = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0xf0
        r1 : int = 0
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_zeroBitLength03C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 0' -> '0xf0 ^ 0x0f = 0'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 0' -> '0xf0 ^ 0x0f = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xf0
        registerB                       = 0x0f
        ->
        '0xf0 ^ 0x0f = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """

        r0 : int = 0xf0
        r1 : int = 0x0f
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength01A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength01B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength01C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength02A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength02B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength02C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength03A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength03B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength03C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength04A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '8, 1, 1' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength04B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 8, 1' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_variableBitLength04C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 8' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterIndex01(self):
        """tests opXOR on 'r1024 ^ r1 = r2' with bitLength '8, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        
        'r1024 ^ r1 = r2' with bitLength '8, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        -> # create registers
        r1024 = [0, 1024];              value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff ^ 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r1024 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterIndex02(self):
        """tests opXOR on 'r0 ^ r1024 = r2' with bitLength '8, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        
        'r0 ^ r1024 = r2' with bitLength '8, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1024]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff ^ 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0xff
        r1024 : int = 0x0f
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1024,                   r1024),                                 # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterIndex03(self):
        """tests opXOR on 'r0 ^ r1 = r1024' with bitLength '8, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        
        'r0 ^ r1 = r1024' with bitLength '8, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1024 = [0, 1024];              value = 0; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r1024_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize01A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize01B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize01C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize02A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize02B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize02C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '0 ^ 1 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '0 ^ 1 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 ^ 1 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize03A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize03B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize03C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '1 ^ 0 = 1'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '1 ^ 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 ^ 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize04A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1024, 1, 1' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize04B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1024, 1' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize04C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '1, 1, 1024' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize05A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '1024, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        
        'r0 ^ r1 = r2' with bitLength '1024, 8, 8' -> '0xff ^ 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 1024
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff ^ 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize05B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 1024, 8' -> '0xff ^ 0x0f = 0xf0'

        'r0 ^ r1 = r2' with bitLength '8, 1024, 8' -> '0xff ^ 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff ^ 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize05C(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 1024' -> '0xff ^ 0x0f = 0xf0'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 1024' -> '0xff ^ 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0x0f
        ->
        '0xff ^ 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 1024
        """

        r0 : int = 0xff
        r1 : int = 0x0f
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_largeRegisterSize06A(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) ^ 2**(2**20 - 1) = 0'
        
        'r0 ^ r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) ^ 2**(2**20 - 1) = 0'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20 - 1); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**20 - 1); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 2**(2**20 - 1)
        registerB                       = 2**(2**20 - 1)
        ->
        '2**(2**20 - 1) ^ 2**(2**20 - 1) = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        """

        r0 : int = 2**(2**20 - 1)
        r1 : int = 2**(2**20 - 1)
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opXOR_largeRegisterSize06B(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) ^ 2**(2**20 - 2) = 2**(2**20 - 1) + 2**(2**20 - 2)'
        
        'r0 ^ r1 = r2' with bitLength '2**20, 2**20, 2**20' -> '2**(2**20 - 1) ^ 2**(2**20 - 2) = 2**(2**20 - 1) + 2**(2**20 - 2)'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20 - 1); bitLength = 2**20
        r1 = [0, 1];                    value = 2**(2**20 - 2); bitLength = 2**20
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 2**(2**20 - 1)
        registerB                       = 2**(2**20 - 2)
        ->
        '2**(2**20 - 1) ^ 2**(2**20 - 2) = 2**(2**20 - 1) + 2**(2**20 - 2)'
        -> # output
        registerDestination             = 2**(2**20 - 1) + 2**(2**20 - 2)
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        """

        r0 : int = 2**(2**20 - 1)
        r1 : int = 2**(2**20 - 2)
        r2_out : int = 2**(2**20 - 1) + 2**(2**20 - 2)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2**20)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opXOR_inputBitPattern1BitSweep01(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) ^ (1 << y) = ?' for x in range(8) for y in range(8)]
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) ^ (1 << y) = ?' for x in range(8) for y in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = (1 << y); bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) ^ (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """

        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = r0 ^ r1
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opXOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_inputBitPattern1BitSweep02(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) ^ (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 ^ r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) ^ (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 512
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) ^ (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 512
        """

        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = r0 ^ r1
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opXOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_inputBitPattern1BitSweep03(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) ^ (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 ^ r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) ^ (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) ^ (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """

        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = r0 ^ r1
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opXOR(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerB                                                   = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_inputBitPatternCheckerboardConstructive01(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... ^ 0b1010... = 0b0000...'
        
        'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... ^ 0b1010... = 0b0000...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... ^ 0b1010... = 0b0000...'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_inputBitPatternCheckerboardConstructive02(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... ^ 0b0101... = 0b0000...'
        
        'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... ^ 0b0101... = 0b0000...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b0101...
        ->
        '0b0101... ^ 0b0101... = 0b0000...'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_inputBitPatternCheckerboardDestructive01(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... ^ 0b0101... = 0b1111...'
        
        'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... ^ 0b0101... = 0b1111...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... ^ 0b0101... = 0b1111...'
        -> # output
        registerDestination             = 2**2048 - 1
        -> # written
        r2 = [0, 2];                    value = 2**2048 - 1; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 2**2048 - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_inputBitPatternCheckerboardDestructive02(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... ^ 0b1010... = 0b1111...'
        
        'r0 ^ r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... ^ 0b1010... = 0b1111...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... ^ 0b1010... = 0b1111...'
        -> # output
        registerDestination             = 2**2048 - 1
        -> # written
        r2 = [0, 2];                    value = 2**2048 - 1; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 2**2048 - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_bitpattern8bit4Overlap(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0xfc ^ 0x3f = 0xc3'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0xfc ^ 0x3f = 0xc3'
        -> # create registers
        r0 = [0, 0];                    value = 0xfc; bitLength = 8
        r1 = [0, 1];                    value = 0x3f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc ^ 0x3f = 0xc3'
        -> # output
        registerDestination             = 0xc3
        -> # written
        r2 = [0, 2];                    value = 0xc3; bitLength = 8
        """

        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0xc3
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_8bitFullCombination(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> ['x ^ y = ?' for x in range(256) for y in range(256)]
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> ['x ^ y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x ^ y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """

        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = x ^ y
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opXOR(
                    funcRead                                                            = MMMU.dummyReadWrapper,
                    funcWrite                                                           = MMMU.dummyWriteWrapper,
                    funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
                    registerDestination                                                 = [0, 2],
                    registerA                                                           = [0, 0],
                    registerB                                                           = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
                    ('read',                    0, 0,                                   r0),
                    ('read',                    0, 1,                                   r1),
                    ('getConfig',               0, 2,                                   8),
                    ('write',                   0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
                    (0, 0,                      r0),                                    # input, no change
                    (0, 1,                      r1),                                    # input, no change
                    (0, 2,                      r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_integration01(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0 ^ 0 = 0'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0 ^ 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 ^ 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_integration02(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '1 ^ 1 = 0'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '1 ^ 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 ^ 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_integration03(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0x0f ^ 0xf0 = 0xff'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0x0f ^ 0xf0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0xf0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0xf0
        ->
        '0x0f ^ 0xf0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0x0f
        r1 : int = 0xf0
        r2_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opXOR_integration04(self):
        """tests opXOR on 'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0x03 ^ 0x02 = 0x01'
        
        'r0 ^ r1 = r2' with bitLength '8, 8, 8' -> '0x03 ^ 0x02 = 0x01'
        -> # create registers
        r0 = [0, 0];                    value = 0x03; bitLength = 8
        r1 = [0, 1];                    value = 0x02; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opXOR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerB                   = [0, 1]
        )
        -> # input
        registerA                       = 0x03
        registerB                       = 0x02
        ->
        '0x03 ^ 0x02 = 0x01'
        -> # output
        registerDestination             = 0x01
        -> # written
        r2 = [0, 2];                    value = 0x01; bitLength = 8
        """

        r0 : int = 0x03
        r1 : int = 0x02
        r2_out : int = 0x01
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opXOR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerB                                                           = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_Exception_funcReadNotFunction(self):
        """tests opNOT raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opNOT, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull
                )

    def test_opNOT_Exception_funcWriteNotFunction(self):
        """tests opNOT raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opNOT,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull
                )

    def test_opNOT_Exception_funcGetConfigNotFunction(self):
        """tests opNOT raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opNOT,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull
                )

    def test_opNOT_Exception_registerDestinationNotRegister(self):
        """tests opNOT raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opNOT,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull
                )

    def test_opNOT_Exception_registerANotRegister(self):
        """tests opNOT raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opNOT,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register # test with invalid register
                )

    def test_opNOT_Exception_registerDestinationNotInMMMU(self):
        """tests opNOT passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opNOT,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull
        )

    def test_opNOT_Exception_registerANotInMMMU(self):
        """tests opNOT passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opNOT,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register # test with invalid register
        )

    def test_opNOT_singleRegister01(self):
        """tests opNOT on '! r0 = r0' with bitLength '1, 1' -> '! 0 = 1'
        
        '! r0 = r0' with bitLength '1, 1' -> '! 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r0 = [0, 0];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r0_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_singleRegister02(self):
        """tests opNOT on '! r0 = r0' with bitLength '1, 1' -> '! 1 = 0'
        
        '! r0 = r0' with bitLength '1, 1' -> '! 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        '! 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_multiRegister01(self):
        """tests opNOT on '! r0 = r1' with bitLength '1, 1' -> '! 0 = 1'
        
        '! r0 = r1' with bitLength '1, 1' -> '! 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_multiRegister02(self):
        """tests opNOT on '! r0 = r1' with bitLength '1, 1' -> '! 1 = 0'
        
        '! r0 = r1' with bitLength '1, 1' -> '! 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        '! 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_zeroBitLength01(self):
        """tests opNOT on '! r0 = r1' with bitLength '0, 0' -> '! 0 = 0'
        
        '! r0 = r1' with bitLength '0, 0' -> '! 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0; bitLength = 0
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 0
        """

        r0 : int = 0
        r1_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   0),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_zeroBitLength02(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> '! 0x0f = 0xf0'
        
        '! r0 = r1' with bitLength '8, 8' -> '! 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x0f
        ->
        '! 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r1 = [0, 1];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0x0f
        r1_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_zeroBitLength03A(self):
        """tests opNOT on '! r0 = r1' with bitLength '0, 8' -> '! 0 = 0xff'
        
        '! r0 = r1' with bitLength '0, 8' -> '! 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0
        r1_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_zeroBitLength03B(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 0' -> '! 0x0f = 0'
        
        '! r0 = r1' with bitLength '8, 0' -> '! 0x0f = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x0f
        ->
        '! 0x0f = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 0
        """

        r0 : int = 0x0f
        r1_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   0),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_variableBitLength01A(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 1' -> '! 0 = 1'
        
        '! r0 = r1' with bitLength '8, 1' -> '! 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_variableBitLength01B(self):
        """tests opNOT on '! r0 = r1' with bitLength '1, 8' -> '! 0 = 0xff'
        
        '! r0 = r1' with bitLength '1, 8' -> '! 0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0
        r1_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_variableBitLength02A(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 1' -> '! 0xff = 0'
        
        '! r0 = r1' with bitLength '8, 1' -> '! 0xff = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xff
        ->
        '! 0xff = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1
        """

        r0 : int = 0xff
        r1_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_variableBitLength02B(self):
        """tests opNOT on '! r0 = r1' with bitLength '1, 8' -> '! 1 = 0xfe'
        
        '! r0 = r1' with bitLength '1, 8' -> '! 1 = 0xfe'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        '! 1 = 0xfe'
        -> # output
        registerDestination             = 0xfe
        -> # written
        r1 = [0, 1];                    value = 0xfe; bitLength = 8
        """

        r0 : int = 1
        r1_out : int = 0xfe
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterIndex01(self):
        """tests opNOT on '! r1024 = r1' with bitLength '8, 8' -> '! 0x0f = 0xf0'
        
        '! r1024 = r1' with bitLength '8, 8' -> '! 0x0f = 0xf0'
        -> # create registers
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 1024]
        )
        -> # input
        registerA                       = 0x0f
        ->
        '! 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r1 = [0, 1];                    value = 0xf0; bitLength = 8
        """

        r1024 : int = 0x0f
        r1_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterIndex02(self):
        """tests opNOT on '! r0 = r1024' with bitLength '8, 8' -> '! 0x0f = 0xf0'
        
        '! r0 = r1024' with bitLength '8, 8' -> '! 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x0f
        ->
        '! 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r1024 = [0, 1024];              value = 0xf0; bitLength = 8
        """

        r0 : int = 0x0f
        r1024_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize01A(self):
        """tests opNOT on '! r0 = r1' with bitLength '1024, 1' -> '! 0 = 1'
        
        '! r0 = r1' with bitLength '1024, 1' -> '! 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r1 = [0, 1];                    value = 1; bitLength = 1
        """

        r0 : int = 0
        r1_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize01B(self):
        """tests opNOT on '! r0 = r1' with bitLength '1, 1024' -> '! 0 = 0xffff...'
        
        '! r0 = r1' with bitLength '1, 1024' -> '! 0 = 0xffff...'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 0xffff...'
        -> # output
        registerDestination             = 0xffff...
        -> # written
        r1 = [0, 1];                    value = 0xffff...; bitLength = 1024
        """

        r0 : int = 0
        r1_out : int = 2**1024 - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1024),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize02A(self):
        """tests opNOT on '! r0 = r1' with bitLength '1024, 1' -> '! 1 = 0'
        
        '! r0 = r1' with bitLength '1024, 1' -> '! 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        '! 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize02B(self):
        """tests opNOT on '! r0 = r1' with bitLength '1, 1024' -> '! 1 = 0xffff...fe'
        
        '! r0 = r1' with bitLength '1, 1024' -> '! 1 = 0xffff...fe'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        '! 1 = 0xffff...fe'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 1024
        """

        r0 : int = 1
        r1_out : int = (2**1024 - 1) - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1024),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize03A(self):
        """tests opNOT on '! r0 = r1' with bitLength '1024, 8' -> '! 0x0f = 0xf0'
        
        '! r0 = r1' with bitLength '1024, 8' -> '! 0x0f = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x0f
        ->
        '! 0x0f = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r1 = [0, 1];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0x0f
        r1_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize03B(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 1024' -> '! 0x0f = 0xffff...f0'
        
        '! r0 = r1' with bitLength '8, 1024' -> '! 0x0f = 0xffff...f0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1024
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x0f
        ->
        '! 0x0f = 0xffff...f0'
        -> # output
        registerDestination             = 0xffff...f0
        -> # written
        r1 = [0, 1];                    value = 0xffff...f0; bitLength = 1024
        """

        r0 : int = 0x0f
        r1_out : int = (2**1024 - 1) - 0x0f
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   1024),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_largeRegisterSize04A(self):
        """tests opNOT on '! r0 = r1' with bitLength '2**20, 2**20' -> '! 0 = 2**(2**20) - 1'
        
        '! r0 = r1' with bitLength '2**20, 2**20' -> '! 0 = 2**(2**20) - 1'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 2**(2**20) - 1'
        -> # output
        registerDestination             = 2**(2**20) - 1
        -> # written
        r1 = [0, 1];                    value = 2**(2**20) - 1; bitLength = 2**20
        """

        r0 : int = 0
        r1_out : int = 2**(2**20) - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opNOT_largeRegisterSize04B(self):
        """tests opNOT on '! r0 = r1' with bitLength '2**20, 2**20' -> '! 2**(2**20) - 1 = 0'
        
        '! r0 = r1' with bitLength '2**20, 2**20' -> '! 2**(2**20) - 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20) - 1; bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 2**(2**20) - 1
        ->
        '! 2**(2**20) - 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        """

        r0 : int = 2**(2**20) - 1
        r1_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opNOT_largeRegisterSize04C(self):
        """tests opNOT on '! r0 = r1' with bitLength '2**20, 2**20' -> '! 2**(2**19) - 1 = 2**(2**20) - 1 - (2**(2**19) - 1)' # ! 0x00..00ff..ff = 0xff..ff00..00
        
        '! r0 = r1' with bitLength '2**20, 2**20' -> '! 2**(2**19) - 1 = 2**(2**20) - 1 - (2**(2**19) - 1)' # ! 0x00..00ff..ff = 0xff..ff00..00
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**19) - 1; bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 2**(2**19) - 1
        ->
        '! 2**(2**19) - 1 = 2**(2**20) - 1 - (2**(2**19) - 1)' # ! 0x00..00ff..ff = 0xff..ff00..00
        -> # output
        registerDestination             = 2**(2**20) - 1 - (2**(2**19) - 1)
        -> # written
        r1 = [0, 1];                    value = 2**(2**20) - 1 - (2**(2**19) - 1); bitLength = 2**20
        """

        r0 : int = 2**(2**19) - 1
        r1_out : int = 2**(2**20) - 1 - (2**(2**19) - 1)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opNOT_largeRegisterSize04D(self):
        """tests opNOT on '! r0 = r1' with bitLength '2**20, 2**20' -> '! 2**(2**20) - 1 - (2**(2**19) - 1) = 2**(2**19) - 1' # ! 0xff..ff00..00 = 0x00..00ff..ff
        
        '! r0 = r1' with bitLength '2**20, 2**20' -> '! 2**(2**20) - 1 - (2**(2**19) - 1) = 2**(2**19) - 1' # ! 0xff..ff00..00 = 0x00..00ff..ff
        -> # create registers
        r0 = [0, 0];                    value = 2**(2**20) - 1 - (2**(2**19) - 1); bitLength = 2**20
        r1 = [0, 1];                    value = 0; bitLength = 2**20
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 2**(2**20) - 1 - (2**(2**19) - 1)
        ->
        '! 2**(2**20) - 1 - (2**(2**19) - 1) = 2**(2**19) - 1' # ! 0xff..ff00..00 = 0x00..00ff..ff
        -> # output
        registerDestination             = 2**(2**19) - 1
        -> # written
        r1 = [0, 1];                    value = 2**(2**19) - 1; bitLength = 2**20
        """

        r0 : int = 2**(2**20) - 1 - (2**(2**19) - 1)
        r1_out : int = 2**(2**19) - 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2**20)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2**20),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opNOT_inputBitPattern1BitSweep01(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> ['! (1 << x) = ?' for x in range(8)]
        
        '! r0 = r1' with bitLength '8, 8' -> ['! (1 << x) = ?' for x in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = (1 << x)
        ->
        '! (1 << x) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 8
        """

        for x in [x for x in range(8)]:
            with self.subTest(x=x):
                r0 : int = (1 << x)
                r1_out : int = r0 ^ 0xff
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opNOT(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   8),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_inputBitPattern1BitSweep02(self):
        """tests opNOT on '! r0 = r1' with bitLength '512, 512' -> ['! (1 << x) = ?' for x in range(512)]
        
        '! r0 = r1' with bitLength '512, 512' -> ['! (1 << x) = ?' for x in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = 0; bitLength = 512
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = (1 << x)
        ->
        '! (1 << x) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 512
        """

        for x in [x for x in range(512)]:
            with self.subTest(x=x):
                r0 : int = (1 << x)
                r1_out : int = r0 ^ (2**512 - 1)
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opNOT(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   512),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_inputBitPattern1BitSweep03(self):
        """tests opNOT on '! r0 = r1' with bitLength '512, 2048' -> ['! (1 << x) = ?' for x in range(512)]
        
        '! r0 = r1' with bitLength '512, 2048' -> ['! (1 << x) = ?' for x in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = 0; bitLength = 2048
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = (1 << x)
        ->
        '! (1 << x) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 2048
        """

        for x in [x for x in range(512)]:
            with self.subTest(x=x):
                r0 : int = (1 << x)
                r1_out : int = r0 ^ (2**2048 - 1)
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opNOT(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   2048),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_inputBitPatternCheckerboard01(self):
        """tests opNOT on '! r0 = r1' with bitLength '2048, 2048' -> '! 0b1010... = 0b0101...'
        
        '! r0 = r1' with bitLength '2048, 2048' -> '! 0b1010... = 0b0101...'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0; bitLength = 2048
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0b1010...
        ->
        '! 0b1010... = 0b0101...'
        -> # output
        registerDestination             = 0b0101...
        -> # written
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1_out : int = sum([2**i for i in range(2048) if i % 2 == 0])
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2048),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_inputBitPatternCheckerboard02(self):
        """tests opNOT on '! r0 = r1' with bitLength '2048, 2048' -> '! 0b0101... = 0b1010...'
        
        '! r0 = r1' with bitLength '2048, 2048' -> '! 0b0101... = 0b1010...'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0; bitLength = 2048
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0b0101...
        ->
        '! 0b0101... = 0b1010...'
        -> # output
        registerDestination             = 0b1010...
        -> # written
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1_out : int = sum([2**i for i in range(2048) if i % 2 == 1])
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   2048),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_8bitFullCombination(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> ['! x = ?' for x in range(256)]
        
        '! r0 = r1' with bitLength '8, 8' -> ['! x = ?' for x in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = x
        ->
        '! x = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r1 = [0, 1];                    value = ?; bitLength = 8
        """

        for x in [x for x in range(256)]:
            with self.subTest(x=x):
                r0 : int = x
                r1_out : int = r0 ^ 0xff
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opNOT(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 1],
                    registerA                                                   = [0, 0]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('getConfig',       0, 1,                                   8),
                    ('write',           0, 1,                                   r1_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_integration01(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> '! 0 = 0xff'
        
        '! r0 = r1' with bitLength '8, 8' -> '! 0 = 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0
        ->
        '! 0 = 0xff'
        -> # output
        registerDestination             = 0xff
        -> # written
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        """

        r0 : int = 0
        r1_out : int = 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_integration02(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> '! 1 = 0xfe'
        
        '! r0 = r1' with bitLength '8, 8' -> '! 1 = 0xfe'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 1
        ->
        '! 1 = 0xfe'
        -> # output
        registerDestination             = 0xfe
        -> # written
        r1 = [0, 1];                    value = 0xfe; bitLength = 8
        """

        r0 : int = 1
        r1_out : int = 0xfe
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_integration03(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> '! 0xf0 = 0x0f'
        
        '! r0 = r1' with bitLength '8, 8' -> '! 0xf0 = 0x0f'
        -> # create registers
        r0 = [0, 0];                    value = 0xf0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xf0
        ->
        '! 0xf0 = 0x0f'
        -> # output
        registerDestination             = 0x0f
        -> # written
        r1 = [0, 1];                    value = 0x0f; bitLength = 8
        """

        r0 : int = 0xf0
        r1_out : int = 0x0f
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNOT_integration04(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 8' -> '! 0x02 = 0xfd'
        
        '! r0 = r1' with bitLength '8, 8' -> '! 0x02 = 0xfd'
        -> # create registers
        r0 = [0, 0];                    value = 0x02; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x02
        ->
        '! 0x02 = 0xfd'
        -> # output
        registerDestination             = 0xfd
        -> # written
        r1 = [0, 1];                    value = 0xfd; bitLength = 8
        """

        r0 : int = 0x02
        r1_out : int = 0xfd
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNot_integration05(self):
        """tests opNOT on '! r0 = r1' with bitLength '8, 4' -> '! 0xfe = 0x1'
        
        '! r0 = r1' with bitLength '8, 4' -> '! 0xfe = 0x1'
        -> # create registers
        r0 = [0, 0];                    value = 0xfe; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 4
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0xfe
        ->
        '! 0xfe = 0x1'
        -> # output
        registerDestination             = 0x1
        -> # written
        r1 = [0, 1];                    value = 0x1; bitLength = 8
        """

        r0 : int = 0xfe
        r1_out : int = 0x1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 4)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   4),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opNot_integration06(self):
        """tests opNOT on '! r0 = r1' with bitLength '4, 8' -> '! 0x01 = 0xfe'
        
        '! r0 = r1' with bitLength '4, 8' -> '! 0x01 = 0xfe'
        -> # create registers
        r0 = [0, 0];                    value = 0x01; bitLength = 4
        r1 = [0, 1];                    value = 0; bitLength = 8
        ->
        opNOT(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1]
            registerA                   = [0, 0]
        )
        -> # input
        registerA                       = 0x01
        ->
        '! 0x01 = 0xfe'
        -> # output
        registerDestination             = 0xfe
        -> # written
        r1 = [0, 1];                    value = 0xfe; bitLength = 8
        """

        r0 : int = 0x01
        r1_out : int = 0xfe
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 4)
        MMMU.createRegister(            0, 1,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opNOT(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1],
            registerA                                                           = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 1,                                   8),
            ('write',                   0, 1,                                   r1_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    #TODO testing on opJump

    def test_opShiftL_Exception_funcReadNotFunction(self):
        """tests opShiftL raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opShiftL, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerShiftOffset                                         = self.registerNull
                )

    def test_opShiftL_Exception_funcWriteNotFunction(self):
        """tests opShiftL raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opShiftL,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function, # test with invalid function
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = self.registerNull
                )

    def test_opShiftL_Exception_funcGetConfigNotFunction(self):
        """tests opShiftL raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opShiftL,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function, # test with invalid function
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = self.registerNull
                )

    def test_opShiftL_Exception_registerDestinationNotRegister(self):
        """tests opShiftL raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opShiftL,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register, # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = self.registerNull
                )

    def test_opShiftL_Exception_registerANotRegister(self):
        """tests opShiftL raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opShiftL,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register, # test with invalid register
                    registerShiftOffset                                         = self.registerNull
                )

    def test_opShiftL_Exception_registerShiftOffsetNotRegister(self):
        """tests opShiftL raises an exception when registerShiftOffset is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opShiftL,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = register # test with invalid register
                )

    def test_opShiftL_Exception_registerDestinationNotInMMMU(self):
        """tests opShiftL passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opShiftL,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = register, # test with invalid register
            registerA                                                           = self.registerNull,
            registerShiftOffset                                                 = self.registerNull
        )

    def test_opShiftL_Exception_registerANotInMMMU(self):
        """tests opShiftL passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opShiftL,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = register, # test with invalid register
            registerShiftOffset                                                 = self.registerNull
        )

    def test_opShiftL_Exception_registerShiftOffsetNotInMMMU(self):
        """tests opShiftL passes through a raised MMMUAccessError exception when registerShiftOffset is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opShiftL,
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = self.registerNull,
            registerA                                                           = self.registerNull,
            registerShiftOffset                                                 = register # test with invalid register
        )

    def test_opShiftL_singleRegister01(self):
        """tests opShiftL on 'r0 << r0 = r0' with bitLength '1, 1, 1' -> '0 << 0 = 0'

        'r0 << r0 = r0' with bitLength '1, 1, 1' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 0]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_singleRegister02(self):
        """tests opShiftL on 'r0 << r0 = r0' with bitLength '1, 1, 1' -> '1 << 1 = 0'
        
        'r0 << r0 = r0' with bitLength '1, 1, 1' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_singleRegister03(self):
        """tests opShiftL on 'r0 << r0 = r0' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        
        'r0 << r0 = r0' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 0]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r0 = [0, 0];                    value = 2; bitLength = 8
        """

        r0 : int = 1
        r0_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_singleRegister04(self):
        """tests opShiftL on 'r0 << r0 = r0' with bitLength '8, 8, 8' -> '2 << 2 = 8'
        
        'r0 << r0 = r0' with bitLength '8, 8, 8' -> '2 << 2 = 8'
        -> # create registers
        r0 = [0, 0];                    value = 2; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 0]
        )
        -> # input
        registerA                       = 2
        registerB                       = 2
        ->
        '2 << 2 = 8'
        -> # output
        registerDestination             = 8
        -> # written
        r0 = [0, 0];                    value = 8; bitLength = 8
        """

        r0 : int = 2
        r0_out : int = 8
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_singleRegister05(self):
        """tests opShiftL on 'r0 << r0 = r0' with bitLength '8, 8, 8' -> '3 << 3 = 24'
        
        'r0 << r0 = r0' with bitLength '8, 8, 8' -> '3 << 3 = 24'
        -> # create registers
        r0 = [0, 0];                    value = 3; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 0]
        )
        -> # input
        registerA                       = 3
        registerB                       = 3
        ->
        '3 << 3 = 24'
        -> # output
        registerDestination             = 24
        -> # written
        r0 = [0, 0];                    value = 24; bitLength = 8
        """

        r0 : int = 3
        r0_out : int = 24
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 0]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   8),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_multiRegister01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_multiRegister02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_multiRegister03(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1' -> '1 << 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_multiRegister04(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1' -> '1 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_multiRegister05(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_zeroBitLength01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '0, 0, 0' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '0, 0, 0' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_zeroBitLength02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_zeroBitLength03A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '0, 8, 8' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '0, 8, 8' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 0
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 0)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_zeroBitLength03B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 0, 8' -> '1 << 0 = 1'

        'r0 << r1 = r2' with bitLength '8, 0, 8' -> '1 << 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 0
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 0)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_zeroBitLength03C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 0' -> '1 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '8, 8, 0' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 0
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 0
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 0)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   0),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength01A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 1, 1' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '8, 1, 1' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength01B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 8, 1' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 8, 1' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength01C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 8' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 8' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength02A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 1, 1' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '8, 1, 1' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength02B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 8, 1' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 8, 1' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength02C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 8' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 8' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength03A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 1, 1' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '8, 1, 1' -> '1 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 0'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength03B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 8, 1' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '1, 8, 1' -> '1 << 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength03C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 8' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '1, 1, 8' -> '1 << 0 = 1'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 1'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength04A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 1, 1' -> '1 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '8, 1, 1' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength04B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 8, 1' -> '1 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 8, 1' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_variableBitLength04C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 8' -> '1 << 1 = 2'
        
        'r0 << r1 = r2' with bitLength '1, 1, 8' -> '1 << 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterIndex01(self):
        """tests opShiftL on 'r1024 << r1 = r2' with bitLength '8, 8, 8' -> '0x0f << 0x04 = 0xf0'
        
        'r1024 << r1 = r2' with bitLength '8, 8, 8' -> '0x0f << 0x04 = 0xf0'
        -> # create registers
        r1024 = [0, 1024];              value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0x04; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 1024]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0x04
        ->
        '0x0f << 0x04 = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r1024 : int = 0x0f
        r1 : int = 0x04
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 1024],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 1024,                                r1024),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 1024,                   r1024),                                 # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterIndex02(self):
        """tests opShiftL on 'r0 << r1024 = r2' with bitLength '8, 8, 8' -> '0x0f << 0x04 = 0xf0'
        
        'r0 << r1024 = r2' with bitLength '8, 8, 8' -> '0x0f << 0x04 = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1024 = [0, 1024];              value = 0x04; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1024]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0x04
        ->
        '0x0f << 0x04 = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r2 = [0, 2];                    value = 0xf0; bitLength = 8
        """

        r0 : int = 0x0f
        r1024 : int = 0x04
        r2_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = r1024, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1024]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1024,                                r1024),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1024,                   r1024),                                 # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterIndex03(self):
        """tests opShiftL on 'r0 << r1 = r1024' with bitLength '8, 8, 8' -> '0x0f << 0x04 = 0xf0'
        
        'r0 << r1 = r1024' with bitLength '8, 8, 8' -> '0x0f << 0x04 = 0xf0'
        -> # create registers
        r0 = [0, 0];                    value = 0x0f; bitLength = 8
        r1 = [0, 1];                    value = 0x04; bitLength = 8
        r1024 = [0, 1024];              value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 1024]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0x0f
        registerB                       = 0x04
        ->
        '0x0f << 0x04 = 0xf0'
        -> # output
        registerDestination             = 0xf0
        -> # written
        r1024 = [0, 1024];              value = 0xf0; bitLength = 8
        """

        r0 : int = 0x0f
        r1 : int = 0x04
        r1024_out : int = 0xf0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 1024,                                value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 1024],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 1024,                                8),
            ('write',                   0, 1024,                                r1024_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 1024,                   r1024_out)                              # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize01A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize01B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize01C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize02A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize02B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize02C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '0 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '0 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 1
        ->
        '0 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1024
        """

        r0 : int = 0
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize03A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '1 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 0'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize03B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '1 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 0'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize03C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '1 << 0 = 1'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '1 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 0; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0
        ->
        '1 << 0 = 0'
        -> # output
        registerDestination             = 1
        -> # written
        r2 = [0, 2];                    value = 1; bitLength = 1024
        """

        r0 : int = 1
        r1 : int = 0
        r2_out : int = 1
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize04A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '1 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1024, 1, 1' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize04B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '1 << 1 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1024, 1' -> '1 << 1 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 1
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 1
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize04C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '1 << 1 = 2'
        
        'r0 << r1 = r2' with bitLength '1, 1, 1024' -> '1 << 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 1; bitLength = 1
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 1024
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize05A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 8, 8' -> '0xff << 1 = 0xfe'
        
        'r0 << r1 = r2' with bitLength '1024, 8, 8' -> '0xff << 1 = 0xfe'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 1024
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 1
        ->
        '0xff << 1 = 0xfe'
        -> # output
        registerDestination             = 0xfe
        -> # written
        r2 = [0, 2];                    value = 0xfe; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 1
        r2_out : int = 0xfe
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize05B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 1024, 8' -> '0xff << 0xff = 0'
        
        'r0 << r1 = r2' with bitLength '8, 1024, 8' -> '0xff << 0xff = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff << 0xff = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize05C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 1024' -> '0xff << 0xff = 0xff << 0xff'
        
        'r0 << r1 = r2' with bitLength '8, 8, 1024' -> '0xff << 0xff = 0xff << 0xff'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 0xff; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 0xff
        ->
        '0xff << 0xff = 0xff << 0xff'
        -> # output
        registerDestination             = 0xff << 0xff
        -> # written
        r2 = [0, 2];                    value = 0xff << 0xff; bitLength = 1024
        """

        r0 : int = 0xff
        r1 : int = 0xff
        r2_out : int = 0xff << 0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 1024)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   1024),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize06A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 << 0xff = 2**0xff'
        
        'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 << 0xff = 2**0xff'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 0xff; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0xff
        ->
        '1 << 0xff = 2**0xff'
        -> # output
        registerDestination             = 2**0xff
        -> # written
        r2 = [0, 2];                    value = 2**0xff; bitLength = 2**20
        """

        r0 : int = 1
        r1 : int = 0xff
        r2_out : int = 2**0xff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_largeRegisterSize06B(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 << 0xffff = 2**0xffff'
        
        'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 << 0xffff = 2**0xffff'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 0xffff; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 0xffff
        ->
        '1 << 0xffff = 2**0xffff'
        -> # output
        registerDestination             = 2**0xffff
        -> # written
        r2 = [0, 2];                    value = 2**0xffff; bitLength = 2**20
        """

        r0 : int = 1
        r1 : int = 0xffff
        r2_out : int = 2**0xffff
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opShiftL_largeRegisterSize06C(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '3 << 0xffff = 2**0xffff + 2**0x10000'
        
        'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '3 << 0xffff = 2**0xffff + 2**0x10000'
        -> # create registers
        r0 = [0, 0];                    value = 3; bitLength = 1024
        r1 = [0, 1];                    value = 0xffff; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 3
        registerB                       = 0xffff
        ->
        '3 << 0xffff = 2**0xffff + 2**0x10000'
        -> # output
        registerDestination             = 2**0xffff + 2**0x10000
        -> # written
        r2 = [0, 2];                    value = 2**0xffff + 2**0x10000; bitLength = 2**20
        """

        r0 : int = 3
        r1 : int = 0xffff
        r2_out : int = 2**0xffff + 2**0x10000
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opShiftL_largeRegisterSize07A(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 << 2**18 = 2**(2**18)'
        
        'r0 << r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 << 2**18 = 2**(2**18)'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1024
        r1 = [0, 1];                    value = 2**18; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 2**18
        ->
        '1 << 2**18 = 2**(2**18)'
        -> # output
        registerDestination             = 2**(2**18)
        -> # written
        r2 = [0, 2];                    value = 2**(2**18); bitLength = 2**20
        """

        r0 : int = 1
        r1 : int = 2**18
        r2_out : int = 2**(2**18)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1024)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opShiftL_inputBitPattern1BitSweep01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) << (1 << y) = ?' for x in range(8) for y in range(8)]
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) << (1 << y) = ?' for x in range(8) for y in range(8)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 8
        r1 = [0, 1];                    value = (1 << y); bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) << (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """

        for x, y in [(x, y) for x in range(8) for y in range(8)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = (r0 << r1) & 0xff
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opShiftL(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerShiftOffset                                         = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_inputBitPattern1BitSweep02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) << (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 << r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) << (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 512
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) << (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 512
        """

        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = (r0 << r1) & (2**512 - 1) if r1 <= 512 else 0  # if/else prevents extreme memory use
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 512)

                returnValue : None = self.ISA.opShiftL(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerShiftOffset                                         = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   512),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_inputBitPattern1BitSweep03(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) << (1 << y) = ?' for x in range(512) for y in range(512)]
        
        'r0 << r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) << (1 << y) = ?' for x in range(512) for y in range(512)]
        -> # create registers
        r0 = [0, 0];                    value = (1 << x); bitLength = 512
        r1 = [0, 1];                    value = (1 << y); bitLength = 512
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = (1 << x)
        registerB                       = (1 << y)
        ->
        '(1 << x) << (1 << y) = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 2048
        """

        for x, y in [(x, y) for x in range(512) for y in range(512)]:
            with self.subTest(x=x, y=y):
                r0 : int = (1 << x)
                r1 : int = (1 << y)
                r2_out : int = (r0 << r1) & (2**2048 - 1) if r1 <= 2048 else 0 # if/else prevents extreme memory use
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 512)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 512)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 2048)

                returnValue : None = self.ISA.opShiftL(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerShiftOffset                                         = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   2048),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_inputBitPatternCheckerboardConstructive01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... << 0b1010... = 0'
        
        'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... << 0b1010... = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b1010...
        ->
        '0b1010... << 0b1010... = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_inputBitPatternCheckerboardConstructive02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... << 0b0101... = 0'
        
        'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... << 0b0101... = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b0101...
        ->
        '0b0101... << 0b0101... = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_inputBitPatternCheckerboardDestructive01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... << 0b0101... = 0'
        
        'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... << 0b0101... = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0b1010...; bitLength = 2048
        r1 = [0, 1];                    value = 0b0101...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0b1010...
        registerB                       = 0b0101...
        ->
        '0b1010... << 0b0101... = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_inputBitPatternCheckerboardDestructive02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... << 0b1010... = 0'
        
        'r0 << r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... << 0b1010... = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0b0101...; bitLength = 2048
        r1 = [0, 1];                    value = 0b1010...; bitLength = 2048
        r2 = [0, 2];                    value = 0; bitLength = 2048
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0b0101...
        registerB                       = 0b1010...
        ->
        '0b0101... << 0b1010... = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2048
        """

        r0 : int = sum([2**i for i in range(2048) if i % 2 == 0])
        r1 : int = sum([2**i for i in range(2048) if i % 2 == 1])
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 2048)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 2048)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2048)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2048),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_bitpattern8bit4Overlap(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '0xfc << 0x3f = 0'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '0xfc << 0x3f = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0xfc; bitLength = 8
        r1 = [0, 1];                    value = 0x3f; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0xfc
        registerB                       = 0x3f
        ->
        '0xfc << 0x3f = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0xfc
        r1 : int = 0x3f
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_8bitFullCombination01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> ['x << y = ?' for x in range(256) for y in range(256)]
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> ['x << y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x << y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 8
        """

        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x << y) & (2**8 - 1)
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 8)

                returnValue : None = self.ISA.opShiftL(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerShiftOffset                                         = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   8),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_8bitFullCombination02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 1024' -> ['x << y = ?' for x in range(256) for y in range(256)]
        
        'r0 << r1 = r2' with bitLength '8, 8, 1024' -> ['x << y = ?' for x in range(256) for y in range(256)]
        -> # create registers
        r0 = [0, 0];                    value = x; bitLength = 8
        r1 = [0, 1];                    value = y; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 1024
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = x
        registerB                       = y
        ->
        'x << y = ?'
        -> # output
        registerDestination             = ?
        -> # written
        r2 = [0, 2];                    value = ?; bitLength = 1024
        """

        for x, y in [(x, y) for x in range(256) for y in range(256)]:
            with self.subTest(x=x, y=y):
                r0 : int = x
                r1 : int = y
                r2_out : int = (x << y) & (2**1024 - 1)
                
                MMMU : self.dummyMMMU = self.dummyMMMU()
                MMMU.createRegister(    0, 0,                                   value = r0, bitLength = 8)
                MMMU.createRegister(    0, 1,                                   value = r1, bitLength = 8)
                MMMU.createRegister(    0, 2,                                   value = 0, bitLength = 1024)

                returnValue : None = self.ISA.opShiftL(
                    funcRead                                                    = MMMU.dummyReadWrapper,
                    funcWrite                                                   = MMMU.dummyWriteWrapper,
                    funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
                    registerDestination                                         = [0, 2],
                    registerA                                                   = [0, 0],
                    registerShiftOffset                                         = [0, 1]
                )

                expectedActivity : list[tuple[str, str | int, str | int, int]] = [ # order matters
                    ('read',            0, 0,                                   r0),
                    ('read',            0, 1,                                   r1),
                    ('getConfig',       0, 2,                                   1024),
                    ('write',           0, 2,                                   r2_out)
                ]

                resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

                expectedRegisters : list[tuple[str | int, str | int, int]] = [  # order matters
                    (0, 0,              r0),                                    # input, no change
                    (0, 1,              r1),                                    # input, no change
                    (0, 2,              r2_out)                                 # output
                ]

                resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

                self.assertEqual(returnValue, None,
                    f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
                self.assertTrue(all([i in resultActivity for i in expectedActivity]),
                    f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
                    f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
                self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
                    f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_integration01(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '0 << 0 = 0'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '0 << 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 8
        r1 = [0, 1];                    value = 0; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0
        registerB                       = 0
        ->
        '0 << 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 0
        r1 : int = 0
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_integration02(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 1 = 2'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 1; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 1
        ->
        '1 << 1 = 2'
        -> # output
        registerDestination             = 2
        -> # written
        r2 = [0, 2];                    value = 2; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 1
        r2_out : int = 2
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_integration03(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 7 = 128'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 7 = 128'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 7; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 7
        ->
        '1 << 7 = 128'
        -> # output
        registerDestination             = 128
        -> # written
        r2 = [0, 2];                    value = 128; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 7
        r2_out : int = 128
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_integration04(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 8 = 0'

        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '1 << 8 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 8
        r1 = [0, 1];                    value = 8; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 8
        ->
        '1 << 8 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 8
        """

        r0 : int = 1
        r1 : int = 8
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_integration05(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '8, 8, 8' -> '0xff << 7 = 128'
        
        'r0 << r1 = r2' with bitLength '8, 8, 8' -> '0xff << 7 = 128'
        -> # create registers
        r0 = [0, 0];                    value = 0xff; bitLength = 8
        r1 = [0, 1];                    value = 7; bitLength = 8
        r2 = [0, 2];                    value = 0; bitLength = 8
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 0xff
        registerB                       = 7
        ->
        '0xff << 7 = 128'
        -> # output
        registerDestination             = 128
        -> # written
        r2 = [0, 2];                    value = 128; bitLength = 8
        """

        r0 : int = 0xff
        r1 : int = 7
        r2_out : int = 128
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 8)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 8)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 8)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   8),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftL_integration06(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1024, 2**20' -> '1 << 2**20 - 1 = 0x8000... = 2**(2**20 - 1)'
        
        'r0 << r1 = r2' with bitLength '1, 1024, 2**20' -> '1 << 2**20 - 1 = 0x8000... = 2**(2**20 - 1)'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 2**20 - 1; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 2**20 - 1
        ->
        '1 << 2**20 - 1 = 0x8000... = 2**(2**20 - 1)'
        -> # output
        registerDestination             = 2**(2**20 - 1)
        -> # written
        r2 = [0, 2];                    value = 2**(2**20 - 1); bitLength = 2**20
        """

        r0 : int = 1
        r1 : int = 2**20 - 1
        r2_out : int = 2**(2**20 - 1)
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            # f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            # f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            # f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')
            '') # numbers contained are too large for str() method to parse and convert to string. This is a workaround

    def test_opShiftL_integration07(self):
        """tests opShiftL on 'r0 << r1 = r2' with bitLength '1, 1024, 2**20' -> '1 << 2**20 = 0'
        
        'r0 << r1 = r2' with bitLength '1, 1024, 2**20' -> '1 << 2**20 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 1; bitLength = 1
        r1 = [0, 1];                    value = 2**20; bitLength = 1024
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        ->
        opShiftL(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 2]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 1]
        )
        -> # input
        registerA                       = 1
        registerB                       = 2**20
        ->
        '1 << 2**20 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r2 = [0, 2];                    value = 0; bitLength = 2**20
        """

        r0 : int = 1
        r1 : int = 2**20
        r2_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)
        MMMU.createRegister(            0, 1,                                   value = r1, bitLength = 1024)
        MMMU.createRegister(            0, 2,                                   value = 0, bitLength = 2**20)

        returnValue : None = self.ISA.opShiftL(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 2],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 1]
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('read',                    0, 1,                                   r1),
            ('getConfig',               0, 2,                                   2**20),
            ('write',                   0, 2,                                   r2_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0),                                    # input, no change
            (0, 1,                      r1),                                    # input, no change
            (0, 2,                      r2_out)                                 # output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftR_Exception_funcReadNotFunction(self):
        """tests opShiftR raises an exception when funcRead is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opShiftR, 
                    funcRead                                                    = function, # test with invalid function
                    funcWrite                                                   = self.functionNull, 
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerShiftOffset                                         = self.registerNull, 
                    arithmetic                                                  = False
                )

    def test_opShiftR_Exception_funcWriteNotFunction(self):
        """tests opShiftR raises an exception when funcWrite is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opShiftR, 
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = function,  # test with invalid function
                    funcGetConfig                                               = self.functionNull, 
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerShiftOffset                                         = self.registerNull, 
                    arithmetic                                                  = False
                )

    def test_opShiftR_Exception_funcGetConfigNotFunction(self):
        """tests opShiftR raises an exception when funcGetConfig is not a function"""
        
        functions : list[Any] = self.functionInvalid

        function : Any
        for function in functions:
            with self.subTest(function=function):
                self.assertRaises(AssertionError, self.ISA.opShiftR, 
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = function,  # test with invalid function
                    registerDestination                                         = self.registerNull, 
                    registerA                                                   = self.registerNull, 
                    registerShiftOffset                                         = self.registerNull, 
                    arithmetic                                                  = False
                )

    def test_opShiftR_Exception_registerDestinationNotRegister(self):
        """tests opShiftR raises an exception when registerDestination is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opShiftR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = register,  # test with invalid register
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = self.registerNull,
                    arithmetic                                                  = False
                )

    def test_opShiftR_Exception_registerANotRegister(self):
        """tests opShiftR raises an exception when registerA is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opShiftR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = register,  # test with invalid register
                    registerShiftOffset                                         = self.registerNull,
                    arithmetic                                                  = False
                )

    def test_opShiftR_Exception_registerShiftOffsetNotRegister(self):
        """tests opShiftR raises an exception when registerShiftOffset is not a register"""
        
        registers : list[Any] = self.registerInvalid

        register : Any
        for register in registers:
            with self.subTest(register=register):
                self.assertRaises(AssertionError, self.ISA.opShiftR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = register,  # test with invalid register
                    arithmetic                                                  = False
                )

    def test_opShiftR_Exception_arithmeticNotBool(self):
        """tests opShiftR raises an exception when arithmetic is not a bool"""
        
        notBools : list[Any] = [i for i in (self.registerInvalid + self.functionInvalid) if i not in [True, False]]

        notBool : Any
        for notBool in notBools:
            with self.subTest(notBool=notBool):
                self.assertRaises(AssertionError, self.ISA.opShiftR,
                    funcRead                                                    = self.functionNull,
                    funcWrite                                                   = self.functionNull,
                    funcGetConfig                                               = self.functionNull,
                    registerDestination                                         = self.registerNull,
                    registerA                                                   = self.registerNull,
                    registerShiftOffset                                         = self.registerNull,
                    arithmetic                                                  = notBool
                )

    def test_opShiftR_Exception_registerDestinationNotInMMMU(self):
        """tests opShiftR passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opShiftR,
            funcRead                                                    = MMMU.dummyReadWrapper,
            funcWrite                                                   = MMMU.dummyWriteWrapper,
            funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
            registerDestination                                         = register, # test with invalid register
            registerA                                                   = self.registerNull,
            registerShiftOffset                                         = self.registerNull,
            arithmetic                                                  = False
        )

    def test_opShiftR_Exception_registerANotInMMMU(self):
        """tests opShiftR passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opShiftR,
            funcRead                                                    = MMMU.dummyReadWrapper,
            funcWrite                                                   = MMMU.dummyWriteWrapper,
            funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
            registerDestination                                         = self.registerNull,
            registerA                                                   = register, # test with invalid register
            registerShiftOffset                                         = self.registerNull,
            arithmetic                                                  = False
        )

    def test_opShiftR_Exception_registerShiftOffsetNotInMMMU(self):
        """tests opShiftR passes through a raised MMMUAccessError exception when registerShiftOffset is not in the MMMU"""
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = 0, bitLength = 8) # creates registerNull

        register : list[str | int, str | int] = [1, 1] # register not in MMMU

        self.assertRaises(MMMUAccessError, self.ISA.opShiftR,
            funcRead                                                    = MMMU.dummyReadWrapper,
            funcWrite                                                   = MMMU.dummyWriteWrapper,
            funcGetConfig                                               = MMMU.dummyGetConfigWrapper,
            registerDestination                                         = self.registerNull,
            registerA                                                   = self.registerNull,
            registerShiftOffset                                         = register, # test with invalid register
            arithmetic                                                  = False
        )

    def test_opShiftR_singleRegister01(self):
        """tests opShiftR on 'r0 >> r0 = r0' with bitLength '1, 1, 1' -> '0 >> 0 = 0'
        
        'r0 >> r0 = r0' with bitLength '1, 1, 1' -> '0 >> 0 = 0'
        -> # create registers
        r0 = [0, 0];                    value = 0; bitLength = 1
        ->
        opShiftR(
            funcRead                    = funcDummyRead
            funcWrite                   = funcDummyWrite
            funcGetConfig               = funcDummyConfig
            registerDestination         = [0, 0]
            registerA                   = [0, 0]
            registerShiftOffset         = [0, 0]
            arithmetic                  = False
        )
        -> # input
        registerA                       = 0
        registerShiftOffset             = 0
        arithmetic                      = False
        ->
        '0 >> 0 = 0'
        -> # output
        registerDestination             = 0
        -> # written
        r0 = [0, 0];                    value = 0; bitLength = 1
        """

        r0 : int = 0
        r0_out : int = 0
        
        MMMU : self.dummyMMMU = self.dummyMMMU()
        MMMU.createRegister(            0, 0,                                   value = r0, bitLength = 1)

        returnValue : None = self.ISA.opShiftR(
            funcRead                                                            = MMMU.dummyReadWrapper,
            funcWrite                                                           = MMMU.dummyWriteWrapper,
            funcGetConfig                                                       = MMMU.dummyGetConfigWrapper,
            registerDestination                                                 = [0, 0],
            registerA                                                           = [0, 0],
            registerShiftOffset                                                 = [0, 0],
            arithmetic                                                          = False
        )

        expectedActivity : list[tuple[str, str | int, str | int, int]] = [      # order matters
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('read',                    0, 0,                                   r0),
            ('getConfig',               0, 0,                                   1),
            ('write',                   0, 0,                                   r0_out)
        ]

        resultActivity : list[tuple[str, str | int, str | int, int]] = MMMU.getActivity()

        expectedRegisters : list[tuple[str | int, str | int, int]] = [          # order matters
            (0, 0,                      r0_out)                                 # input, output
        ]

        resultRegisters : list[tuple[str | int, str | int, int]] = [(i, j, MMMU.readWrittenRegister(i, j)) for i, j, _ in expectedRegisters]

        self.assertEqual(returnValue, None,
            f'\nAssert function return value is None:\nExpected None\nResult {returnValue}')
        self.assertTrue(all([i in resultActivity for i in expectedActivity]),
            f'\nAssert Activities Done:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedActivity, resultActivity)]),
            f'\nAssert Activities Done In Order:\nExpected activity:\n\t{expectedActivity}\nResult activity:\n\t{resultActivity}')
        self.assertTrue(all([i == j for i, j in zip(expectedRegisters, resultRegisters)]),
            f'\nAssert Registers Correct Value:\nExpected registers:\n\t{expectedRegisters}\nResult registers:\n\t{resultRegisters}')

    def test_opShiftR_singleRegister02(self):
        """tests opShiftR on 'r0 >> r0 = r0' with bitLength '8, 8, 8' -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_singleRegister03(self):
        """tests opShiftR on 'r0 >> r0 = r0' with bitLength '8, 8, 8' -> '2 >> 2 = 0'"""
        raise NotImplementedError

    def test_opShiftR_singleRegister04(self):
        """tests opShiftR on 'r0 >> r0 = r0' with bitLength '8, 8, 8' -> '3 >> 3 = 0'"""
        raise NotImplementedError

    def test_opShiftR_multiRegister01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1' -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_multiRegister02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1' -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_multiRegister03(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1' -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_multiRegister04(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1' -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_multiRegister05(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' -> '4 >> 1 = 2'"""
        raise NotImplementedError

    def test_opShiftR_arithmetic01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_arithmetic02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1' with arithmetic = True -> '1 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_arithmetic03(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = False -> '0xf0 >> 1 = 0x78'"""
        raise NotImplementedError

    def test_opShiftR_arithmetic04(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = True -> '0xf0 >> 1 = 0xf8'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength01A(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '0, 0, 0'  with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength02A(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8'  with arithmetic = False -> '2 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength03A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '0, 8, 8'  with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength03B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 0, 8'  with arithmetic = False -> '2 >> 0 = 2'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength03C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 0'  with arithmetic = False -> '2 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength01B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '0, 0, 0'  with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength02B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8'  with arithmetic = True -> '2 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength03A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '0, 8, 8'  with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength03B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 0, 8'  with arithmetic = True -> '2 >> 0 = 2'"""
        raise NotImplementedError

    def test_opShiftR_zeroBitLength03C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 0'  with arithmetic = True -> '2 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength01A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength01B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength01C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength01A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength01B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength01C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength02A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength02B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength02C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength02A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength02B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength02C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength03A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = False -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength03B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = False -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength03C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = False -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength03A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = True -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength03B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = True -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength03C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = True -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength04A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength04B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength04C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength04A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 1, 1' with arithmetic = True -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength04B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 8, 1' with arithmetic = True -> '1 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_variableBitLength04C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 8' with arithmetic = True -> '1 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterIndex01(self):
        """tests opShiftR on 'r1024 >> r1 = r2' with bitLength '8, 8, 8' -> '0xff >> 1 = 0x78'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterIndex02(self):
        """tests opShiftR on 'r0 >> r1024 = r2' with bitLength '8, 8, 8' -> '0xff >> 1 = 0x78'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterIndex03(self):
        """tests opShiftR on 'r0 >> r1 = r1024' with bitLength '8, 8, 8' -> '0xff >> 1 = 0x78'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize01A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize01B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize01C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = False -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize01A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize01B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize01C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = True -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize02A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize02B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize02C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = False -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize02A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize02B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize02C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = True -> '0 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize03A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = False -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize03B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = False -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize03C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = False -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize03A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = True -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize03B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = True -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize03C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = True -> '1 >> 0 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize04A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize04B1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize04C1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = False -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize04A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1024, 1, 1' with arithmetic = True -> '1 >> 1 = 0'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize04B2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1024, 1' with arithmetic = True -> '1 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize04C2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '1, 1, 1024' with arithmetic = True -> '1 >> 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize05A1(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2**20, 2**20, 2**20' with arithmetic = False -> '2**(2**20 - 1) >> (2**20 - 2) = 1'"""
        raise NotImplementedError

    def test_opShiftR_largeRegisterSize05A2(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2**20, 2**20, 2**20' with arithmetic = True -> '2**(2**20 - 1) >> (2**20 - 2) = 2**(2**20) - 1'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPattern1BitSweep01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = False -> ['(1 << x) >> (1 << y) = ?' for x in range(8) for y in range(8)]"""
        raise NotImplementedError

    def test_opShiftR_inputBitPattern1BitSweep02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '512, 512, 512' with arithmetic = False -> ['(1 << x) >> (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opShiftR_inputBitPattern1BitSweep03(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '512, 512, 2048' with arithmetic = False -> ['(1 << x) >> (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opShiftR_inputBitPattern1BitSweep01B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = True -> ['(1 << x) >> (1 << y) = ?' for x in range(8) for y in range(8)]"""
        raise NotImplementedError

    def test_opShiftR_inputBitPattern1BitSweep02B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '512, 512, 512' with arithmetic = True -> ['(1 << x) >> (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opShiftR_inputBitPattern1BitSweep03B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '512, 512, 2048' with arithmetic = True -> ['(1 << x) >> (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardConstructive01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = False -> '0b1010... >> 0b1010... = 0'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardConstructive02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = False -> '0b0101... >> 0b0101... = 0'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardDestructive01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = False -> '0b1010... >> 0b0101... = 0'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardDestructive02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = False -> '0b0101... >> 0b1010... = 0'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardConstructive01B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = True -> '0b1010... >> 0b1010... = 1'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardConstructive02B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = True -> '0b0101... >> 0b0101... = 0'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardDestructive01B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = True -> '0b1010... >> 0b0101... = 1'"""
        raise NotImplementedError

    def test_opShiftR_inputBitPatternCheckerboardDestructive02B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2048, 2048, 2048' with arithmetic = True -> '0b0101... >> 0b1010... = 0'"""
        raise NotImplementedError

    def test_opShiftR_bitpattern8bit4Overlap(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = False -> '0xfc >> 0x3f = 0'"""
        raise NotImplementedError

    def test_opShiftR_bitpattern8bit4OverlapB(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = True -> '0xfc >> 0x3f = 1'"""
        raise NotImplementedError

    def test_opShiftR_8bitFullCombination01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = False -> ['x >> y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opShiftR_8bitFullCombination02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 1024' with arithmetic = False -> ['x >> y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opShiftR_8bitFullCombination01B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = True -> ['x >> y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opShiftR_8bitFullCombination02B(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 1024' with arithmetic = True -> ['x >> y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opShiftR_integration01(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' -> '0 >> 0 = 0'"""
        raise NotImplementedError

    def test_opShiftR_integration02(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = False -> '0x80 >> 7 = 1'"""
        raise NotImplementedError

    def test_opShiftR_integration03(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = True -> '0x80 >> 7 = 0xff'"""
        raise NotImplementedError

    def test_opShiftR_integration04(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = False -> '0x80 >> 8 = 0'"""
        raise NotImplementedError

    def test_opShiftR_integration05(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '8, 8, 8' with arithmetic = True -> '0x80 >> 8 = 0xff'"""
        raise NotImplementedError

    def test_opShiftR_integration06(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2**20, 1024, 2**20' with arithmetic = False -> '0x8000... >> 2**20 - 1 = 1'"""
        raise NotImplementedError

    def test_opShiftR_integration07(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2**20, 1024, 2**20' with arithmetic = True -> '0x8000... >> 2**20 - 1 = 0xffff...'"""
        raise NotImplementedError

    def test_opShiftR_integration08(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2**20, 1024, 2**20' with arithmetic = False -> '0x8000... >> 2**20 = 0'"""
        raise NotImplementedError

    def test_opShiftR_integration09(self):
        """tests opShiftR on 'r0 >> r1 = r2' with bitLength '2**20, 1024, 2**20' with arithmetic = True -> '0x8000... >> 2**20 = 0xffff...'"""
        raise NotImplementedError

    def test_opRotate_Exception_funcReadNotFunction(self):
        """tests opRotate raises an exception when funcRead is not a function"""
        raise NotImplementedError

    def test_opRotate_Exception_funcWriteNotFunction(self):
        """tests opRotate raises an exception when funcWrite is not a function"""
        raise NotImplementedError

    def test_opRotate_Exception_funcGetConfigNotFunction(self):
        """tests opRotate raises an exception when funcGetConfig is not a function"""
        raise NotImplementedError

    def test_opRotate_Exception_registerDestinationNotRegister(self):
        """tests opRotate raises an exception when registerDestination is not a register"""
        raise NotImplementedError

    def test_opRotate_Exception_registerANotRegister(self):
        """tests opRotate raises an exception when registerA is not a register"""
        raise NotImplementedError

    def test_opRotate_Exception_registerShiftOffsetNotRegister(self):
        """tests opRotate raises an exception when registerShiftOffset is not a register"""
        raise NotImplementedError

    def test_opRotate_Exception_leftOrRightNotLeftOrRight(self):
        """tests opRotate raises an exception when leftOrRight is not 'left' or 'right''"""
        raise NotImplementedError

    def test_opRotate_Exception_registerDestinationNotInMMMU(self):
        """tests opRotate passes through a raised MMMUAccessError exception when registerDestination is not in the MMMU"""
        raise NotImplementedError

    def test_opRotate_Exception_registerANotInMMMU(self):
        """tests opRotate passes through a raised MMMUAccessError exception when registerA is not in the MMMU"""
        raise NotImplementedError

    def test_opRotate_Exception_registerShiftOffsetNotInMMMU(self):
        """tests opRotate passes through a raised MMMUAccessError exception when registerShiftOffset is not in the MMMU"""
        raise NotImplementedError

    def test_opRotate_singleRegister01(self):
        """tests opRotate on 'r0 Rotate Left r0 = r0' with bitLength '1, 1, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_singleRegister02(self):
        """tests opRotate on 'r0 Rotate Right r0 = r0' with bitLength '1, 1, 1' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_singleRegister03(self):
        """tests opRotate on 'r0 Rotate Left r0 = r0' with bitLength '8, 8, 8' -> '1 Rotate Left 1 = 2'"""
        raise NotImplementedError

    def test_opRotate_singleRegister04(self):
        """tests opRotate on 'r0 Rotate Right r0 = r0' with bitLength '8, 8, 8' -> '1 Rotate Right 1 = 0x80'"""
        raise NotImplementedError

    def test_opRotate_singleRegister05(self):
        """tests opRotate on 'r0 Rotate Left r0 = r0' with bitLength '8, 8, 8' -> '2 Rotate Left 2 = 8'"""
        raise NotImplementedError

    def test_opRotate_singleRegister06(self):
        """tests opRotate on 'r0 Rotate Right r0 = r0' with bitLength '8, 8, 8' -> '2 Rotate Right 2 = 0x80'"""
        raise NotImplementedError

    def test_opRotate_singleRegister07(self):
        """tests opRotate on 'r0 Rotate Left r0 = r0' with bitLength '8, 8, 8' -> '3 Rotate Left 3 = 0x18'"""
        raise NotImplementedError

    def test_opRotate_singleRegister08(self):
        """tests opRotate on 'r0 Rotate Right r0 = r0' with bitLength '8, 8, 8' -> '3 Rotate Right 3 = 0x60'"""
        raise NotImplementedError

    def test_opRotate_multiRegister01(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_multiRegister02(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_multiRegister03(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_multiRegister04(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_multiRegister05(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_multiRegister06(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_multiRegister07(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1' -> '1 Rotate Left 1 = 1'"""
        raise NotImplementedError

    def test_opRotate_multiRegister08(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1' -> '1 Rotate Right 1 = 1'"""
        raise NotImplementedError

    def test_opRotate_multiRegister09(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> '1 Rotate Left 1 = 2'"""
        raise NotImplementedError

    def test_opRotate_multiRegister10(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> '1 Rotate Right 1 = 0x80'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength01A(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '0, 0, 0' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength02A(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> '4 Rotate Right 1 = 2'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength03A1(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '0, 8, 8' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength03B1(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 0, 8' -> '4 Rotate Right 0 = 4'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength03C1(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 0' -> '4 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength01B(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '0, 0, 0' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength02B(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> '4 Rotate Left 1 = 8'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength03A2(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '0, 8, 8' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength03B2(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 0, 8' -> '4 Rotate Left 0 = 4'"""
        raise NotImplementedError

    def test_opRotate_zeroBitLength03C2(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 0' -> '4 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength01A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 1, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength01B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 8, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength01C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 8' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength02A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 1, 1' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength02B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 8, 1' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength02C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 8' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength03A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 1, 1' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength03B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 8, 1' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength03C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 8' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength04A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 1, 1' -> '1 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength04B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 8, 1' -> '1 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength04C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 8' -> '1 Rotate Left 1 = 2'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength01A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 1, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength01B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 8, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength01C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 8' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength02A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 1, 1' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength02B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 8, 1' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength02C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 8' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength03A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 1, 1' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength03B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 8, 1' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength03C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 8' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength04A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 1, 1' -> '1 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength04B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 8, 1' -> '1 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_variableBitLength04C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 8' -> '1 Rotate Right 1 = 0x80'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterIndex01A(self):
        """tests opRotate on 'r1024 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> '0x0f Rotate Left 0x04 = 0xf0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterIndex02A(self):
        """tests opRotate on 'r0 Rotate Left r1024 = r2' with bitLength '8, 8, 8' -> '0x0f Rotate Left 0x04 = 0xf0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterIndex03A(self):
        """tests opRotate on 'r0 Rotate Left r1 = r1024' with bitLength '8, 8, 8' -> '0x0f Rotate Left 0x04 = 0xf0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterIndex01B(self):
        """tests opRotate on 'r1024 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> '0x0f Rotate Right 0x04 = 0xf0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterIndex02B(self):
        """tests opRotate on 'r0 Rotate Right r1024 = r2' with bitLength '8, 8, 8' -> '0x0f Rotate Right 0x04 = 0xf0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterIndex03B(self):
        """tests opRotate on 'r0 Rotate Right r1 = r1024' with bitLength '8, 8, 8' -> '0x0f Rotate Right 0x04 = 0xf0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize01A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError
        
    def test_opRotate_largeRegisterSize01B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1024, 1' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize01C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1024' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize02A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1, 1' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize02B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1024, 1' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize02C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1024' -> '0 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize03A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1, 1' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize03B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1024, 1' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize03C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1024' -> '1 Rotate Left 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize04A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1, 1' -> '1 Rotate Left 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize04B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1024, 1' -> '1 Rotate Left 1 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize04C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1, 1, 1024' -> '1 Rotate Left 1 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize05A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 8, 8' -> '0xff Rotate Left 1 = 0xfe'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize05B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 1024, 8' -> '0xff Rotate Left 0xff = 0xff'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize05C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 1024' -> '0xff Rotate Left 0xff = 0xff'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize06A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 Rotate Left 0xff = ?'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize06B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 Rotate Left 0xffff = ?'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize06C1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '1024, 1024, 2**20' -> '3 Rotate Left 0xffff = ?'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize07A1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '2**20, 1024, 2**20' -> '1 Rotate Left 1 = 2'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize07B1(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '2**20, 1024, 2**20' -> '1 Rotate Left 2**20 - 1 = 2**(2**20 - 1)'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize01A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1, 1' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError
        
    def test_opRotate_largeRegisterSize01B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1024, 1' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize01C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1024' -> '0 Rotate Right 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize02A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1, 1' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize02B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1024, 1' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize02C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1024' -> '0 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize03A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1, 1' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize03B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1024, 1' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize03C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1024' -> '1 Rotate Right 0 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize04A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1, 1' -> '1 Rotate Right 1 = 0'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize04B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1024, 1' -> '1 Rotate Right 1 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize04C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1, 1, 1024' -> '1 Rotate Right 1 = 1'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize05A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 8, 8' -> '0xff Rotate Right 1 = 0x8f'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize05B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 1024, 8' -> '0xff Rotate Right 0xff = 0xff'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize05C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 1024' -> '0xff Rotate Right 0xff = 0xff'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize06A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 Rotate Right 0xff = ?'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize06B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1024, 2**20' -> '1 Rotate Right 0xffff = ?'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize06C2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '1024, 1024, 2**20' -> '3 Rotate Right 0xffff = ?"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize07A2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '2**20, 1024, 2**20' -> '1 Rotate Right 1 = 2**(2**20 - 1)'"""
        raise NotImplementedError

    def test_opRotate_largeRegisterSize07B2(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '2**20, 1024, 2**20' -> '1 Rotate Right 2**20 - 1 = 2'"""
        raise NotImplementedError

    def test_opRotate_inputBitPattern1BitSweep01A(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) Rotate Left (1 << y) = ?' for x in range(8) for y in range(8)]"""
        raise NotImplementedError

    def test_opRotate_inputBitPattern1BitSweep02A(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) Rotate Left (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opRotate_inputBitPattern1BitSweep03A(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) Rotate Left (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opRotate_inputBitPattern1BitSweep01B(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> ['(1 << x) Rotate Right (1 << y) = ?' for x in range(8) for y in range(8)]"""
        raise NotImplementedError

    def test_opRotate_inputBitPattern1BitSweep02B(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '512, 512, 512' -> ['(1 << x) Rotate Right (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opRotate_inputBitPattern1BitSweep03B(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '512, 512, 2048' -> ['(1 << x) Rotate Right (1 << y) = ?' for x in range(512) for y in range(512)]"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardConstructive01(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... Rotate Left 0b1010... = 0b1010...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardConstructive02(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... Rotate Left 0b0101... = 0b1010...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardDestructive01(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... Rotate Left 0b0101... = 0b0101...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardDestructive02(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... Rotate Left 0b1010... = 0b0101...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardConstructive01(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... Rotate Right 0b1010... = 0b1010...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardConstructive02(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... Rotate Right 0b0101... = 0b1010...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardDestructive01(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '2048, 2048, 2048' -> '0b1010... Rotate Right 0b0101... = 0b0101...'"""
        raise NotImplementedError

    def test_opRotate_inputBitPatternCheckerboardDestructive02(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '2048, 2048, 2048' -> '0b0101... Rotate Right 0b1010... = 0b0101...'"""
        raise NotImplementedError

    def test_opRotate_bitpattern8bit4OverlapA(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> '0xfc Rotate Left 0x3f = ?'"""
        raise NotImplementedError

    def test_opRotate_bitpattern8bit4OverlapB(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> '0xfc Rotate Right 0x3f = ?'"""
        raise NotImplementedError

    def test_opRotate_8bitFullCombination01A(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> ['x Rotate Left y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opRotate_8bitFullCombination02A(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 1024' -> ['x Rotate Left y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opRotate_8bitFullCombination01B(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> ['x Rotate Right y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opRotate_8bitFullCombination02B(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 1024' -> ['x Rotate Right y = ?' for x in range(256) for y in range(256)]"""
        raise NotImplementedError

    def test_opRotate_integration01(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> '0 Rotate Left 0 = 0'"""
        raise NotImplementedError

    def test_opRotate_integration02(self):
        """tests opRotate on 'r0 Rotate Left r1 = r2' with bitLength '8, 8, 8' -> '1 Rotate Left 7 = 0x80'"""
        raise NotImplementedError

    def test_opRotate_integration03(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 8' -> '1 Rotate Right 1 = 0x80'"""
        raise NotImplementedError

    def test_opRotate_integration04(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 16' -> '0xfe Rotate Left 1 = 0xfd'"""
        raise NotImplementedError

    def test_opRotate_integration05(self):
        """tests opRotate on 'r0 Rotate Right r1 = r2' with bitLength '8, 8, 2' -> '0xfe Rotate Left 1 = 1'"""
        raise NotImplementedError
    
    #TODO testing on opCopyElement

    #TODO testing on opCopyMultiElemnt

    #TODO testing on englatAdd_RippleCarry

    #TODO testing on englatMultiply_ShiftAdd1

    #TODO testing on englatMultiply_ShiftAdd2

    #TODO testing on englatAND

    #TODO testing on englatNOT

#====================================================================================================================== Main

if __name__ == "__main__":
    #Testing
    # runs all tests
    # to run a specific test module, use $> python .\CPUSimulator.py [test module ...]
    logging.basicConfig(level = logging.ERROR)
    unittest.main(verbosity = 2, buffer = True, exit = False)

    # # run specific test from a specific testCase
    # suite = unittest.TestSuite()
    # suite.addTest(TestParseDefaultBuildingBlocks("test_ruleContainer_ExceptionContainerDictionaryContainsDuplicateKeyValuePair04"))
    # runner = unittest.TextTestRunner()
    # runner.run(suite)
    
    # reset logging level
    logging.basicConfig(level = logging.INFO) # CRITICAL=50, ERROR=40, WARN=30, WARNING=30, INFO=20, DEBUG=10, NOTSET=0
    debugHighlight = lambda x : 13000 < x < 30000
    print("\n" + "".ljust(80, "=") + "\n")

    '''
    class quicktest(CPUsim_v4):
        def __init__(self):
            super().__init__()
            self.setDisplay(self.DisplaySimpleAndClean(0))
    CPU = quicktest()
    CPU.programLinkAndLoad("add(r[0], r[1], r[2]) \n halt")
    CPU.memoryInject('r', 1, 255)
    CPU.run
    result : int = CPU.memoryExtract('r', 0)
    '''

    # nameSpace : dict[str, NameSpaceObject] = {}
    # nameSpace["r"] = NameSpaceObject("registerBank", "r", None, None)
    # nameSpace["add"] = NameSpaceObject("instruction", "add", None, None)

    # program : str = "add((r[0]), (r[1], r[2])) \n halt"

    # compiler = CPUsim_v4.CompilerDefault()
    # compiler.updateNameSpace(nameSpace)
    # parser = CPUsim_v4.ParserDefault()
    # parser.updateNameSpace(nameSpace)
    
    # root, labels = parser.parseCode(program)
    # print(f"parsed code\n{root}")
    # print(f"parsed labels\n{labels}")

    # data, jump, nodes = compiler.link(root, labels, {})
    # print(f"linked code\n{data}")
    # print(f"linked jump\n{jump}")
    # print(f"linked nodes\n{nodes}")
